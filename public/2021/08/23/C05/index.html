

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Mengki">
  <meta name="keywords" content="个人博客，个人分享">
  
    <meta name="description" content="六、C语言入门——结构体&amp;ensp;&amp;ensp;实际上，我们处理的东西往往是复杂的，通常需要很多的参数去描述，比如一个人，最起码姓名性别年龄这就3个需要描述的内容了，一个变量能不能同时描述这3个属性，或许可以，比方说用字符数组，不过处理很麻烦，因为名字是字符没有问题，但年龄怎么也应该是个int类型的吧，等过了一年，年龄++，字符串改起来可是比一个数简单加1麻烦的多。&amp;ens">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言总结项目和入门——结构体与共用体">
<meta property="og:url" content="http://example.com/2021/08/23/C05/index.html">
<meta property="og:site_name" content="MengkiPage">
<meta property="og:description" content="六、C语言入门——结构体&amp;ensp;&amp;ensp;实际上，我们处理的东西往往是复杂的，通常需要很多的参数去描述，比如一个人，最起码姓名性别年龄这就3个需要描述的内容了，一个变量能不能同时描述这3个属性，或许可以，比方说用字符数组，不过处理很麻烦，因为名字是字符没有问题，但年龄怎么也应该是个int类型的吧，等过了一年，年龄++，字符串改起来可是比一个数简单加1麻烦的多。&amp;ens">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/C.jpg">
<meta property="article:published_time" content="2021-08-23T11:14:43.000Z">
<meta property="article:modified_time" content="2022-10-24T05:00:03.500Z">
<meta property="article:author" content="Mengki">
<meta property="article:tag" content="知识总结">
<meta property="article:tag" content="C">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/C.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>C语言总结项目和入门——结构体与共用体 - MengkiPage</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/fluid-extension.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<link rel="stylesheet" href="/css/indeximg-hover.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":2},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":true,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>MengkiPage</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>
    <!-- weather -->
    <!-- 添加天气 -->

<div id="he-plugin-simple"></div>
<script>
WIDGET = {
  "CONFIG": {
    "modules": "01234",
    "background": "5",
    "tmpColor": "FFFFFF",
    "tmpSize": "20",
    "cityColor": "FFFFFF",
    "citySize": "20",
    "aqiColor": "FFFFFF",
    "aqiSize": "20",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "fixed": "false",
    "vertical": "top",
    "horizontal": "left",
    "key": "ccc947744b17444186d510ec360b4500"
  }
}
</script>
<script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/playlist/">
                <i class="iconfont icon-music"></i>
                音乐
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/ownimg/inndex.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C语言总结项目和入门——结构体与共用体"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Mengki
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-08-23 19:14" pubdate>
          2021年8月23日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          14k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          116 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C语言总结项目和入门——结构体与共用体</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：6 天前
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="六、C语言入门——结构体"><a href="#六、C语言入门——结构体" class="headerlink" title="六、C语言入门——结构体"></a>六、C语言入门——结构体</h1><p>&amp;ensp;&amp;ensp;实际上，我们处理的东西往往是复杂的，通常需要很多的参数去描述，比如一个人，最起码姓名性别年龄这就3个需要描述的内容了，一个变量能不能同时描述这3个属性，或许可以，比方说用字符数组，不过处理很麻烦，因为名字是字符没有问题，但年龄怎么也应该是个int类型的吧，等过了一年，年龄++，字符串改起来可是比一个数简单加1麻烦的多。<br>&amp;ensp;&amp;ensp;鉴于对实际事物描述的复杂性，C语言引入结构体的概念（面向对象编程则使用更为全面的类结构描述）。<br>&amp;ensp;&amp;ensp;结构体就是一堆类型的集合，用来充分且合适的描述一个对象的特征，比如姓名，我们要一个字符数组，年龄要一个int，性别我们可以要一个bool值（C语言也是用int，因为bool不常见），<strong>现在我们自定义一个集合（类型），包含这三个属性，并给这个集合取名People，这就是用结构体描述人的基本操作。</strong><br>&amp;ensp;&amp;ensp;<strong>结构体是用户自定义的数据类型（这句很重要）</strong>，通过结构体的定义，将一些本身没啥联系的单元（变量所在的地方）联系在一起，组成集合。</p>
<ul>
<li><p>结构体的定义</p>
<pre><code class="hljs">  struct People
  &#123;
      int age;
      char name[50];
      char sex;
  &#125;;

  struct 结构体类型名
  &#123;
      成员列表；
  &#125;;
</code></pre>
</li>
</ul>
<p>&amp;ensp;&amp;ensp;我们定义了一个人的类型，<strong>（结尾的分号！！）。</strong></p>
<p>&amp;ensp;&amp;ensp;有了人的类型，我们怎么用呢？<br>&amp;ensp;&amp;ensp;这里我打算用类和对象的关系来说明一下结构体和其变量的关系，因为我觉得确实这两种可以有相似之处。<br>&amp;ensp;&amp;ensp;我们上面定义了一个人，但这个人是虚假的，因为你不知道它叫啥，性别和年龄，因为我们只是定义，所以<strong>这个人是虚拟的</strong>，但每个人都有我们刚定义的几种属性，这意味着我们可以用这个人去描述其他所有人（不考虑什么同名同姓之类的），所以说我们刚定义的又有通用性，我把它叫框架（类、结构体），其他所有的人（对象、结构体变量）都可以用这个框架搭建出来，它们彼此之间只是赋的值不同，<strong>而结构上没有任何区别</strong>（人和人都是骨头搭建的）。换句话说，有了这个框架，我们想创建多少个人就能搞多少个人，无非就是赋不同的值，而骨架是固定。<strong>从结构到一个个具体的人这个过程，叫实例化，表示我们从一个理论的人（只有类型）为骨架创建了一个实际的人</strong>（这里只是给成员属性赋值，对于类的实例化还可以有行为属性。）<br>&amp;ensp;&amp;ensp;比较抽象？我们现在来创建一个具体的人：<br>&amp;ensp;&amp;ensp;struct People a;<br>&amp;ensp;&amp;ensp;前面我们说过，结构体是一种用户自定义的<strong>类型</strong>，People就是我们对这种自定义的类型起的类型名，前面struct是C语言强调这个类型是结构体类型（好像现在有的版本前面不用struct了，不过还是建议写上）。struct People就是C语言对用户自定义类型的一种识别格式。上面的例子用前面的话来说就是：<strong>我们定义了一个People类型的结构体变量，叫a。</strong><br>&amp;ensp;&amp;ensp;int a；——我们定义了一个int类型的整型变量，叫a<br>&amp;ensp;&amp;ensp;两者没有区别，无非是自定义类型和本来类型的区别。<br><strong>加粗样式</strong>现在我们有了一个人了，是a，struct People a就是实例化，表示创建了一个可以<strong>实际操作</strong>的，真真实实的人，<strong>但是现在a的名字是什么，并不是a，a只是变量名，代表一个人的变量，这个人叫什么我们还没起呢</strong>，这里引出一个<strong>重点</strong>，<strong>变量是真实存在</strong>的（在内存空间中有它的专属地方），所以说它是可以实际操作的（可以对内存空间中的值改变和读写），<strong>类型是虚假的</strong>，就像前面说的，<strong>你不能对int赋值，因为int是类型，同样的你也不能对People赋值，因为People是类型，是自定义的类型，这就是结构体和结构体变量的本质区别，结构体是类型，是虚假的不能赋值，变量是确切存在的，可以操作的</strong>。（类和对象的关系也是这样的）<br>&amp;ensp;&amp;ensp;现在我们给a这个变量代表的人起名字，a是个结构体变量，它里面有结构体所包含的骨架（前面说的），这里就设计到怎么访问里面的属性。<br>&amp;ensp;&amp;ensp;我们访问地址有&amp;，*运算符，访问结构体属性也有自己的。</p>
<p><strong>点运算符（.）</strong><br>&amp;ensp;&amp;ensp;<strong>想访问什么属性，点出来就好了</strong>。<br>&amp;ensp;&amp;ensp;访问a的名字：a.name；<br>&amp;ensp;&amp;ensp;<strong>注意，结构体有的才能点出来，才能访问，你定义人这个骨架的时候都没写的东西，你怎么能指望你按照这个骨架创建出来的变量有别的东西呢</strong>？<br>&amp;ensp;&amp;ensp;我们给a的名字赋值：a.name &#x3D; “ann”;<br>&amp;ensp;&amp;ensp;a.name表示访问a中名字为name的变量，并给这个变量赋值ann，好像没啥问题，但我们name的类型是什么：数组，a.name就是char数组，数组怎么能在定义完还能直接这样赋值的呢，所以上的语句有问题的。<br>&amp;ensp;&amp;ensp;但我们给年龄什么的赋值，就不会有这样由于char数组自己导致的赋值不行的问题发生了。<br>a.age &#x3D; 15;<br>a.sex &#x3D; ‘男’;<br>&amp;ensp;&amp;ensp;上面由于我们是先定义后赋值，导致数组类型的赋值很是麻烦，我们实际上可以在定义结构体变量a的时候就给a赋值。<br>    &amp;ensp;&amp;ensp;struct People a &#x3D; {15,”ann”,’男’};<br>    &amp;ensp;&amp;ensp;注意，用大括号包含所有属性的初始值，每个属性初值之间用逗号分割，<strong>结构体里面写的顺序是什么，就按这个顺序赋值。</strong><br>    &amp;ensp;&amp;ensp;我们甚至可以直接在声明结构体的时候就定义结构体变量<br>struct People<br>{<br>    &amp;ensp;&amp;ensp;int age;<br>    &amp;ensp;&amp;ensp;char name[50];<br>    &amp;ensp;&amp;ensp;char sex;<br>}a;<br>&amp;ensp;&amp;ensp;跟在屁股后面就行了，a是结构体变量名。<br>&amp;ensp;&amp;ensp;当然也可以赋初值</p>
<pre><code class="hljs">struct People
&#123;
int age;
char name[50];
char sex;
&#125;a= &#123;15,&quot;ann&quot;,&#39;男&#39;&#125;;

struct 结构体类型名
&#123;
成员列表；
&#125;变量名列表;
</code></pre>
<p>&amp;ensp;&amp;ensp;重要的是，由于<strong>结构体也是变量类型</strong>，结构体里面的属性是变量，所以我们可以在结构体的属性里面定义别的结构体类型的变量，简单来说，<strong>结构体可以嵌套。</strong></p>
<pre><code class="hljs">struct Favourite
&#123;
int number;
int month;
&#125;;

struct People
&#123;
int age;
char name[50];
char sex;
struct Favourite fav;
&#125;a= &#123;15,&quot;ann&quot;,&#39;男&#39;,&#123;13,6&#125;&#125;;
</code></pre>
<p>&amp;ensp;&amp;ensp;这个例子中，我们添加了对人的一个描述——最喜欢的东西，我们把它也搞成结构体，类型为Favourite，由于C语言对于结构体变量定义的特殊形式，于是这个变量的定义就变成了struct Favourite fav;对变量a赋初值，前面很好理解，最后一个由于是结构体，所以初值也要用大括号括起来，就形成了大括号嵌套的形式（和结构体嵌套是同样的）<br>&amp;ensp;&amp;ensp;怎么访问结构体的结构体？一级一级点出来就OK了。a.fav.month——访问a的month属性。<br>&amp;ensp;&amp;ensp;<strong>只要抓住点运算符一级一级的访问属性，就能访问任意嵌套的结构体</strong>。<br>&amp;ensp;&amp;ensp;点运算符的优先级是最高的，所以a.age++就是我们期望的先找到age，再对age++。<br>&amp;ensp;&amp;ensp;结构体变量作为变量，当然也有地址，其属性成员也有各自的地址。<br>&amp;ensp;&amp;ensp;注意，结构体只能点名道姓的赋值和访问，不能说希望直接输入各种类型的值对其整体赋值。<br>&amp;ensp;&amp;ensp;如：</p>
<pre><code class="hljs">struct People
&#123;
int age;
char name[50];
char sex;
&#125;a;
scanf(&quot;%d,%s,%c&quot;,&amp;a);
</code></pre>
<p>&amp;ensp;&amp;ensp;希望通过这种语句直接给a整体赋值是不可以的。<br>&amp;ensp;&amp;ensp;<strong>结构体使可以相互赋值的，两个结构体a，b同类型，我想把a的值全给b，b&#x3D;a就OK，数组是不可以这样的。</strong></p>
<ul>
<li>结构体数组</li>
</ul>
<p>&amp;ensp;&amp;ensp;顾名思义，就是其元素都是结构体变量的数组。<br>&amp;ensp;&amp;ensp;有了这个，我们就可以创建很多人了。<br>&amp;ensp;&amp;ensp;定义和数组的定义一样：struct People a[5];<br>类型 数组名[大小]（<strong>结构体就是自定义的类型</strong>）</p>
<p>&amp;ensp;&amp;ensp;数组中的每一个元素都是一个People类型的结构体，访问的话，当然根据层层访问的方法，首先这是一个数组，所以要先访问数组，当我们访问到里面的元素时，发现这是个结构体变量，再使用结构体变量的访问方式。<br>&amp;ensp;&amp;ensp;a[1].age——访问第一个结构体变量的age属性。</p>
<p>&amp;ensp;&amp;ensp;我们也可以在定义结构体的时候定义其数组</p>
<pre><code class="hljs">struct People
&#123;
int age;
char sex;
&#125;a[2] = &#123;5，‘男’，6，‘女‘&#125;;
</code></pre>
<p>&amp;ensp;&amp;ensp;并采用这种一一对应的初始化方式。</p>
<ul>
<li>结构体指针</li>
</ul>
<p>&amp;ensp;&amp;ensp;结构体变量是变量，当然有指向结构体的指针了。<br>    &amp;ensp;&amp;ensp;定义和指针的定义一样：struct People *p<br>    &amp;ensp;&amp;ensp;我们让它指向刚才定义的a[0]——p &#x3D; &amp;a[0]<br>    &amp;ensp;&amp;ensp;现在我们可以通过p访问a[0]的属性了，对于指针的问题，首先搞清楚，指针指向了什么，p指向a[0]这个结构体，所以*p当然就是a[0]了，我们访问其中的age属性，再.age就OK，综上——（*p）.age。注意这里的括号是必须的，因为.运算优先级最高比*还高，不加括号就先成了p.age，这什么都不是，因为p不是结构体，怎么能用点运算符呢。<br>    &amp;ensp;&amp;ensp;对于结构体指针，我们还有更为方便的使用方法，我们想访问age属性，<strong>可以使用p-&gt;age这种形式，表示直接访问p指向的结构体的age属性</strong>（-&gt;箭头、指向的，是不是很形象），它的结果当然是age了，所以（*p）.age和p-&gt;age是等价的，当然a[0].age也是等价的，这三种访问方法就看你怎么使用了。<br>    &amp;ensp;&amp;ensp;普通的指针还能直接指向对应的数组，对于结构体指针和结构体数组当然也是如此，结构体数组名代表这个数组的首地址，我们直接p &#x3D; a；就把指针和数组挂钩了，p++呢，根据前面的元素是指向下一个元素，所以是指向数组中下一个结构体。<br>    &amp;ensp;&amp;ensp;P++的时候，p怎么知道要跳过多少个内存空间才能指向下一个元素呢？我们上一章讲过了，我们在定义p的时候就告诉它它指向的内存是多大的空间了。对于结构体也是如此。至于结构体在内存中是怎么存放的，这个还不是简单的说有多少属性就开辟多少空间，比如说我们有一个int类型，一个char[50]，一个double类型的属性的结构体，我们在定义这样的结构体变量的时候，是在内存中开辟了4+50+8&#x3D;62的内存空间吗？看起来好像确实是这样的，但实际上，我们用sizeof看一看。</p>
<pre><code class="hljs">struct People
&#123;
    int age;
    char name[50];
    double k;
&#125;a;

int main()
&#123;
    printf(&quot;%d&quot;,sizeof(a));
    return 0;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/6386c5a345dc476daa67620176cee2fa.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;平白无故多了2个，为什么，这里涉及一个内存对齐的东西，对于初学来说用处不大，知不知道也不影响咱们编程，在对应的阶段干对应的事才是合适的。<br>    &amp;ensp;&amp;ensp;简单来说，内存对齐就是为了好看，加一些空的内存空间凑个整，64大家都知道是2^6，2的倍数计算机喜欢呀，62就不好看。当然这是感性的认识，内存对齐是有好处的，对于访问的速度加快，减少访问周期什么都挺关键。<br>    &amp;ensp;&amp;ensp;现在我们有结构体指针了，我们说说结构体当函数参数。<br>    &amp;ensp;&amp;ensp;我们当然可以直接把结构体变量当参数：void fun（struct People a）<br>&amp;ensp;&amp;ensp;当我们传入一个结构体的时候，就会拷贝一份结构体给函数。这是我们前面所知道的，实参和形参的知识。<br>    &amp;ensp;&amp;ensp;重要的是，结构体不同于普通变量，它是一堆数据的集合，和数组比较像，通常一个结构体是很大的，上面的例子就有64byte，这还是很简单的一个结构体，复杂的结构体里套结构体，占的空间相当大，你现在还要拷贝一份传给函数，原本不富裕的内存更加雪上加霜。我们数组传进来的时候其实是一个指针，指针只用存储地址，通常都很小，所以从花销上来看，对于函数的参数需要结构体的时候，我们更倾向于传结构体的指针。（当然不是说直接给结构体不行）</p>
<h1 id="共用体类型"><a href="#共用体类型" class="headerlink" title="共用体类型"></a>共用体类型</h1><p>&amp;ensp;&amp;ensp;共用体和结构体很像，但却是不同的内存分配方式。</p>
<ul>
<li><p>共用体类型定义：</p>
<pre><code class="hljs">  union 共用体
  &#123;
      成员列表
  &#125;；
      union Data
  &#123;
      int i；
      double k；
      char m；
  &#125;
</code></pre>
</li>
</ul>
<p>&amp;ensp;&amp;ensp;变量定义：union Data a；当然和结构体一样的初始化和变量定义的形式都有，这里只是举个例子。<br>&amp;ensp;&amp;ensp;看起来和结构体没啥差别，<strong>但共用体共用一个内存空间</strong>，结构体是各个元素的集合，每个元素是有自己的位置的，共用体是只开辟最大变量类型的空间，里面的值由全体成员共享。<br>&amp;ensp;&amp;ensp;例如上面的Data，它实际上占了多大空间呢，答案是8byte，等于其最大的成员类型double的大小，假设我们对a.i &#x3D; 2这样付个值，由于共用体成员共用这一片内存空间，所以一变都变，k的值就变成了2.0，char的值就是2，代表的ASCII是STX。<br>&amp;ensp;&amp;ensp;<strong>共用体可以使同一存储区域的内容有多种解读形式。</strong></p>
<h1 id="枚举类型："><a href="#枚举类型：" class="headerlink" title="枚举类型："></a>枚举类型：</h1><p>&amp;ensp;&amp;ensp;枚举类型提供一个变量的几种可能。<br>    &amp;ensp;&amp;ensp;比如一个表示星期的变量，它的值只能有7中，取值情况是完全确定的，这时就可以用枚举来定义。</p>
<ul>
<li><p>枚举类型：</p>
<pre><code class="hljs">  enum 枚举名
  &#123;
      情况
  &#125;；

  enum Weekday
  &#123;
      Mon，
      Thu，
  &#125;;
</code></pre>
</li>
</ul>
<p>&amp;ensp;&amp;ensp;这里只写2个举个例子。<strong>注意用逗号分开</strong><br>&amp;ensp;&amp;ensp;同样的，定义变量和前面的相同：enum Weekday a；<br>&amp;ensp;&amp;ensp;<strong>枚举类型的变量，只能取枚举类型中有的值</strong>，如a&#x3D;2.3，a&#x3D;‘k’是不行的，a&#x3D;Mon是OK的，a&#x3D;Fri是不行的（因为我里面还没写），a&#x3D;Monday是不行的（因为里面没有）。<br>    &amp;ensp;&amp;ensp;这个Mon只在对应枚举类型中才有，平常没有说明的话谁也不知道Mon是什么，所以int I &#x3D; Mon是不行的。<br>    &amp;ensp;&amp;ensp;声明枚举类型的时候，编译器将里面的东西按常量处理，所以Mon这个符号就能像常量一样使用了。<br>    &amp;ensp;&amp;ensp;实际上，每一个枚举元素代表一个整数，开始的是0，依次往后排，a &#x3D; Thu和a &#x3D; 1是一样的，对于一个枚举类型的变量，它的值为2表示它取枚举类型中从开始往后数的第三个常量。<br>    &amp;ensp;&amp;ensp;枚举元素也可以判断，因为它们被赋予了对应的整数，Mon&gt;Thu的结果是假。</p>
<ul>
<li>typedef命名自己的变量类型</li>
</ul>
<p>&amp;ensp;&amp;ensp;和define很像，但差别也挺大的。就是给变量类型起别名。<br>&amp;ensp;&amp;ensp;<strong>首先typedef是语句不是宏定义。</strong><br>&amp;ensp;&amp;ensp;<strong>typedef int INT；——我们把整型int重命名成了INT，以后在程序中INT i表示声明一个整型变量。</strong><br>&amp;ensp;&amp;ensp;同样的，我们对结构体什么的也可以这样搞：<br>typedef struct{<br>    int num；<br>} Data；<br>    &amp;ensp;&amp;ensp;表示我们重新声明了一个Data的数据类型，是一个结构体类型。这里的分号是typedef语句的分号，和结构体定义什么的无关。<br>    &amp;ensp;&amp;ensp;Data a表示声明一个结构体变量a，struct什么的都不用写了。<br>&amp;ensp;&amp;ensp;重定义函数指针：<br>&amp;ensp;&amp;ensp;typedef int （*Point）（）；<br>&amp;ensp;&amp;ensp;定义了一个Point的函数指针类型（无参数，返回int）<br>&amp;ensp;&amp;ensp;这里使用书上的一个总结，我觉得说的很好。<br><img src="https://img-blog.csdnimg.cn/337d7b81f1df438e909a0ec224c6bca6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;下一章的文件操作，会有一个FILE的数据类型，就是由这种方法定义出来的。<br>&amp;ensp;&amp;ensp;我们下一章再见！</p>
<h1 id="代码训练与详解"><a href="#代码训练与详解" class="headerlink" title="代码训练与详解"></a>代码训练与详解</h1><p>&amp;ensp;&amp;ensp;这里我们将要综合指针和结构体的知识，完成链表结构的实现，这算是第一个比较关键的大项目了吧。<br>    &amp;ensp;&amp;ensp;首先，链表是一种数据结构，是动态开辟内存空间对数据进行分配的结构，前面我们说了，数组作为一个放数组的东西，它不能动态开辟，写成多少就是多少，它是静态的，这对我们放数据产生很大的困扰，更多时候我不知道我要放多少个，我希望我希望放多少就能放多少，这个数组明显是不行了，我们可以用更为高级的数据结构来实现，比如链表。</p>
<ul>
<li>首先我们来介绍一些知识：</li>
</ul>
<p><strong>C语言动态内存空间的分配</strong><br>&amp;ensp;&amp;ensp;我们定义变量，函数的形参传值什么的，都是编译器帮我们自动就开辟了内存空间了，我们能不能自己开辟一块内存空间，放自己想放的东西呢，当然是可以的。但是我们仍然没有办法把空间开在想开的地址上（汇编能轻松实现这个功能，这就是更底层语言的优势），地址仍是编译器选择，我们只是选择了一个自己开辟的内存。<br>&amp;ensp;&amp;ensp;系统提供了很大库函数，来实现这种操作。<br><strong>malloc函数——void* malloc(unsigned int size)</strong><br>&amp;ensp;&amp;ensp;这个函数在内存中开辟一块size大小的空间，返回这个开辟空间的首地址，这里void<em>表示这个指针没有指向任何类型，*<em>他是一个不知道指向什么类型，但确实指向了一个地方的指针，听起来比较奇怪，实际原因是手动开辟的内存没有变量属性，他就是单单一个空间，不像定义变量时开辟的内存，明确知道这是一个变量类型的区域。</em></em><br>&amp;ensp;&amp;ensp;如果函数没能成功开辟空间，就返回NULL空指针。<br>malloc（100）——开辟内存大小时100byte的空间。</p>
<p><strong>calloc函数——void* calloc(unsigned int n,unsigned int size)</strong><br>&amp;ensp;&amp;ensp;这个函数也是开辟一块空间，不同的是他是连续开辟n个大小为size的空间，这个空间的形式是不是和数组很像。<br>&amp;ensp;&amp;ensp;<strong>用这个函数可以实现动态数组，n是数组长度，size是数组元素的大小。</strong>同样的不成功放回空指针。<br>calloc（50，4）——连续开辟50个大小是4byte的空间（其内存格式和int a[50]开辟的内存格式是一样的）</p>
<p><strong>free函数——void* free(void *p)</strong><br>&amp;ensp;&amp;ensp;我们要知道，我们自己开辟的空间和编译器开的有什么区别。编译器开辟的空间受编译器管理，其空间的有效时间（存活时间）遵循生存周期的控制（前面讲的），而我们自己开的空间，编译器管不了，他只能乖乖听话说开一个多大的就开一个多大的，我们自己不释放这片空间（使其无效，相当于生存周期结束），编译器动也不感动这片区域，<strong>这就是自己开辟空间的好处，不受生存周期控制，跳出三界之外，不在五行之中。我们开辟的空间，只能由我们释放。</strong><br>&amp;ensp;&amp;ensp;但是别忘了，开辟完空间一定要记得手动释放（C和C++还是保留了手动释放内存空间的需求，C#什么的都还给编译器了不在用自己手动管了）。不然你不用了编译器也不会释放的，浪费空间。<br>&amp;ensp;&amp;ensp;free函数就是释放空间的函数，p是使用malloc或calloc函数开辟的空间的返回值，即开辟的地址。</p>
<p><strong>realloc函数——void* realloc(void* p,unsigned int size)</strong><br>&amp;ensp;&amp;ensp;对于已经用malloc或calloc函数开辟的空间，想改变其空间大小，可以用这个。<br>&amp;ensp;&amp;ensp;P是待改变的空间指针，size是新空间的大小，函数会将p指针指向的地方进行相应的改变，p指针不变。<br>&amp;ensp;&amp;ensp;<strong>这4个函数都在头文件stdlib.h中。</strong></p>
<p>&amp;ensp;&amp;ensp;现在我们来说说链表的事，我们这里只说最简单的单向链表<br>&amp;ensp;&amp;ensp;链表就是链子，把每一个单元串起来，链表中的每一个单元叫<strong>结点</strong>，每一个结点包含2部分，首先是我们要存放的数据，还有就是指向下一个结点的指针，每个结点通过这样的链式指针一个一个的指下去，从而形成了连续不断的链表结构，除结点外，链表还要有一个<strong>头指针</strong>，用来指向第一个结点，从而可以访问整个链表，同样的，对于链表的末尾，其指针应当指向空。表示后面没有结点。<br><img src="https://img-blog.csdnimg.cn/a59e49c412ad4a9e891c852047b80b4f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;<strong>链表的地址可以是不连续的，因为链表的每个元素（结点）之间是通过地址直接跳转访问，而数组的元素地址是连续的，因为数组的访问是通过地址简单的加减来访问的。</strong><br>&amp;ensp;&amp;ensp;这里的结点，很明显要包含数据和一个指针，所以结点应该是结构体。</p>
<pre><code class="hljs">struct Node
&#123;
    int num;
    struct Node *p;	
&#125;;
</code></pre>
<p>&amp;ensp;&amp;ensp;我们这里写一个简单的结点，用num表示数据，p指向下一个结点。<br>&amp;ensp;&amp;ensp;静态链表很简单，因为他的数据是现成的，只要把它们串起来就好说了<br>&amp;ensp;&amp;ensp;比如a，b，c三个结构体，里放着数据，我们来把他们串成链表<br>head &#x3D; &amp;a;<br>a.p &#x3D; &amp;b;<br>b.p &#x3D; &amp;c;<br>c,p &#x3D; NULL;<br>&amp;ensp;&amp;ensp;其中head是头指针，就这样一层一层的串下去，别忘了最后要置为NULL。</p>
<p>&amp;ensp;&amp;ensp;对于动态的链表，就麻烦一点了。<br>&amp;ensp;&amp;ensp;首先，我们要开辟一个空间来当结点，然后把数据写进去，然后再开辟一个结点，并把原来开辟的结点的指向下一个的指针指向新开的结点，逻辑很清楚，让我们来试试。<br>&amp;ensp;&amp;ensp;我们可以写下这样的代码：<br>    struct Node <em>p_next;<br>    struct Node <em>head &#x3D; malloc(sizeof(struct Node));<br>    head-&gt;num &#x3D; 0;<br>    p_next &#x3D; malloc(sizeof(struct Node));<br>    head-&gt;p &#x3D; p_next;<br>    p_next-&gt;num &#x3D; 1;<br>&amp;ensp;&amp;ensp;首先我们给头结点head开了空间，然后给他赋值为0，又开了下一个空间，用p_next来指向，并成功把head的下一个指针指向了p_next，然后赋值，现在，我们应该再新建下一个结点了，但我们发现没有可以使用的指针变量了，头节点要始终指向链表的开头，所以头节点不能再变了，我们现在还有一个p_next指针，**但我们开辟新的空间并用p_next接收的话，我们就完全失去了和前面节点的联系，还怎么让前节点的指针指向后节点呢？</em></em><br>&amp;ensp;&amp;ensp;所以实际上链表的生成是要靠2个指针完成的，它们交替前进，一个提供新开节点的信息，另一个提供上一个节点的信息，并通过这两个节点将链表串起来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEN sizeof(struct Node)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">head</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">p_old</span>;</span><span class="hljs-comment">//老指针 </span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">p_new</span>;</span><span class="hljs-comment">//新指针 </span><br>	head = <span class="hljs-built_in">malloc</span>(LEN);<br>	p_old = head;<br>	p_new = head; 		<span class="hljs-comment">//三个指针指向开始节点 </span><br>	<br>	p_old-&gt;num = <span class="hljs-number">0</span>;		<span class="hljs-comment">//对起始节点赋值 </span><br>	p_new = <span class="hljs-built_in">malloc</span>(LEN);<span class="hljs-comment">//新节点的开辟，并用新指针接收 </span><br>	p_old-&gt;p = p_new;<span class="hljs-comment">//老指针（上一个）的p指向新指针（下一个） </span><br>	p_new-&gt;num = <span class="hljs-number">1</span>;<span class="hljs-comment">//新节点赋值 </span><br>	p_old = p_new;<span class="hljs-comment">//老指针跟进——这一步很重要 </span><br>	<br>	p_new = <span class="hljs-built_in">malloc</span>(LEN);<span class="hljs-comment">//新指针再开辟，原来的变成老的节点，正好由老指针指向着</span><br><br></code></pre></td></tr></table></figure>
<p>&amp;ensp;&amp;ensp;这里两个指针的变化需要注意，总是新指针先指向开辟的空间，然后和老指针实现前面节点和新开节点的关联，然后老指针跟进，新指针再开辟，这样的一个循环过程。<br>&amp;ensp;&amp;ensp;完整代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEN sizeof(struct Node)</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-type">int</span> num;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">p</span>;</span>	<br>&#125;;<br><br><span class="hljs-keyword">struct</span> Node* <span class="hljs-title function_">Link</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Print</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node* head)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	Print(Link());<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">struct</span> Node* <span class="hljs-title function_">Link</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">head</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">p_old</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">p_new</span>;</span><br>	<span class="hljs-type">int</span> i;<br>	<br>	head = (<span class="hljs-keyword">struct</span> Node*)<span class="hljs-built_in">malloc</span>(LEN);<br>	p_old = head;<br>	p_new = head;<br>	p_old-&gt;num = <span class="hljs-number">0</span>;<br>	<br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">50</span>;i++)<br>	&#123;<br>		p_new = (<span class="hljs-keyword">struct</span> Node*)<span class="hljs-built_in">malloc</span>(LEN);<span class="hljs-comment">//开辟 </span><br>		p_new-&gt;num = i;<span class="hljs-comment">//赋值 </span><br>		p_old-&gt;p = p_new;<span class="hljs-comment">//连接 </span><br>		p_old = p_new;<span class="hljs-comment">//跟进</span><br>	&#125;<br>	p_old-&gt;p = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Print</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node* head)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">p_temp</span> =</span> head;<br>	<span class="hljs-keyword">for</span>(;p_temp != <span class="hljs-literal">NULL</span>;p_temp = p_temp-&gt;p)<br>	&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,p_temp-&gt;num);<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>&amp;ensp;&amp;ensp;这里我编了两个函数，一个是链表的创建，另一个是链表的显示（这个待会会说）<br>&amp;ensp;&amp;ensp;#define LEN sizeof(struct Node)——这是宏定义，表示将LEN和sizeof(struct Node)挂钩，编译器看见LEN就用sizeof(struct Node)替换，所以LEN 就是表示Node结构体的大小。<br>&amp;ensp;&amp;ensp;head &#x3D; (struct Node*)malloc(LEN);这里用了(struct Node*)，这是强制类型转换，因为malloc返回的是void<em>，虽然可以用struct Node</em>的指针head接收，但有得时候会报错，而且为了突出开辟空间的真实类型，可以使用强制类型转换。<br>&amp;ensp;&amp;ensp;p_old-&gt;p &#x3D; NULL;——别忘了最后一个指针指向空。<br><img src="https://img-blog.csdnimg.cn/e24474c9f97a47ebaab958ae21d3b1e9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>显示1到49（截不全），说明是成功的。<br><strong>下面我们来说说链表的操作：</strong><br><strong>链表打印</strong>:由于每一个节点存储着下一个节点的地址，这个访问就很简单了，每次访问完，让指针指向下一个，再加上最后一个指针会指向空的结束标志，就能写出上面Print函数的效果了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Find</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node* head,<span class="hljs-type">int</span> num)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">p_temp</span> =</span> head;<br>	<span class="hljs-keyword">for</span>(;p_temp != <span class="hljs-literal">NULL</span>;p_temp = p_temp-&gt;p)<br>	&#123;<br>		<span class="hljs-keyword">if</span>(p_temp-&gt;num == num)<br>		&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;FIND!--%d&quot;</span>,p_temp-&gt;num);<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>&amp;ensp;&amp;ensp;找到返回1，没有找到返回0.</p>
<p><strong>链表修改</strong>:找到后就能访问对于属性了，修改就很方便。<br><strong>链表插入</strong>:这个就比较麻烦了。<br>&amp;ensp;&amp;ensp;首先我们找到待插入的节点，然后让前一个的节点指向这个节点，让这个节点指向后面的节点，就实现了插入。但注意的是，如果插在最后，最后指向的应当为空，如果插在最前面，需要改变head头指针的指向。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node* head,<span class="hljs-keyword">struct</span> Node* temp,<span class="hljs-type">int</span> num)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">p_temp</span> =</span> head;<br>	<span class="hljs-keyword">if</span>(num == head-&gt;num)<br>	&#123;<br>		temp-&gt;p = head-&gt;p;<br>		head = temp;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<br>	<span class="hljs-keyword">for</span>(;p_temp != <span class="hljs-literal">NULL</span>;p_temp = p_temp-&gt;p)<br>	&#123;<br>		<span class="hljs-keyword">if</span>(p_temp-&gt;num == num)<br>		&#123;<br>			temp-&gt;p = p_temp-&gt;p;<br>			p_temp-&gt;p = temp;<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(p_temp-&gt;p == <span class="hljs-literal">NULL</span>)<br>		&#123;<br>			p_temp-&gt;p = temp;<br>			temp-&gt;p = <span class="hljs-literal">NULL</span>;<br>		&#125;<br>	&#125;<br>	<br>&#125;<br><br><br></code></pre></td></tr></table></figure>
<p><strong>链表删除</strong>:<br>&amp;ensp;&amp;ensp;让前面的指向后面的，然后直接把中间free就OK。注意删除的是头节点和尾节点的时候。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Del</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node* head,<span class="hljs-type">int</span> num)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">p_temp</span> =</span> head;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">p_now</span> =</span> head;<br>	<span class="hljs-keyword">if</span>(num == head-&gt;num)<br>	&#123;<br>		head = head-&gt;p;<br>		<span class="hljs-built_in">free</span>(p_temp);<br>		<span class="hljs-keyword">return</span>;	<br>	&#125;<br>	<span class="hljs-keyword">for</span>(;p_temp != <span class="hljs-literal">NULL</span>;p_now = p_temp,p_temp = p_temp-&gt;p)<br>	&#123;<br>		<span class="hljs-keyword">if</span>(p_temp-&gt;num == num)<br>		&#123;<br>			p_now-&gt;p = p_temp-&gt;p;<br>			<span class="hljs-built_in">free</span>(p_temp);<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(p_temp-&gt;p == <span class="hljs-literal">NULL</span> &amp;&amp; p_temp-&gt;p-&gt;num == num)<br>		&#123;<br>			<span class="hljs-built_in">free</span>(p_temp-&gt;p);<br>			p_temp-&gt;p = <span class="hljs-literal">NULL</span>;<br>		&#125;<br>	&#125;<br>	<br>&#125;<br><br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" class="category-chain-item">知识总结</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">#知识总结</a>
      
        <a href="/tags/C/">#C</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C语言总结项目和入门——结构体与共用体</div>
      <div>http://example.com/2021/08/23/C05/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Mengki</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2021年8月23日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2022年10月24日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/08/24/C06/" title="C语言总结项目和入门——文件操作">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">C语言总结项目和入门——文件操作</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/08/19/py01/" title="Python学习入门（个人版）">
                        <span class="hidden-mobile">Python学习入门（个人版）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments">
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"NSS2f8i8dzd2yjWuxHKDsjMK-gzGzoHsz","appKey":"jkZNtRhI868kvI72itm1QArw","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <span>Mengki</span> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
<span>全站字数：101k</span>
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    
      <script  src="/js/img-lazyload.js" ></script>
    
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/xiaoxuehua.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
