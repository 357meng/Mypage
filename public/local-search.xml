<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>故事</title>
    <link href="/2022/10/24/zizhi01/"/>
    <url>/2022/10/24/zizhi01/</url>
    
    <content type="html"><![CDATA[<p><strong>他们总觉得我傻，说我什么都不记<br>其实我只是记得少<br>比如樱花慢慢飘落<br>比如细雪覆盖山头<br>风沙的故事也总要有人记得</strong></p><p><strong>当风沙的故事渐渐被人遗忘<br>阳光不再奔跑<br>我又回到这里<br>樱花慢慢飘落，白雪覆盖山头<br>它们说<br>好久不见</strong></p><span id="more"></span><style>  /* 设置整个页面的字体 */  html, body, .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 25px;  }</style>]]></content>
    
    
    <categories>
      
      <category>诗歌</category>
      
      <category>随手写写</category>
      
    </categories>
    
    
    <tags>
      
      <tag>诗歌</tag>
      
      <tag>随便瞎写</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx服务器搭建与个人博客部署</title>
    <link href="/2022/10/19/shumeipai01/"/>
    <url>/2022/10/19/shumeipai01/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>换源： <a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu">https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu</a></p><p>如果你安装的过程中出现无法定位软件包的问题，或者下不动，可以考虑换源。</p><p>其他换源教程：<a href="https://blog.csdn.net/qq_43029747/article/details/94874442">https://blog.csdn.net/qq_43029747/article/details/94874442</a></p><p>上次搞了一个树莓派，相当于有了自己的服务器。大家应该也想着部署些什么东西上去吧。这次带来我关于服务器以及个人博客搭建的分享。Ps：虽然有了一个树莓派，但是没有温控风扇只能一直转，又吵又费电，有能力的可以自己DIY一个温控单元。加上我还在学校，经常有断网断电的现象，重启后还需要进行相关配置，所以我现在搞了一个阿里云的服务器，免费1个月，可以先用着。服务器及博客配置：<strong>nginx+hexo静态博客</strong></p><p>关于服务器，我个人理解就是部署在你本地的机器（云服务器就是在云端机器）上面的平台，负责处理网页的请求和相应，相当于本机和网络的桥梁，我们在这个平台上面搭建自己的web程序。</p><p>关于博客：网页页面分2种：动态页面和静态页面。静态页面比较简单，直接是浏览器能够读取的文本形式，如html等，有人访问的时候直接把html丢过去就行了，比较快速，缺点是管理比较麻烦，每次更新都相当于重写整个页面的代码，没有相关框架的话工程量比较大。动态页面涉及到数据库的操作，代码也是更为上层的形式，所有元素都是从库中调用的关系，有访问的时候需要在服务器先编译，把库中的内容联系起来生成浏览器可以访问的形式，再进行发送。反应比静态的慢（对于有限带宽、处理器内存也不行的话更是如此），但是适合管理和大型工程。个人博客比较简单，静态页面也有快速响应、保密性好的特点。所以个人博客大多数是静态的。如果从头开始编写html之类的代码，对于外行人属实是折磨。所以我们一般使用静态博客的框架，相当于帮助我们快速完成html等相关代码的编写，我们只需要专注于博客设计和文章就好了，你可能觉得这样博客会显的比较单调或者不能独树一帜。我当时也有这种想法，不过现在我可以说不用担心，一方面博客框架都有很多的主题可以选择，另一方面主题也会提供很多参数让你自己修改，完全能够满足个人的需求。如果你说我就想要一个前无古人后无来者的风格，你或许可以考虑自己写一个或者使用动态博客。静态博客框架有很多，我这里使用的hexo。</p><h1 id="一、web服务器：Nginx搭建"><a href="#一、web服务器：Nginx搭建" class="headerlink" title="一、web服务器：Nginx搭建"></a>一、web服务器：Nginx搭建</h1><p>首先，下载nginx：<code>sudo apt install nginx</code><br>查看版本：<code>nginx -v</code><br>下载完成后，输入nginx就可以运行（大家都是这么说）。然而如果你出现了fail to listen 80端口的情况，一般来说都是你的nginx已经在运行了。可以先关闭：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nginx -s stop<br></code></pre></td></tr></table></figure><p><img src="/2022/10/19/shumeipai01/image001.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>再启动，就ok了</p><p><strong>此时在网页输入你的ip（树莓派就是树莓派的ip，前提是在和你树莓派在同一网络的设备的浏览器上输入，当然如果你有公网ip（云服务器就自带）就都行。），能看到下面的欢迎页面就ok</strong><br><img src="/2022/10/19/shumeipai01/image003.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>Nginx重启：<code>nginx -s reload</code><br>其他Nginx教程：<a href="https://blog.csdn.net/qq_40036754/article/details/102463099?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166616431316800192281667%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166616431316800192281667&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-102463099-null-null.142%5Ev59%5Epc_search_tree,201%5Ev3%5Econtrol_1&utm_term=nginx&spm=1018.2226.3001.4187">大佬nginx学习教程</a></p><h1 id="二、博客搭建"><a href="#二、博客搭建" class="headerlink" title="二、博客搭建"></a>二、博客搭建</h1><p>由于使用静态博客框架，所以<strong>博客框架不一定要放在服务器</strong>上，比如我在我的电脑上使用博客框架，对主题进行调教，写文章，等等。等我感觉差不多了，再生成静态的文本代码等等文件，把这些文件放到服务器上，就相当于把我设计的网站部署在服务器上了。这就是静态网页的好处，设计和部署可以分开，只要把框架生成好的现成的html等等代码放到服务器上，别人就可以正常访问。当然前提是你有web平台（如nginx）。综上，<strong>我建议在自己电脑上写博客，再进行部署</strong>，能少折腾一点服务器。</p><p>博客框架有很多，我这里使用的是Hexo框架，官网：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p><p>我的电脑是windows，下面的教程也是在windows上的。</p><p>其实官网已经写的十分详细了，照着来应该不会有问题。我说说主要的操作。</p><p>首先，这个框架需要Node.js，需要提前下载：<a href="https://nodejs.org/en/%EF%BC%8C%E8%87%B3%E4%BA%8Egit%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E6%88%91%E6%84%9F%E8%A7%89%E7%9B%AE%E5%89%8D%E8%BF%98%E4%B8%8D%E7%94%A8%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BD%A0%E8%A6%81%E8%AE%B2%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%9C%A8github%E6%88%96%E8%80%85%E8%A6%81%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%AE%89%E8%A3%85git%E3%80%82%E6%9C%89%E6%A0%91%E8%8E%93%E6%B4%BE%E6%88%96%E8%80%85%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E5%85%88%E4%B8%8D%E7%94%A8%EF%BC%8C%E9%83%A8%E7%BD%B2%E4%BB%80%E4%B9%88%E7%9A%84%E5%85%88%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%B0%B1%E5%A5%BD%E4%BA%86%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%90%8E%E9%9D%A2%E5%86%8D%E8%AF%B4%E3%80%82">https://nodejs.org/en/，至于git是否需要我感觉目前还不用，如果你要讲博客部署在github或者要实现同步更新，可以安装git。有树莓派或者云服务器可以先不用，部署什么的先简单的上传文件就好了，可以后面再说。</a></p><p>下好之后安装，之后打开cmd看看有没有成功<br><img src="/2022/10/19/shumeipai01/image005.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>说明安装成功了，如果显示不是外部或内部指令啥的，需要修改一下全局变量。</p><p>参考配置全局变量：<a href="https://blog.csdn.net/zsx0806/article/details/121891980">https://blog.csdn.net/zsx0806/article/details/121891980</a></p><p>创建一个文件夹用来放hexo以及管理你的博客，之后就可以安装hexo了，cd到你刚刚创建好的文件夹，使用npm命令：<code>npm install -g hexo-cli</code><br>进行下载，使用<code>hexo -v</code>查看下载的版本，使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init<br>npm install<br></code></pre></td></tr></table></figure><p>进行安装，必须新建空文件夹，否则<br><img src="/2022/10/19/shumeipai01/image007.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>完整运行后，应该是这样的<br><img src="/2022/10/19/shumeipai01/image009.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>此时这个ttest文件夹就是你Hexo框架的文件夹了。关于其中的文件目录可以上官网看。</p><p>如果你输入hexo显示不是外部或内部指令啥的，同样需要修改一下全局变量，将hexo的文件加入，放上我个人的环境变量目录：<br> <img src="/2022/10/19/shumeipai01/image011.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>Ok之后，使用cmd在你的Hexo框架的文件夹（如上面的ttest）目录下输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g<br>hexo s<br></code></pre></td></tr></table></figure><p>打开命令行中提示网址，我这里使用了主题，所以输出和白板hexo情况下不太一样</p><p><img src="/2022/10/19/shumeipai01/image013.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>关于Hexo的文件目录，有几个比较重要：</p><ul><li><strong>public：存放生成的页面，要运行生成页面的指令后才出现这个文件夹，部署的话就将这个文件夹下的所有文件放到服务器的nginx的根目录下面就ok了（后面还会说）</strong></li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章，Hexo按照你的文章内容生成html文件。</li><li>themes：主题，选择一个好看的主题也是一大乐趣。</li><li><strong>_config.yml: 博客的配置文件</strong>，用来更好的调教你的博客，可以修改配置进行自定义个性化。具体什么是什么可以看官网，非常详细。</li></ul><p>主题：hexo官网也提供很多主题，我使用的是Fluid，当时也是在网上逛的时候看到的，使用下来感觉非常不错，安利一下，感谢大佬们的开源。<br>知乎介绍：<a href="https://zhuanlan.zhihu.com/p/137679728">https://zhuanlan.zhihu.com/p/137679728</a><br>Fluid调教方法（官方手册）：<a href="https://fluid-dev.github.io/hexo-fluid-docs/guide">https://fluid-dev.github.io/hexo-fluid-docs/guide</a><br><img src="/2022/10/19/shumeipai01/image015.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>官方文档写的也是非常详细，从安装到调教都有了，大家可以自行食用。<br>个人调教的结果：<br><img src="/2022/10/19/shumeipai01/image017.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><img src="/2022/10/19/shumeipai01/image019.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>Ps：目前博客已经部署在阿里云服务器上了，之前都是部署在我的树莓派上，后来受不了吵闹和频繁的断电断网。但是域名没有搞定，说是阿里云免费的服务器是按量的不能备案，<strong>我真的3Q</strong>。没办法又不能暴露公网IP，大家就先稍等吧。</p><p>最常用的Hexo指令，我称之为一条龙服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo g<br>hexo s <br></code></pre></td></tr></table></figure><p>分别是：清空，生成，开服务，其中hexo g这个指令很重要，<strong>它可以将你写的md文件按照你选择的主题生成静态网页文件</strong>，放在public文件夹中。</p><p>其他Hexo教程：<a href="https://zhuanlan.zhihu.com/p/44213627">https://zhuanlan.zhihu.com/p/44213627</a></p><h1 id="三、部署在服务器"><a href="#三、部署在服务器" class="headerlink" title="三、部署在服务器"></a>三、部署在服务器</h1><p>重点来了，谁能想到，这是我消耗时间最多的部分。希望我能够帮助大家少走弯路。</p><p>当你把博客调教好后，首先，重新生成一遍防止BUG，之后将public文件夹下的所有文件拷贝，上传到你的服务器的文件夹下（建议在服务器上也新建一个文件夹用来放）。树莓派可以使用VNC传输文件，云服务器没有桌面可以用Xshell的rz指令。完成之后，启动nginx，访问ip，你会发现还是nginx的欢迎页面，<strong>因为nginx的相关配置没有改</strong>，需要操作一下。</p><p><strong>重点来了</strong>，修改nginx配置，我看了极多帖子，都是说修改nginx.conf文件，这样的页面<br><img src="/2022/10/19/shumeipai01/image021.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><strong>大多数帖子是2020年的，我不知道现在还能不能行，反正我的文件中压根就没有location这块，更别提什么root了。于是我猜测是导入了其他的配置文件了，我一个一个的翻，终于找到能够生效的改root根目录的地方（使用Linux系统的情况下）。</strong></p><p><strong>&#x2F;etc&#x2F;nginx&#x2F;sites-enabled</strong>，在这个目录中有一个default文件，打开之后才是大家所说的，你会在这里看到一个root<br><img src="/2022/10/19/shumeipai01/image023.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述">把后面的目录改成指向你服务器上放hexo生成的静态文件的那个文件夹。然后保存重启nginx，不出意外，就成功了。</p><h1 id="四、内网穿透"><a href="#四、内网穿透" class="headerlink" title="四、内网穿透"></a>四、内网穿透</h1><p>博客搞好了，只能在局域网里看多没意思，我们要<strong>让公网也能访问</strong>，一种方法，搞一个公网ip和域名（云服务器），还有用内网穿透。</p><p>内网穿透具体就是让有公网访问能力的人转接你服务器的访问任务，当有人访问你的网址（通常是提供内网穿透的平台给你分配的公网可以访问的网址）时，提供内网穿透的平台会将这个来自公网的请求发送给你的局域网（前提你这个局域网要联网），再发送到你的服务器上，放回也是一样的，先返回给平台，再返回给用户，从而实现公网访问。</p><p>树莓派上实现内网穿透的有很多，我用了2个分享给大家。</p><h2 id="1-sunny内网穿透：https-www-ngrok-cc"><a href="#1-sunny内网穿透：https-www-ngrok-cc" class="headerlink" title="1.sunny内网穿透：https://www.ngrok.cc/"></a>1.sunny内网穿透：<a href="https://www.ngrok.cc/">https://www.ngrok.cc/</a></h2><p> 这个可以自定义域名，好像需要实名认证，还有花2块钱购买一个最低等级的隧道，之后就可以配置了。<br> <img src="/2022/10/19/shumeipai01/image025.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>启动的话，需要下载相关软件，官网有教程<br><img src="/2022/10/19/shumeipai01/image027.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>树莓派注意下载ARM版本的<br><img src="/2022/10/19/shumeipai01/image029.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>下载之后放在服务器上，cd到存放你刚刚下载的sunny文件的路径上，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./sunny clientid 隧道<span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><p>其中隧道id就是上面注册时分配给你的。<br>成功的话，你就可以在公网通过你的网址进行访问了。不过有时候连不上，只能说不稳定，而且响应比较慢。</p><h2 id="2-cpolar：-https-dashboard-cpolar-com-login"><a href="#2-cpolar：-https-dashboard-cpolar-com-login" class="headerlink" title="2.cpolar： https://dashboard.cpolar.com/login"></a>2.cpolar： <a href="https://dashboard.cpolar.com/login">https://dashboard.cpolar.com/login</a></h2><p>不能自定义域名，稳定性比上一个好。<br><img src="https://img-blog.csdnimg.cn/b3a11d10196c4f9eac80e36360da8c96.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>同样，下载ARM的cpolar文件，按照教程来就ok，nginx的端口一般是80。成功的话会在命令行里显示分配给你的网址，同样可以公网访问了。速度当然也慢。</p>]]></content>
    
    
    <categories>
      
      <category>知识总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树莓派</tag>
      
      <tag>服务器</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《星星变奏曲》 江河</title>
    <link href="/2022/10/13/fenxiang01/"/>
    <url>/2022/10/13/fenxiang01/</url>
    
    <content type="html"><![CDATA[<p><strong>如果大地的每个角落都充满了光明<br>谁还需要星星，谁还会<br>在夜里凝望<br>寻找遥远的安慰<br>谁不愿意<br>每天<br>都是一首诗<br>每个字都是一颗星<br>像蜜蜂在心头颤动<br>谁不愿意，有一个柔软的晚上<br>柔软得像一片湖<br>萤火虫和星星在睡莲丛中游动<br>谁不喜欢春天<br>鸟落满枝头<br>像星星落满天空<br>闪闪烁烁的声音从远方飘来<br>一团团白丁香朦朦胧胧</strong></p><p><strong>如果大地每个角落都充满了光明<br>谁还需要星星，谁还会<br>在寒冷中寂寞地燃烧<br>寻求星星点点的希望<br>谁愿意<br>一年又一年<br>总写苦难的诗<br>每一首是一群颤抖的星星<br>像冰雪覆盖心头<br>谁愿意，看着夜晚冻僵<br>僵硬得像一片土地<br>风吹落一颗又一颗瘦小的星<br>谁不喜欢飘动的旗子<br>喜欢火<br>涌出金黄的星星<br>在天上的星星疲倦的时候–升起<br>去照亮太阳照不到的地方。</strong></p><style>  /* 设置整个页面的字体 */  html, body, .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 25px;  }</style>]]></content>
    
    
    <categories>
      
      <category>分享</category>
      
      <category>诗歌</category>
      
    </categories>
    
    
    <tags>
      
      <tag>诗歌</tag>
      
      <tag>分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《春江花月夜》 【唐】（张若虚）</title>
    <link href="/2022/10/13/fenxiang00/"/>
    <url>/2022/10/13/fenxiang00/</url>
    
    <content type="html"><![CDATA[<p><strong>春江潮水连海平，海上明月共潮生。<br>滟滟随波千万里，何处春江无月明！<br>江流宛转绕芳甸，月照花林皆似霰。<br>空里流霜不觉飞，汀上白沙看不见。<br>江天一色无纤尘，皎皎空中孤月轮。<br>江畔何人初见月？江月何年初照人？<br>人生代代无穷已，江月年年望相似。<br>不知江月待何人，但见长江送流水。<br>白云一片去悠悠，青枫浦上不胜愁。<br>谁家今夜扁舟子？何处相思明月楼？<br>可怜楼上月徘徊，应照离人妆镜台。<br>玉户帘中卷不去，捣衣砧上拂还来。<br>此时相望不相闻，愿逐月华流照君。<br>鸿雁长飞光不度，鱼龙潜跃水成文。<br>昨夜闲潭梦落花，可怜春半不还家。<br>江水流春去欲尽，江潭落月复西斜。<br>斜月沉沉藏海雾，碣石潇湘无限路。<br>不知乘月几人归，落月摇情满江树。</strong></p><style>  /* 设置整个页面的字体 */  html, body, .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 25px;  }</style>]]></content>
    
    
    <categories>
      
      <category>分享</category>
      
      <category>诗歌</category>
      
    </categories>
    
    
    <tags>
      
      <tag>诗歌</tag>
      
      <tag>分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>发呆页面</title>
    <link href="/2022/10/12/fadai/"/>
    <url>/2022/10/12/fadai/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><audio id="bgmusic" src="Anan Ryoko - Refrain.mp3" autoplay="autoplay" loop="loop" style="display: block; width: 3%; height:3%;"></audio>    <script type="text/javascript">  function toggleSound() {            var music = document.getElementById("bgmusic");//获取ID                console.log(music);                console.log(music.paused);            if (music.paused) { //判读是否播放                music.paused=false;                music.play(); //没有就播放            }<pre><code class="hljs">    &#125;</code></pre><p>setInterval(“toggleSound()”,1);<br></script></p><head>    <meta charset="UTF-8">    <meta http-equiv="X-UA-Compatible" content="IE=edge">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <link rel="stylesheet" href="test.css">    <title>Mengkipage</title></head><div class="container">  <div class="planetone"></div>  <div class="cicle"></div></div><div class="planettwo"></div><div class="planetthree"></div><div class="supernova">  <span></span>  <span></span>  <span></span>  <span></span>  <span></span></div>]]></content>
    
    
    
    <tags>
      
      <tag>简简单单才是真</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派4b入门以及各种系统烧录问题分享</title>
    <link href="/2022/10/11/shumeipai00/"/>
    <url>/2022/10/11/shumeipai00/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近几天入手了一个树莓派4b，4GRAM，想着搞搞什么服务器之类的，搞了几天，现在写点东西分享一下。现在看到的就是部署在服务器上的成果。我向来讨厌说话说一半，或者就是不说重点，或者非要讲一些高深的东西劝退新人的情况，有能力的人是可以把晦涩的情况用最为朴实和善于理解的话讲明白的，这也是我追求的目标，当然我也是菜鸡，只能分享我在搞这个东西的时候的情况，但我尽量把流程说的明白一点，也方便像我一样的新手能更方便的上手吧。<br>&amp;ensp;&amp;ensp; ps：网上资源贴为什么都好陈旧，都看不到近几年的，很多方法都不知道还能不能用，对于我这种新手上手能难受啊。<br>&amp;ensp;&amp;ensp;本文提到的软件以及程序系统我都有整理，大家按需下载就好了<br><strong>链接：<a href="https://pan.baidu.com/s/125eILvcDr8-avgbSO2Eu2Q">https://pan.baidu.com/s/125eILvcDr8-avgbSO2Eu2Q</a><br>提取码：4cyu</strong></p><hr><h1 id="一、买一个树莓派"><a href="#一、买一个树莓派" class="headerlink" title="一、买一个树莓派"></a>一、买一个树莓派</h1><p>&amp;ensp;&amp;ensp;首先，你需要买一个板子，这几年树莓派涨的飞起。单单一个板子就要700+，来点配件800+，想整个8GRAM直接上千。我劝各位一定要想清楚，别让1000块吃灰。<br>&amp;ensp;&amp;ensp;4b和3b相比，先不说什么处理器有什么变化，我认为最重要的是4b的RAM有1G 2G 4G 8G（4b+）可以选择，这个比什么CPU处理能力高多少直观多了。各位可以看需求购买，毕竟越大RAM价格直线上升，要考虑一个性价比。我认为如果说就是搞搞服务器，平常跑点小程序，学学LINUX，4G就ok了，如果说只是想拿来看看视频，当个小硬盘，2G也ok，如果要跑大型程序，搞嵌入式，图像识别，深度学习，那可能要8G。<br><img src="https://img-blog.csdnimg.cn/f25ce98ed50d4003a4d17232fc28f2ac.jpeg#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;有了主板之后，一般还需要买一些配件，最主要的是，<strong>一张TF卡</strong>（32G或者64G应该都可，建议一样一个备用）<strong>和读卡器</strong>，用来刷系统。商家一般会送一个外壳，散热风扇，散热片，充电线（看你买的什么套装吧），<strong>我个人建议是搞个屏幕</strong>，不用太贵能用就行，虽然没有屏幕也可以用，但我感觉不确定因素很多，很多时候需要一个屏幕，能简化很多操作。<br><img src="https://img-blog.csdnimg.cn/a3c8e3c713274a8696e45a88567e02e2.png#pic_center" srcset="/img/loading.gif" lazyload alt="TF卡">&amp;ensp;&amp;ensp;买回来之后，先看看外观有没有问题，注意别被坑了。<br>&amp;ensp;&amp;ensp;安装散热片，把那背面的胶撕下来粘到芯片上就行了。</p><p><img src="https://img-blog.csdnimg.cn/c937df8ffe3f42d5a53e57a0e991df1f.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述">&amp;ensp;&amp;ensp;然后我建议先搞系统，因为可能会很麻烦，把树莓派先装进壳子里就不方便了。<br>&amp;ensp;&amp;ensp;安装风扇</p><p><img src="https://img-blog.csdnimg.cn/4a1c814168ef4bd7850bf9f30b246ebc.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;<strong>风扇的红线插在4脚上，黑线插在6脚上，都在外侧排针上</strong>，就行了，注意看好别插错，不然风扇不转的。<br>&amp;ensp;&amp;ensp;物理安装就差不多了，剩下的就是拧拧螺丝就可以了。</p><h1 id="二、上系统"><a href="#二、上系统" class="headerlink" title="二、上系统"></a>二、上系统</h1><p>&amp;ensp;&amp;ensp;这个过程很煎熬，不顺畅的话像我搞了两天半……<br>&amp;ensp;&amp;ensp;先说结论：<strong>为什么不乖乖用官方的烧录软件呢</strong>？网上教程各式各样，又要下格式化的，又要下烧录的，烧录的还有好几种，事先说明我全下了，因为我当时确实碰到了难以解决的问题（后文说）。最后还是觉得官方的最适合新手。当然如果你要烧录其他的系统，或者官方的烧录不行了（这也是常有的事），当我没说。但我首推官方的烧录系统。不管大家用那种，<strong>建议从头看到尾，中间说的一些东西是都适用的。</strong><br>&amp;ensp;&amp;ensp;官网：<a href="https://www.raspberrypi.com/">https://www.raspberrypi.com/</a><br><img src="https://img-blog.csdnimg.cn/bed1cc3a5a444fe68d1379e82adda65b.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述">&amp;ensp;&amp;ensp;在软件（Software）里，可以看到官方的下载器</p><p><img src="https://img-blog.csdnimg.cn/b0e85109cde44135a7e53d4beceb9b8e.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;大家电脑应该是windows吧，不是的话就下对应的就可以了，下载后安装即可。<br><img src="https://img-blog.csdnimg.cn/5742287cc11d42aead55deb5d11bf614.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;从这里可以下官方提供的系统镜像，不过要自己烧录，后面再说。<br>&amp;ensp;&amp;ensp;完成之后，打开软件，插入TF卡。</p><p><img src="https://img-blog.csdnimg.cn/328dedc7702b4e5e9334ef57dbfcb31c.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;选择烧录的系统，除了官方推荐的，还有Ubuntu和其他种类的，我这里用的是这个<br><img src="https://img-blog.csdnimg.cn/fe52784858f74502bf53f7dca907bb98.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;<strong>我选择的是带桌面的，Lite是只有命令行，Full是不但有桌面，还有一些自带软件</strong>。我手头有屏幕，桌面会帮我省很多事，大家按需下载就好。<br>&amp;ensp;&amp;ensp;<strong>注意SD卡，别选错了，烧录过程是格式化的，数据无价</strong>。<br>&amp;ensp;&amp;ensp;选好之后，右下角有个设置可以进行更改：<br><img src="https://img-blog.csdnimg.cn/c0bc05e0d2d84494b48fb84dee5618c5.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;你可以设置主机名：在路由器上你这个设备的名字。<strong>要开启SSH</strong>，后面用来远程连接树莓派。<strong>还要设置用户名和密码</strong>，这个很重要，别忘了，当然也可以用默认的，如果你用的系统是raspberry pi，默认用户名是pi，密码raspberry（ps：我看有贴说官方已经移除了默认用户，或许只能烧录的时候设置了），其他系统有所不同，这个我也没看过。你还可以配置WiFi，不过这个好像不大行可以试试，不过wifi国家一定要CN。除非你不在国内。</p><p><img src="https://img-blog.csdnimg.cn/0ed9bbc79b75471286bd0ba3202942cc.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;烧录就好了，它会自动格式化，非常简单，还有自动验证，还能省去很多配置步骤，为什么没人推荐呢？？？<br>&amp;ensp;&amp;ensp;如果不想用官方烧录，要用别的，我这里也说一下。首先，<strong>你需要一个SD卡格式工具和一个烧录工具</strong>，我下载了贴里各种软件，在链接里已经整合给大家。大家注意用管理员权限运行，否则有些会有问题。<br>链接：<a href="https://pan.baidu.com/s/125eILvcDr8-avgbSO2Eu2Q">https://pan.baidu.com/s/125eILvcDr8-avgbSO2Eu2Q</a><br>提取码：4cyu</p><p>&amp;ensp;&amp;ensp;各种软件都大同小异，首先格式化，打开格式化软件，选择SD卡格式化就ok了，如果需要选择格式化的格式，FAT32就好了（一般都没有这个选项）。<br>&amp;ensp;&amp;ensp;注：我看有的贴说快速格式化不行，要覆盖格式化（overwrite），我试过了，不行的还是不行。不过把这个信息提供给大家。<br>&amp;ensp;&amp;ensp;之后你要自己下载一个系统，从官网也可以，从别的地方也可以，下载下来的一般都是img文件。之后选择一个烧录工具，选择你的img文件，选好你要烧录到的设备，写入就ok了。<br><img src="https://img-blog.csdnimg.cn/ce0abd02ec9244eeb7eba5ff3904f1f7.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;注意，写入完成后windows会想要格式化这个设备，<strong>直接取消就行</strong>，不然就白烧了。<br>&amp;ensp;&amp;ensp;如果你用的非官方烧录，就无法直接配置设置，还需要一下操作。此时你的计算机应该应该会有一个Boot的设备，里面是烧录好的文件，<strong>在根目录也就是boot文件夹下创建一个ssh的文件，不要后缀，表示开启ssh服务。之后新建一个wpa_supplicant.conf的文件用来联网</strong>，编辑如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">country=CN<br>ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev<br>update_config=<span class="hljs-number">1</span><br> <br>network=&#123;<br>ssid=<span class="hljs-string">&quot;wifi名&quot;</span><br>psk=<span class="hljs-string">&quot;wifi密码&quot;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;按正常来说，此时你把TF卡弹出，插入树莓派就OK了，<strong>然而如果这么简单我就不会搞3天了</strong>。下面我将整理我烧录树莓派系统是出现的问题以及我查看的贴提出的解决方法。</p><h1 id="三、系统烧录故障情况"><a href="#三、系统烧录故障情况" class="headerlink" title="三、系统烧录故障情况"></a>三、系统烧录故障情况</h1><p>&amp;ensp;&amp;ensp;先上一个LED灯闪烁的情况方便大家判断情况。<br><img src="https://img-blog.csdnimg.cn/067745f6d22f46059337a9dc895e0889.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;PWR是电源红灯，ACT是SD卡绿灯，其他的4b没有就不用看了。<br>&amp;ensp;&amp;ensp;ACT闪烁情况：<br><img src="https://img-blog.csdnimg.cn/70e28dc61e564d3c9502c3f9a5d3b77a.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;下面说说我碰到的问题。</p><h2 id="1-固件问题"><a href="#1-固件问题" class="headerlink" title="1.固件问题"></a>1.固件问题</h2><p>&amp;ensp;&amp;ensp;Raspberry Pi 4B eeprom firmware,bootloader，如果固件有问题，输出屏幕会一直提示firmware的错误，<strong>拔出tf卡再上电，绿色的LED不闪说明固件挂了</strong>，需要修复，<br>&amp;ensp;&amp;ensp;树莓派4b的固件是烧录在EEPROM里的，负责引导系统，没有固件或者固件不行了有系统也进不去。修复需用一个空的TF卡。在官方的烧录里提供了修复文件的烧录（官方烧录真的省事）<br><img src="https://img-blog.csdnimg.cn/52d5579144c049ae862185d85646e8af.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;进入这个Misc开头的，选择里面的Bootloader，选择sd card boot<br><img src="https://img-blog.csdnimg.cn/b7174b1cc27445979d06d5c91e901f32.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;然后烧录到修复卡里就好了，<strong>有可能不成功，多烧几次</strong>。<br>&amp;ensp;&amp;ensp;不想用官方的，也行，上官方的github：<a href="https://github.com/raspberrypi/rpi-eeprom/tree/master/firmware/critical">官方github</a>。下载这3种最新的修复<br><img src="https://img-blog.csdnimg.cn/d56c0bcd477f4cf48df2598c80874b9b.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;放到FAT32格式话的TF卡中。修复卡就好了，问题是我试过了，感觉不一定能成功，原文链接因为看的太多找不见了……<br>&amp;ensp;&amp;ensp;实在不行我下载了官方的修复，并拷贝出来了，在链接里都有，送给大家，看看能不能用。<br>&amp;ensp;&amp;ensp;有了修复卡后，插入树莓派，上电，等一下，绿灯规律闪烁就ok了。<br>&amp;ensp;&amp;ensp;其他修复方法链接：<a href="https://www.bilibili.com/video/BV1it4y1y7uQ/">https://www.bilibili.com/video/BV1it4y1y7uQ/</a></p><h2 id="2-验证失败"><a href="#2-验证失败" class="headerlink" title="2.验证失败"></a>2.验证失败</h2><p>&amp;ensp;&amp;ensp;无论树莓派官方的烧录还是其他的，都可以提供验证操作，用来判断烧录的和原来的是不是一样，像上面的Win32DiskImager需要生成检验值，再进行检验，其他的可以自动检验。<strong>如果出现的结果是验证失败。那么你就有的罪受了，表示你的卡出问题了</strong>，具体什么问题，要进一步分析。（自动检验的烧录如果验证失败是不会烧录的，所以你TF卡还是空的）</p><h2 id="3-插入主板，报错：VFS-Unable-to-mount-root-fs-on-unknown-block-179-2"><a href="#3-插入主板，报错：VFS-Unable-to-mount-root-fs-on-unknown-block-179-2" class="headerlink" title="3.插入主板，报错：VFS Unable to mount root fs on unknown-block(179,2)"></a>3.插入主板，报错：VFS Unable to mount root fs on unknown-block(179,2)</h2><p>&amp;ensp;&amp;ensp;这是常见的错误，表示卡中的内容有问题，解决方法：</p><h3 id="1-重新格式化，重新烧录"><a href="#1-重新格式化，重新烧录" class="headerlink" title="1 重新格式化，重新烧录"></a>1 重新格式化，重新烧录</h3><p> &amp;ensp;&amp;ensp;一般没用。我看有的贴说快速格式化不行，要覆盖格式化（overwrite），我试过了，不行的还是不行。不过把这个信息提供给大家。或者用DiskGenius这种磁盘管理工具格式化，删除设备分区，再直接格式化为FAT32，再烧录，不过这个软件操作起来有风险（操作不慎电脑硬盘直接无），至于效果是不是更好我也不好说。</p><h3 id="2-将TF卡挂在在Linux系统下，用Linux指令进行修复"><a href="#2-将TF卡挂在在Linux系统下，用Linux指令进行修复" class="headerlink" title="2. 将TF卡挂在在Linux系统下，用Linux指令进行修复"></a>2. 将TF卡挂在在Linux系统下，用Linux指令进行修复</h3><p>&amp;ensp;&amp;ensp; 树莓派的系统本身也是Linux，用Linux修复Linux。但是首先，我们需要一个Linux系统。方法如下：</p><ul><li><p>WSL：适用于 Linux 的 Windows 子系统，可以在windows下面搞linux，最新的是wsl2。在控制面版中选择程序，程序和功能下面的启用或关闭windows功能。<br><img src="https://img-blog.csdnimg.cn/815ea0b230fd468aa36d3babfc979daf.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>找到这两个，打勾开启，重启电脑<br><img src="https://img-blog.csdnimg.cn/fcae3909850b4bb183e4a82d19ce0402.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>之后在自带的微软商店里找Ubuntu或者搜Linux<br> <img src="https://img-blog.csdnimg.cn/04c8fecad3954a2f835ec4c0f795e296.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><strong>能不能下载，就看各位的造化了</strong>，成功的话，打开就是Linux的命令行了。<br>另外的设置方法：<a href="https://blog.csdn.net/weixin_45027467/article/details/106862520">https://blog.csdn.net/weixin_45027467/article/details/106862520</a></p></li><li><p>虚拟机大法好<br> &amp;ensp;&amp;ensp;很明显我方法1没有成功，迫不得已只能上虚拟机了。VMware虚拟机，用免费的player版本，官网；<a href="http://www.vmware.com/cn%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%90%8E%E5%AE%89%E8%A3%85%E5%B0%B1ok%E3%80%82">http://www.vmware.com/cn，下载后安装就ok。</a><br>&amp;ensp;&amp;ensp;除此之外，还需要一个Linux的镜像，我用的是Ubuntu。<strong>都在链接里</strong>。<br>&amp;ensp;&amp;ensp;准备好之后，新建虚拟机<br><img src="https://img-blog.csdnimg.cn/4d6852c7fb784558b7a4c5a5e48a01ca.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;选择下载好的系统镜像<br><img src="https://img-blog.csdnimg.cn/de246ac087f343e5a4a044a596da50ba.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;设置名称密码，之后就是选择虚拟机位置，选择一个剩余空间大点的盘，虚拟机占用的比较多，剩下的按推荐就好了。<br>&amp;ensp;&amp;ensp;成功之后重启，就有一个Ubuntu的虚拟机了。插入TF卡，选择接入虚拟机，就可以进行接下来的操作了。<br>&amp;ensp;&amp;ensp;其他虚拟机安装教程：<a href="https://zhuanlan.zhihu.com/p/41940739">https://zhuanlan.zhihu.com/p/41940739</a></p></li><li><p>修复操作：<br>&amp;ensp;&amp;ensp;打开命令行：桌面ctrl+alt+t，查看sd卡分区</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fdisk -l<br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;找到sd卡的分区：一般为&#x2F;dev的分区<br>&amp;ensp;&amp;ensp;修复：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fsck.ext4 -v /dev/sdb2<br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fsck -f -v -r /dev/sdb2<br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;一般需要root权限，在指令前面加上sudo，如sudo fsck -f -v -r &#x2F;dev&#x2F;sdb2就ok了。<br>&amp;ensp;&amp;ensp;如果成功，就ok了。可惜我没有成功……<br>其他Linux修复：<a href="https://blog.csdn.net/cp562090732/article/details/46618347">https://blog.csdn.net/cp562090732/article/details/46618347</a><br><a href="https://blog.csdn.net/qq_37082966/article/details/110231836">https://blog.csdn.net/qq_37082966/article/details/110231836</a><br><a href="https://blog.csdn.net/lhl_blog/article/details/106952234">https://blog.csdn.net/lhl_blog/article/details/106952234</a></p><h2 id="3-Linux修复报错"><a href="#3-Linux修复报错" class="headerlink" title="3.Linux修复报错"></a>3.Linux修复报错</h2><p>&amp;ensp;&amp;ensp;在我尝试修复时，Linux报错resize2fs: Bad magic number in super-block，超级块损坏，我按照后面的修复提示操作了，没有用。网上说还有什么分区表出错什么的情况，我本来对Linux也不熟，对磁盘修复什么的就更不会了，网上的帖子看也看不懂，最后只能止步于此。<strong>GG</strong></p><h2 id="4-烧录过程或者格式化过程中弹出拒绝访问"><a href="#4-烧录过程或者格式化过程中弹出拒绝访问" class="headerlink" title="4.烧录过程或者格式化过程中弹出拒绝访问"></a>4.烧录过程或者格式化过程中弹出拒绝访问</h2><ul><li>a.弹出TF卡再插入（一般就ok，不行重启电脑）</li><li>b.用DiskGenius删除分区格式化后再新建分区。</li></ul><h2 id="5-其他尝试"><a href="#5-其他尝试" class="headerlink" title="5.其他尝试"></a>5.其他尝试</h2><p>&amp;ensp;&amp;ensp;我还在虚拟机中下了官方的烧录，在虚拟机中进行烧录，结果是一样的验证失败。我还尝试烧录Ubuntu的系统，插入树莓派后直接就是找不到内核。我还看到有Noobs可以绕过烧录进行系统安装，不过我在官网上已经找不到资源了。</p><p>&amp;ensp;&amp;ensp;<strong>最后，当我搞到超级块损坏的时候，我就觉得我这个TF卡估计是歇菜了，当时图便宜从咸鱼上买了2张64G的，到头来没一个能用的，我只好在淘宝上买了32G的TF卡，到货后，官方烧录直接通过，啥事没有。看到这里还没解决的朋友，我劝你想想是不是TF卡的原因，在买个好点的试试。虽然我最后没有解决问题，但我还是把我解决的经历分享出来，希望能帮助到大家。</strong></p><h1 id="四、进系统后的设置"><a href="#四、进系统后的设置" class="headerlink" title="四、进系统后的设置"></a>四、进系统后的设置</h1><ul><li>有屏幕的话，直接接个鼠标键盘就能用了，没有屏幕的话，要先联SSH。<br><strong>保证你电脑和树莓派在之前设置好的同一wifi里</strong>。</li><li>查看树莓派ip：由于我有屏幕，直接就能看，没有屏幕的话也有办法，我从网上看到了一些方法，其中ip扫描的软件我也放链接里了，但我没用过：<br><a href="https://www.labno3.com/2021/08/02/finding-the-ip-address-of-your-raspberry-pi/">https://www.labno3.com/2021/08/02/finding-the-ip-address-of-your-raspberry-pi/</a><br><a href="https://blog.csdn.net/Mark_md/article/details/107689003">https://blog.csdn.net/Mark_md/article/details/107689003</a></li><li>本地电脑用SSH连接需要下软件，推荐Xshell（链接里都有）<br>安装之后，打开，新建会话<br><img src="https://img-blog.csdnimg.cn/8c1b88f545a24bbd81369e8a1b94e7a2.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><strong>在主机里输入树莓派的ip</strong>，就行了，连接时需要输入树莓派的名称和密码，就是在烧录时候设置的。</li><li>能够进入命令行后，基本就完事了，可以先更新一下系统和软件。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get upgrade<br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;觉得下载太慢的可以换源，我这里速度还行，就没换。</p><ul><li>树莓派的系统设置：输入<code>sudo raspi-config</code><br>里面可以改树莓派的一些设置，像时区什么的，也可以改中文，不过建议先安中文字库<br>安装中文字库：<code>sudo apt-get install ttf-wqy-zenhei</code><br>安装中文输入法:<code>sudo apt-get install scim-pinyin</code>（安了但我用不了，很奇怪）</li><li>扩展分区：在sudo raspi-config后的主页面中选择Advanced Options，选择A1 Expand Filesystem确定就好了，系统会把分区扩展到整个TF卡。</li><li>开启VNC：有桌面的话可以用这个，相当于远程桌面。在sudo raspi-config后的主页面中选择Interfacing Options,找到VNC将它enable就ok了。电脑需要下载客户端，连接方法和SSh一样，用ip就行了。</li></ul><p>&amp;ensp;&amp;ensp;现在你可以用自己电脑操作树莓派了，树莓派的初始化就差不多了，开始装软件吧。<br>&amp;ensp;&amp;ensp;<strong>关于静态IP的问题</strong>：我尝试设置静态ip，结果直接上不了网了，最后重装系统才行的，我再想想看怎么搞。<br>&amp;ensp;&amp;ensp;<strong>我也不是万能的，我只是把我入手树莓派的经历分享出来，有很多问题和情况我没有碰到或者没有说明的，各位可以去看看别的贴。</strong><br>&amp;ensp;&amp;ensp;谢谢大家。<br>资源链接；链接：<a href="https://pan.baidu.com/s/125eILvcDr8-avgbSO2Eu2Q">https://pan.baidu.com/s/125eILvcDr8-avgbSO2Eu2Q</a><br>提取码：4cyu</p>]]></content>
    
    
    
    <tags>
      
      <tag>树莓派</tag>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>String类常见用法总结（C++）</title>
    <link href="/2022/01/27/Cplusplus00/"/>
    <url>/2022/01/27/Cplusplus00/</url>
    
    <content type="html"><![CDATA[<h1 id="一、构造函数"><a href="#一、构造函数" class="headerlink" title="一、构造函数"></a>一、构造函数</h1><table><thead><tr><th>string a;</th><th>默认构造</th></tr></thead><tbody><tr><td>string a(b);</td><td>拷贝构造</td></tr><tr><td>string a(“abc”);</td><td>初始化为字符串“abc”</td></tr><tr><td>string a(n,’c’);</td><td>用n个‘c’初始化</td></tr><tr><td>string a(cs,3);</td><td>用字符数组cs的前3个初始化（char cs[]）</td></tr></tbody></table><p>注：以下均为成员函数</p><h1 id="二、赋值"><a href="#二、赋值" class="headerlink" title="二、赋值"></a>二、赋值</h1><table><thead><tr><th>重载等号运算符&#x3D;</th><th>可以用const char*类型，string类型，char类型当右值进行赋值</th></tr></thead><tbody><tr><td>assign(elem)</td><td>elem可以为const char*类型，string类型</td></tr><tr><td>assign(n,c)</td><td>用n个c字符赋值</td></tr><tr><td>assign(const char* s ,int n)</td><td>将s字符串前n个进行赋值</td></tr></tbody></table><h1 id="三、访问"><a href="#三、访问" class="headerlink" title="三、访问"></a>三、访问</h1><table><thead><tr><th>operator[]</th><th>重载运算符</th></tr></thead><tbody><tr><td>at(int id)</td><td>通过id访问字符</td></tr></tbody></table><h1 id="四、字符串拼接"><a href="#四、字符串拼接" class="headerlink" title="四、字符串拼接"></a>四、字符串拼接</h1><table><thead><tr><th>重载+&#x3D;运算符</th><th>可以接const char*类型，string类型，char类型</th></tr></thead><tbody><tr><td>append(elem)</td><td>elem可以为const char*类型，string类型</td></tr><tr><td>append(const char*s,int n)</td><td>把s中的前n个字符拼接到字符串的末尾</td></tr><tr><td>append(const string &amp;s,int pos,int n)</td><td>字符串从s开始的n个字符拼接到末尾</td></tr></tbody></table><h1 id="五、字符串插入"><a href="#五、字符串插入" class="headerlink" title="五、字符串插入"></a>五、字符串插入</h1><table><thead><tr><th>insert(pos,s)</th><th>在pos位置插入字符串s</th></tr></thead><tbody><tr><td>insert(pos,str,a,n)</td><td>在pos位置插入str中从a处位置开始的n个字符</td></tr><tr><td>insert(pos,str,n)</td><td>在pos位置插入str字符的前n个</td></tr><tr><td>insert(pos,n,ch)</td><td>在pos位置插入n个ch</td></tr></tbody></table><h1 id="六、字符串删除"><a href="#六、字符串删除" class="headerlink" title="六、字符串删除"></a>六、字符串删除</h1><table><thead><tr><th>erase(int a,int b)</th><th>删除从a开始的 b个字符</th></tr></thead><tbody><tr><td>erase(pos1,pos2)</td><td>删除从迭代器pos1到pos2的字符</td></tr><tr><td>erase(pos)</td><td>删除迭代器pos指向的字符</td></tr></tbody></table><h1 id="七、字符串子串"><a href="#七、字符串子串" class="headerlink" title="七、字符串子串"></a>七、字符串子串</h1><table><thead><tr><th>substr(pos,n)</th><th>返回从pos开始的n个字符组成的字符串</th></tr></thead><tbody><tr><td>substr(pos)</td><td>返回从pos开始到结尾组成的字符串</td></tr></tbody></table><h1 id="八、字符串查找、替换"><a href="#八、字符串查找、替换" class="headerlink" title="八、字符串查找、替换"></a>八、字符串查找、替换</h1><p>未找到返回-1</p><table><thead><tr><th>find(const string &amp;s,int pos&#x3D;0)</th><th>从pos位置查找字符串s第一次出现的位置</th></tr></thead><tbody><tr><td>find(const char*s,int pos&#x3D;0)</td><td>从pos位置查找字符串s第一次出现的位置</td></tr><tr><td>find(const char*s,int pos,int n)</td><td>从pos位置查找字符串s前n个字符第一次出现的位置</td></tr><tr><td>find(const char c,int pos&#x3D;0)</td><td>从pos查找字符c第一次出现的位置</td></tr><tr><td>rfind(const string &amp;s,int pos&#x3D;npos)</td><td>从pos查找字符串s最后一次出现的位置</td></tr><tr><td>rfind(const char*s,int pos&#x3D;npos)</td><td>从pos查找字符串s最后一次出现的位置</td></tr><tr><td>rfind(const char*s,int pos,int n)</td><td>从pos查找字符串s前n个字符最后一次出现的位置</td></tr><tr><td>rfind(const char c,int pos&#x3D;0)</td><td>从pos查找字符c最后一次出现的位置</td></tr><tr><td>replace(int pos,int n,const string&amp; s)</td><td>替换从pos开始的n个字符串为s</td></tr><tr><td>replace(int pos,int n,const char* s)</td><td>替换从pos开始的n个字符串为s</td></tr></tbody></table><h1 id="九、字符串比较"><a href="#九、字符串比较" class="headerlink" title="九、字符串比较"></a>九、字符串比较</h1><table><thead><tr><th>compare(s)</th><th>和s进行比较相等返回0，大于返回1，小于返回-1</th></tr></thead><tbody><tr><td>重载运算符</td><td>&lt;,&gt;,&#x3D;&#x3D;</td></tr></tbody></table><h1 id="十、转换"><a href="#十、转换" class="headerlink" title="十、转换"></a>十、转换</h1><table><thead><tr><th>to_string(val)</th><th>把val转换为字符串</th></tr></thead><tbody><tr><td>stoi(s,p,b)</td><td>把字符串从p开始变为b进制的int</td></tr><tr><td>stol(s,p,b)</td><td>变long</td></tr><tr><td>stoul(s,p,b)</td><td>变unsigned long</td></tr><tr><td>stoll(s,p,b)</td><td>变long long</td></tr><tr><td>stoull(s,p,b)</td><td>变unsigned long long</td></tr><tr><td>stof(s,p)</td><td>变float</td></tr><tr><td>stod(s,p)</td><td>变double</td></tr><tr><td>stold(s,p)</td><td>变long double</td></tr></tbody></table><ul><li>用stringstream，头文件sstream<br>用stringstream类，定义变量，输入流，再输出<br><strong>多次转换必须清空流！</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">stringstream ss;<br><span class="hljs-type">int</span> k;<br>string s;<br>cin&gt;&gt;s;<br>ss&lt;&lt;s;<span class="hljs-comment">//输入流 </span><br>ss&gt;&gt;k;<span class="hljs-comment">//输出，完成转换</span><br>ss.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">//清空 </span><br></code></pre></td></tr></table></figure><p>实现从字符串到int的转换，反过来也可以<br>多个字符串拼接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">sstream &lt;&lt; <span class="hljs-string">&quot;a&quot;</span> &lt;&lt; <span class="hljs-string">&quot;1&quot;</span> &lt;&lt; <span class="hljs-string">&quot;b&quot;</span>;<br>   sstream &lt;&lt; <span class="hljs-string">&quot;2c&quot;</span>;<br>   cout &lt;&lt; sstream.<span class="hljs-built_in">str</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>实现拼接</p>]]></content>
    
    
    <categories>
      
      <category>知识总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识总结</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL常用容器用法大全</title>
    <link href="/2022/01/26/Cplusplus01/"/>
    <url>/2022/01/26/Cplusplus01/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>整合总结一下C++的STL库中常用的一些容器</p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="一、vector：向量"><a href="#一、vector：向量" class="headerlink" title="一、vector：向量"></a>一、vector：向量</h1><p>&amp;ensp; &amp;ensp;变长数组，单端数组，要包含头文件vector</p><ol><li>构造函数</li></ol><table><thead><tr><th>vector&lt;T&gt; v  ;</th><th>默认构造函数，空的</th></tr></thead><tbody><tr><td>vector&lt;T&gt; v(20);</td><td>初始化20个空间，初始值全0</td></tr><tr><td>vector&lt;T&gt; v(n,elem);</td><td>用elem初始化n个空间</td></tr><tr><td>vector&lt;T&gt; v(a.begin(),a.end());</td><td>将a的起始迭代器和中止迭代器之间的内容当v的初始值（包含起始迭代器，不包含终止迭代器）</td></tr><tr><td>vector&lt;T&gt; v(a);</td><td>拷贝构造</td></tr></tbody></table><ol start="2"><li>成员函数</li></ol><p>a.赋值</p><table><thead><tr><th>assign(n,elem)</th><th>将n个elem赋值</th></tr></thead><tbody><tr><td>assign(beg，end)</td><td>将[beg,end)之间的元素拷贝赋值（迭代器）</td></tr><tr><td>重载等号运算符</td><td>vector&amp; operator&#x3D;(const vector &amp;vec)——v1&#x3D;v2;</td></tr></tbody></table><p>b.访问</p><table><thead><tr><th>at(int idx)</th><th>返回索引idx指向的数据</th></tr></thead><tbody><tr><td>重载运算符 operator[]</td><td>——像数组一样访问</td></tr><tr><td>front()</td><td>返回第一个元素的引用</td></tr><tr><td>back()</td><td>返回最后一个元素的引用</td></tr></tbody></table><p>c.属性</p><table><thead><tr><th>size()</th><th>返回容器中元素个数</th></tr></thead><tbody><tr><td>empty()</td><td>判断容器是否为空</td></tr><tr><td>capacity()</td><td>返回容器容量</td></tr><tr><td>resize(int num)</td><td>改变容量为num</td></tr></tbody></table><p>d.迭代器函数</p><table><thead><tr><th>begin()</th><th>返回第一个元素的迭代器</th></tr></thead><tbody><tr><td>end()</td><td>返回最后一个元素后一个位置的迭代器</td></tr><tr><td>rbegin()</td><td>返回最后一个元素的逆序迭代器</td></tr><tr><td>rend()</td><td>返回第一个元素的前一个位置的逆序迭代器</td></tr></tbody></table><p>e.操作</p><table><thead><tr><th>push_back(a)</th><th>把a加入最后</th></tr></thead><tbody><tr><td>pop_back()</td><td>删除最后一个元素</td></tr><tr><td>insert(pos,a)</td><td>向pos迭代器指向的位置插入a</td></tr><tr><td>insert(pos,a,elem)</td><td>向pos迭代器指向的位置插入a个elem</td></tr><tr><td>erase(pos)</td><td>删除pos指向的元素</td></tr><tr><td>erase(sta,pos)</td><td>删除迭代器sta到pos的元素</td></tr><tr><td>clear()</td><td>清空元素</td></tr><tr><td>swap(vec)</td><td>实现于vec容器的交换</td></tr></tbody></table><h1 id="二、deque：双端数组"><a href="#二、deque：双端数组" class="headerlink" title="二、deque：双端数组"></a>二、deque：双端数组</h1><p>双端数组，头文件deque</p><ol><li>构造函数</li></ol><table><thead><tr><th>deque&lt;T&gt; v  ;</th><th>默认构造函数，空的</th></tr></thead><tbody><tr><td>deque&lt;T&gt; v(20);</td><td>初始化20个空间，初始值全0</td></tr><tr><td>deque&lt;T&gt; v(n,elem);</td><td>用elem初始化n个空间</td></tr><tr><td>deque&lt;T&gt; v(a.begin(),a.end());</td><td>将a的起始迭代器和中止迭代器之间的内容当v的初始值（包含起始迭代器，不包含终止迭代器）</td></tr><tr><td>deque&lt;T&gt; v(a);</td><td>拷贝构造</td></tr></tbody></table><ol start="2"><li>成员函数</li></ol><p>a.赋值</p><table><thead><tr><th>assign(n,elem)</th><th>将n个elem赋值</th></tr></thead><tbody><tr><td>assign(beg，end)</td><td>将[beg,end)之间的元素拷贝赋值（迭代器）</td></tr><tr><td>重载等号运算符</td><td>operator&#x3D;</td></tr></tbody></table><p>b.访问</p><table><thead><tr><th>at(int idx)</th><th>返回索引idx指向的数据</th></tr></thead><tbody><tr><td>重载运算符 operator[]</td><td>——像数组一样访问</td></tr><tr><td>front()</td><td>返回第一个元素的引用</td></tr><tr><td>back()</td><td>返回最后一个元素的引用</td></tr></tbody></table><p>c.属性</p><table><thead><tr><th>size()</th><th>返回容器中元素个数</th></tr></thead><tbody><tr><td>empty()</td><td>判断容器是否为空</td></tr><tr><td>capacity()</td><td>返回容器容量</td></tr><tr><td>resize(int num)</td><td>改变容量为num</td></tr></tbody></table><p>d.迭代器函数</p><table><thead><tr><th>begin()</th><th>返回第一个元素的迭代器</th></tr></thead><tbody><tr><td>end()</td><td>返回最后一个元素后一个位置的迭代器</td></tr><tr><td>rbegin()</td><td>返回最后一个元素的逆序迭代器</td></tr><tr><td>rend()</td><td>返回第一个元素的前一个位置的逆序迭代器</td></tr></tbody></table><p>e.操作</p><table><thead><tr><th>push_back(elem)</th><th>尾加</th></tr></thead><tbody><tr><td>push_front(elem)</td><td>头加</td></tr><tr><td>pop_back()</td><td>尾删</td></tr><tr><td>pop_front()</td><td>头删</td></tr><tr><td>insert(pos,a)</td><td>向pos迭代器指向的位置插入a</td></tr><tr><td>insert(pos,a,elem)</td><td>向pos迭代器指向的位置插入a个elem</td></tr><tr><td>erase(pos)</td><td>删除pos指向的元素</td></tr><tr><td>erase(beg,end)</td><td>清除[beg,end)的内容</td></tr><tr><td>clear()</td><td>清空元素</td></tr></tbody></table><h1 id="三、stack：栈"><a href="#三、stack：栈" class="headerlink" title="三、stack：栈"></a>三、stack：栈</h1><p>栈，头文件stack，不允许遍历，只能访问栈顶</p><ol><li>构造函数</li></ol><table><thead><tr><th>stack&lt;T&gt; v  ;</th><th>默认构造函数，空的</th></tr></thead><tbody><tr><td>stack&lt;T&gt; v(a);</td><td>拷贝构造</td></tr></tbody></table><ol start="2"><li>成员函数</li></ol><p>a.操作</p><table><thead><tr><th>push(elem)</th><th>入栈</th></tr></thead><tbody><tr><td>pop()</td><td>出栈，删除栈顶元素</td></tr><tr><td>top()</td><td>返回栈顶第一个元素的引用;</td></tr></tbody></table><p>b.属性</p><table><thead><tr><th>size()</th><th>返回容器中元素个数</th></tr></thead><tbody><tr><td>empty()</td><td>判断容器是否为空</td></tr></tbody></table><h1 id="四、queue：队列"><a href="#四、queue：队列" class="headerlink" title="四、queue：队列"></a>四、queue：队列</h1><p>头文件queue，不可以遍历,只有头尾可以访问</p><ol><li>构造函数</li></ol><table><thead><tr><th>queue&lt;T&gt; v  ;</th><th>默认构造函数，空的</th></tr></thead><tbody><tr><td>queue&lt;T&gt; v(a);</td><td>拷贝构造</td></tr></tbody></table><ol start="2"><li>成员函数</li></ol><table><thead><tr><th>push(elem)</th><th>入队</th></tr></thead><tbody><tr><td>pop()</td><td>出队</td></tr><tr><td>back()</td><td>返回最后一个元素</td></tr><tr><td>front()</td><td>返回第一个元素</td></tr><tr><td>empty()</td><td>是否为空</td></tr><tr><td>size()</td><td>队大小</td></tr></tbody></table><h1 id="五、list：链表"><a href="#五、list：链表" class="headerlink" title="五、list：链表"></a>五、list：链表</h1><p>链表，头文件list，STL中是双向循环链表，列表迭代器只能前移和后移，不支持随机访问</p><ol><li>构造函数</li></ol><table><thead><tr><th>list&lt;T&gt; v  ;</th><th>默认构造函数，空的</th></tr></thead><tbody><tr><td>list&lt;T&gt; v(20);</td><td>初始化20个空间，初始值全0</td></tr><tr><td>list&lt;T&gt; v(n,elem);</td><td>用elem初始化n个空间</td></tr><tr><td>list&lt;T&gt; v(a.begin(),a.end());</td><td>将a的起始迭代器和中止迭代器之间的内容当v的初始值（包含起始迭代器，不包含终止迭代器）</td></tr><tr><td>list&lt;T&gt; v(a);</td><td>拷贝构造</td></tr></tbody></table><ol start="2"><li>成员函数</li></ol><p>a.赋值</p><table><thead><tr><th>assign(n,elem)</th><th>将n个elem赋值</th></tr></thead><tbody><tr><td>assign(beg，end)</td><td>将[beg,end)之间的元素拷贝赋值（迭代器）</td></tr><tr><td>重载等号运算符</td><td>operator&#x3D;</td></tr></tbody></table><p>b.访问</p><table><thead><tr><th>front()</th><th>返回第一个元素的引用</th></tr></thead><tbody><tr><td>back()</td><td>返回最后一个元素的引用</td></tr></tbody></table><p>c.属性</p><table><thead><tr><th>size()</th><th>返回容器中元素个数</th></tr></thead><tbody><tr><td>empty()</td><td>判断容器是否为空</td></tr><tr><td>resize(num,elem)</td><td>改变大小为num，多出的用elem填充</td></tr><tr><td>resize(int num)</td><td>改变容量为num</td></tr></tbody></table><p>d.迭代器函数</p><table><thead><tr><th>begin()</th><th>返回第一个元素的迭代器</th></tr></thead><tbody><tr><td>end()</td><td>返回最后一个元素后一个位置的迭代器</td></tr><tr><td>rbegin()</td><td>返回最后一个元素的逆序迭代器</td></tr><tr><td>rend()</td><td>返回第一个元素的前一个位置的逆序迭代器</td></tr></tbody></table><p>e.操作</p><table><thead><tr><th>push_back(elem)</th><th>尾加</th></tr></thead><tbody><tr><td>push_front(elem)</td><td>头加</td></tr><tr><td>pop_back()</td><td>尾删</td></tr><tr><td>pop_front()</td><td>头删</td></tr><tr><td>insert(pos,a)</td><td>向pos迭代器指向的位置插入a</td></tr><tr><td>insert(pos,a,elem)</td><td>向pos迭代器指向的位置插入a个elem</td></tr><tr><td>insert(pos,beg,end)</td><td>在pos指向的地方插入[beg,end)区间内的内容</td></tr><tr><td>erase(pos)</td><td>删除pos指向的元素</td></tr><tr><td>erase(beg,end)</td><td>清除[beg,end)的内容</td></tr><tr><td>clear()</td><td>清空元素</td></tr><tr><td>remove(elem)</td><td>删除所有与elem值匹配的内容</td></tr><tr><td>unique()</td><td>删除容器中相邻的重复元素，只留下一个</td></tr><tr><td>reverse()</td><td>反转链表</td></tr><tr><td>sort(fun)</td><td>排序，默认升序，成员函数（所有不支持随机访问迭代器的容器都不能用标准算法），可用fun指明排序规则</td></tr></tbody></table><h1 id="六、set：集合"><a href="#六、set：集合" class="headerlink" title="六、set：集合"></a>六、set：集合</h1><p>集合，包含头文件set，关联式容器，自动排序，不容许有重复元素</p><p><strong>mutiset：可以重复插入数据</strong></p><ol><li>构造函数</li></ol><table><thead><tr><th>set&lt;T&gt; v  ;</th><th>默认构造函数，空的</th></tr></thead><tbody><tr><td>set&lt;T&gt; v(a.begin(),a.end());</td><td>将a的起始迭代器和中止迭代器之间的内容当v的初始值（包含起始迭代器，不包含终止迭代器）</td></tr><tr><td>set&lt;T&gt; v(a);</td><td>拷贝构造</td></tr></tbody></table><ol start="2"><li>成员函数</li></ol><p>a.赋值</p><table><thead><tr><th>重载等号运算符</th><th>operator&#x3D;</th></tr></thead></table><p>b.访问</p><table><thead><tr><th>find(key)</th><th>存在，返回指向该元素的迭代器，不存在返回end()迭代器</th></tr></thead><tbody><tr><td>count(key)</td><td>统计key出现的次数，set只有0、1两种取值，mutiset可以大于1</td></tr><tr><td>lower_bound(val)</td><td>返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器</td></tr><tr><td>upper_bound(val)</td><td>返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器</td></tr><tr><td>equal_range(val)</td><td>返回对组，first和second所构成的区间值为val</td></tr></tbody></table><p>c.属性</p><table><thead><tr><th>size()</th><th>返回容器中元素个数</th></tr></thead><tbody><tr><td>empty()</td><td>判断容器是否为空</td></tr></tbody></table><p>d.迭代器函数</p><table><thead><tr><th>begin()</th><th>返回第一个元素的迭代器</th></tr></thead><tbody><tr><td>end()</td><td>返回最后一个元素后一个位置的迭代器</td></tr><tr><td>rbegin()</td><td>返回最后一个元素的逆序迭代器</td></tr><tr><td>rend()</td><td>返回第一个元素的前一个位置的逆序迭代器</td></tr></tbody></table><p>e.操作</p><table><thead><tr><th>insert(elem)</th><th>插入elem元素，返回是否成功</th></tr></thead><tbody><tr><td>erase(pos)</td><td>删除pos指向的元素</td></tr><tr><td>erase(beg,end)</td><td>清除[beg,end)的内容</td></tr><tr><td>erase(elem)</td><td>删除值为elem的元素</td></tr><tr><td>clear()</td><td>清空元素</td></tr></tbody></table><h1 id="七、pair：对组"><a href="#七、pair：对组" class="headerlink" title="七、pair：对组"></a>七、pair：对组</h1><p>对组，不用包含头文件，把两个元素捆绑为对组。</p><ol><li>构造函数</li></ol><table><thead><tr><th>pair&lt;T1,T2&gt; p(V1,V2);</th><th>V1为first，V2为second</th></tr></thead><tbody><tr><td>pair&lt;T1,T2&gt; p &#x3D; make_pair(V1,V2);</td><td></td></tr></tbody></table><ol start="3"><li>访问<br>p.first——第一个元素<br>p.second——第二个元素</li></ol><h1 id="八、map：字典"><a href="#八、map：字典" class="headerlink" title="八、map：字典"></a>八、map：字典</h1><p>字典，头文件map，所存的元素为pair，所有元素按键值排序，键值不能重复</p><p><strong>mutimap：key可以重复</strong></p><ol><li>构造函数</li></ol><table><thead><tr><th>map&lt;T1，T2&gt; v  ;</th><th>默认构造函数，空的</th></tr></thead><tbody><tr><td>map&lt;T1，T2&gt; v(a);</td><td>拷贝构造</td></tr></tbody></table><ol start="2"><li>成员函数</li></ol><p>a.赋值</p><table><thead><tr><th>重载等号运算符</th><th>operator&#x3D;</th></tr></thead></table><p>b.访问</p><table><thead><tr><th>find(key)</th><th>返回指向key键的元素迭代器，没有返回end()</th></tr></thead><tbody><tr><td>count(key)</td><td>统计key个数</td></tr><tr><td>operator[]</td><td>重载[]运算符，通过key索引查找value，key不存在会新建添加</td></tr><tr><td>lower_bound(val)</td><td>返回一个指向当前 map 容器中key第一个小于或等于 val 的元素的双向迭代器</td></tr><tr><td>upper_bound(val)</td><td>返回一个指向当前map 容器中key第一个大于 val 的元素的迭代器</td></tr><tr><td>equal_range(val)</td><td>返回对组，first和second所构成的区间值为val</td></tr></tbody></table><p>c.属性</p><table><thead><tr><th>size()</th><th>返回容器中元素个数</th></tr></thead><tbody><tr><td>empty()</td><td>判断容器是否为空</td></tr></tbody></table><p>d.迭代器函数</p><table><thead><tr><th>begin()</th><th>返回第一个元素的迭代器</th></tr></thead><tbody><tr><td>end()</td><td>返回最后一个元素后一个位置的迭代器</td></tr><tr><td>rbegin()</td><td>返回最后一个元素的逆序迭代器</td></tr><tr><td>rend()</td><td>返回第一个元素的前一个位置的逆序迭代器</td></tr></tbody></table><p>e.操作</p><table><thead><tr><th>insert(elem)</th><th>插入elem元素，返回是否成功</th></tr></thead><tbody><tr><td>erase(pos)</td><td>删除pos指向的元素</td></tr><tr><td>erase(beg,end)</td><td>清除[beg,end)的内容</td></tr><tr><td>erase(elem)</td><td>删除值为elem的元素</td></tr><tr><td>clear()</td><td>清空元素</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>知识总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识总结</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言总结项目和入门大作业——信息管理系统（多文件版）</title>
    <link href="/2021/09/01/C07/"/>
    <url>/2021/09/01/C07/</url>
    
    <content type="html"><![CDATA[<h1 id="八、C语言入门大作业——信息管理系统（多文件版）"><a href="#八、C语言入门大作业——信息管理系统（多文件版）" class="headerlink" title="八、C语言入门大作业——信息管理系统（多文件版）"></a>八、C语言入门大作业——信息管理系统（多文件版）</h1><p>&amp;ensp;&amp;ensp;C语言大作业学过的都知道这是一个对C语言综合应用的考核，也是对项目开发的实践，<strong>信息管理系统是C语言历史悠久的压轴</strong>，因为它用来综合使用C语言在合适不过了，今天我也用这个来做为这一系列的结尾，希望大家都能用C语言实现自己期望的目标和项目。<br>&amp;ensp;&amp;ensp;<strong>信息管理只要4个核心功能——增删查改。</strong><br>&amp;ensp;&amp;ensp;信息管理系统的东西还是很多的，我这里精简一下，我们只要来实现<strong>5大功能：新建、查找、删除、修改、清空，并在文件中保存。同时我们将再次使用多文件编程（DevC++版），补充前面对多文件编程的漏洞，详细讲述条件编译和外部变量在多文件中的使用，我们将接触更多的系统函数，以及很多新鲜的用法。</strong><br>&amp;ensp;&amp;ensp;大家或许会觉得程序之间的关联性很强，一下子理不清关系，这是正常的，因为这个程序是我写完之后我知道什么是什么，不同函数遵循什么的规定，这些是我规划了很长时间才出来的，我会尽量讲的详细一点，大家多看肯定能看懂的。</p><h2 id="一、功能模块的划分："><a href="#一、功能模块的划分：" class="headerlink" title="一、功能模块的划分："></a>一、功能模块的划分：</h2><p>&amp;ensp;&amp;ensp;大型项目首先要知道我们需要实现什么功能，再把这些功能向下划分，形成一个个可重复利用的函数，这也是封装的一种（自顶向下）。<br>&amp;ensp;&amp;ensp;首先，我们有5个功能，最起码5个函数就有了吧，其次我们还要保存在文件中，文件的读写函数也要有，2+5&#x3D;7个了，这是第一级划分，还可以再向下细分，这里就因人而异了，当然随时把现成的代码块封装成函数也是可以的，功能细分只是可以让你对这个项目有更好的认识。</p><h2 id="二、多文件的编写"><a href="#二、多文件的编写" class="headerlink" title="二、多文件的编写"></a>二、多文件的编写</h2><p>&amp;ensp;&amp;ensp;一般来说，同一类功能的函数（math.h）或者同一文件中的函数放在同一个文件中。我这里使用了2个文件，一个文件放和文件读写相关的函数，另一个放和这个项目有关的所有函数。当然这样还是笼统的分，分多少文件也看个人习惯，这里做简单处理，就分2个吧，再加上对应的头文件和main函数文件，本项目共5个文件。<br>&amp;ensp;&amp;ensp;Dev c++多文件编写：<br>&amp;ensp;&amp;ensp;首先，打开。<br><img src="https://img-blog.csdnimg.cn/de24ce9dd98a4522a8510edeaca32fca.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pif5aScLueni-WjsA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>文件—新建—项目（<strong>所有的多文件工程都要新建项目</strong>）<br><img src="https://img-blog.csdnimg.cn/aa7b9f4e72f5452ea3d2ce51781e4fe2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pif5aScLueni-WjsA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>我们选第二个：控制台程序，并选择C语言<br><img src="https://img-blog.csdnimg.cn/232531de4f664a249458d98c9298cb25.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pif5aScLueni-WjsA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;选择一个保存项目的地方。<strong>最好新建一个属于这个项目的文件夹，方便后续添加文件。</strong><br>&amp;ensp;&amp;ensp;保存，OK，项目就好了。<br>&amp;ensp;&amp;ensp;它会自动提供一个main函数模板</p><p><img src="https://img-blog.csdnimg.cn/19d03920e1c74e708684099e77336af7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pif5aScLueni-WjsA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>咱们用自己写的，不用它这个。<br><img src="https://img-blog.csdnimg.cn/b65b2b399abe475ea8bd93c2e9545f4b.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>左侧项目管理可以管理这个项目的文件，咱们先把它自带的这个移除，右键移除就OK。<br>然后就可以添加自己的文件了，我们先新建一个文件<br><img src="https://img-blog.csdnimg.cn/ab86a3ea320b46b0bd00214dd92fc504.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pif5aScLueni-WjsA==,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>第一个，然后把main函数写进去，保存为main.c（前面的章节讲过了，这里略）<br>右键项目（就上面这个5（你自己命名的项目名））-添加，找到刚刚的文件就OK了。<br>用这种方法把需要的5个文件添加进去。<br>这里我已经规划好了，所以文件是直接全部新建导入的，实际在开发中文件是随时整理，随时编写的，什么时候觉得需要就可以搞。<br><img src="https://img-blog.csdnimg.cn/248bedc4231249a0a5fb640b3172d24b.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><h2 id="三、基本函数的实现（重点）"><a href="#三、基本函数的实现（重点）" class="headerlink" title="三、基本函数的实现（重点）"></a>三、基本函数的实现（重点）</h2><p>&amp;ensp;&amp;ensp;我们把所有函数都进行封装，使main函数得到精简。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> temp=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(temp)<br>&#123;<br><span class="hljs-keyword">switch</span>(Menu())<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>Build();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>Seek();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>Amend();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>Delete();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>Clear();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>temp = <span class="hljs-number">0</span>;<br>&#125;<br>getchar();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;这是最终main函数的样子。其余所有功能都靠函数实现，这些东西都会讲到，莫急莫急。</p><ul><li>菜单函数<br>首先我们来实现<strong>菜单函数</strong>。<br>菜单函数很简单，显示选择项，输入选项，OK了，</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Menu</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-keyword">do</span>&#123;<br>system(<span class="hljs-string">&quot;cls&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n\n\n\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t\t\t   \n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t\t|----------信息管理系统----------|\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t\t|\t1.新建联系人             |\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t\t|\t2.查看联系人             |\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t\t|\t3.修改联系人             |\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t\t|\t4.删除联系人             |\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t\t|\t5.清空联系人             |\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t\t|\t6.退出                   |\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t\t|--------------------------------|\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t\t请输入选项&lt;1~6&gt;:&quot;</span>);<br><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">6</span>||n&lt;<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入有误，请重新输入\a&quot;</span>);<br>getchar();<br>getchar();<br>system(<span class="hljs-string">&quot;cls&quot;</span>);<br>&#125;<br>&#125;<span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">6</span>||n&lt;<span class="hljs-number">1</span>);<br>getchar();<br><span class="hljs-keyword">return</span> n;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;需要注意的是，我们通过菜单函数的返回值来判断用户输入了几，同时对于非法输入，应当提示重新输入，保证完整性。<br>&amp;ensp;&amp;ensp;<strong>这个system(“cls”);是什么，这是一个系统函数，看system就知道了，cls是它的参数，实现的功能是小黑窗清屏，就是清除之前小黑窗（控制台命令行）的所有内容</strong>，由于我们这个程序会不断的循环执行，时间长了东西会很多，这里采用每次显示菜单的时候就进行清屏刷新的方式。<br>&amp;ensp;&amp;ensp;大家会发现这里用了很多好像没啥用的getchar();前面说了，这是读取一个字符的函数，但没有接收它的返回值，所以它相当于<strong>白读</strong>，实际上它<strong>起到的作用是阻碍程序进行</strong>，当程序运行到这里，它必须等待一个输入才能继续，<strong>相当于按任意键继续的感觉</strong>，由于我们有清屏函数的存在，如果程序不停的话，它printf的东西我们还没看呢，清屏了，啥也没有，就很难受。<br>&amp;ensp;&amp;ensp;有时候会连续出现2个getchar();这是因为上一次的键盘输入会产生输入的缓存，需要先用一个来消除，然后才能正确接收，只用一个的话就直接从缓存中读了一个字符，而和我们的输不输入没啥关系了，<strong>所以要先消耗缓存中的字符，这一点在输入字符串的时候尤为关键。</strong><br>菜单函数和main函数放在一起了。</p><p>&amp;ensp;&amp;ensp;好了，接下来重头戏来了，我们写一下<strong>主体功能</strong>的实现<br>&amp;ensp;&amp;ensp;首先，我们写一下我们管理的东西的一些信息，我这里是用的人。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br><span class="hljs-type">char</span> phone[<span class="hljs-number">15</span>];<span class="hljs-comment">//手机 </span><br><span class="hljs-type">char</span> name[<span class="hljs-number">100</span>];<span class="hljs-comment">//名字 </span><br><span class="hljs-type">char</span> num[<span class="hljs-number">20</span>];<span class="hljs-comment">//工号 </span><br><span class="hljs-type">char</span> ad[<span class="hljs-number">50</span>];<span class="hljs-comment">//地址 </span><br><span class="hljs-type">char</span> sex;<span class="hljs-comment">//性别 </span><br><span class="hljs-type">int</span> age;<span class="hljs-comment">//年龄 </span><br>&#125;People;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;同时用typedef重新定义这个结构体为People，现在我们就有了People这个数据类型了。<br>&amp;ensp;&amp;ensp;我们需要不断输入，通过输入判断是否结束，这意味着我们需要用链表来存储，我们再写一个链表的结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>People peo;<br><span class="hljs-type">int</span> id;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>* <span class="hljs-title">p_next</span>;</span><br>&#125;Node;<br><br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;这是链表中的节点结构体，包含这个节点存放的信息peo，这个节点的id，下一个节点的指针。并重定义为Node。</p><ul><li>新建函数</li></ul><p>&amp;ensp;&amp;ensp;接下来，我们将编写“增”——新建函数，在此之前先来说说我的思路。编写程序最重要的就是思路，思路有了编不出来就是对这个语言的了解不够，当你不知道如何实现，没有思路的时候，数据结构和算法就是时候去学习一下了。<br>&amp;ensp;&amp;ensp;<strong>我们用链表结构存放我们输入的数据，如果我们没有输入特定的结束字符，就一直新建，同时我们用一个全局变量来记录我们生成了多少个节点（数据），这个数字将存在文件中表示文件中存放了多少个数据。</strong><br>&amp;ensp;&amp;ensp;Ps：虽然按道理我们只要一块一块的写入，再一块一块的读出，是能够正好读完的，用文件的结束标志就能完全读入，本应没必要再记录，但我写的程序总是会多载入一些乱码数据，以我的实力难以解决，只能出此下策。如有大神能指点迷津，甚是感谢！<br>&amp;ensp;&amp;ensp;需要注意的是，数据新建的时候是分为2种情况的，之前有数据和之前没有数据，要分开处理。我们做如下规定：当没有数据时，head指针为空，当存在数据时，head指针指向数据.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//新建函数，返回头节点 </span><br>Node* <span class="hljs-title function_">Create</span><span class="hljs-params">(Node* head)</span><br>&#123;<br>Node* p_old,*p_new;<br>People t;<br><br><span class="hljs-keyword">if</span>(!Input(&amp;t))<br>&#123;<br><span class="hljs-keyword">return</span> head;<span class="hljs-comment">//没有新建 </span><br>&#125;<br><span class="hljs-keyword">if</span>(!head)<br>&#123;<br>head = (Node*)<span class="hljs-built_in">malloc</span>(LEN);<br>p_old = head;<br>p_new = head;<br>p_new-&gt;id = <span class="hljs-number">0</span>;<br>p_new-&gt;peo = t;<br>p_new-&gt;p_next = <span class="hljs-literal">NULL</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>p_new = (Node*)<span class="hljs-built_in">malloc</span>(LEN);<br><span class="hljs-keyword">for</span>(p_old = head;p_old-&gt;p_next != <span class="hljs-literal">NULL</span>;p_old = p_old-&gt;p_next);<br>p_old-&gt;p_next = p_new;<br>p_new-&gt;id = p_old-&gt;id+<span class="hljs-number">1</span>;<br>p_old = p_new;<br>p_new-&gt;peo = t;<br>p_new-&gt;p_next = <span class="hljs-literal">NULL</span>;<br>&#125;<br>Number++;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(!Input(&amp;t))<br>&#123;<br><span class="hljs-keyword">return</span> head; <br>&#125;<br><br>p_new = (Node*)<span class="hljs-built_in">malloc</span>(LEN);<br>Number++;<br>p_new-&gt;id = p_old-&gt;id+<span class="hljs-number">1</span>;<br>p_new-&gt;peo = t;<br>p_old-&gt;p_next = p_new;<br>p_new-&gt;p_next = <span class="hljs-literal">NULL</span>;<br>p_old = p_new;<br><br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们用一个局部变量t来接收每次的输入。<br>我还编了一个<strong>输入函数</strong>，实现每次的输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//输入函数 </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Input</span><span class="hljs-params">(People* p)</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n输入姓名（输入#中止）：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;p-&gt;name);<br><span class="hljs-keyword">if</span>(p-&gt;name[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入年龄：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;p-&gt;age);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入性别(m-男,f-女)：&quot;</span>);<br>getchar();<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;p-&gt;sex);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入手机号：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;p-&gt;phone);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入地址：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;p-&gt;ad);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入工号:(没有输入-1)&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;p-&gt;num);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;<strong>通过一个People的指针的传入，直接对对应位置的结构体赋值。并规定退出符号——名字输入#，则返回0，表示输入结束符号，否则返回1，表示正常输入</strong>。其他的都是小玩意，可有可无的。我这里是考虑到不是人人都有编号，所以对编号的输入进行了规定，这些都是小问题。<br>&amp;ensp;&amp;ensp;当输入结束时，就返回头指针。对于第一次输入就退出的话，相当于没有新建，就把头指针原封不动的返回去。对于有新输入的话，我们会在后面进行合适的处理，保证头指针指向的链表是完整的。<br>&amp;ensp;&amp;ensp;当输入有效时，我们就可以建立空间存放这个新数据了，这里分2中情况，第一次新建和之前有数据，这个可以根据头指针来区分。<br>&amp;ensp;&amp;ensp;对于新建的，就好说了，我们直接新建一个空间，放刚刚输入的数据（**结构体可以直接赋值p_new-&gt;peo &#x3D; t;**）并让id&#x3D;0。对于之前存在数据的话，我们先新建一个节点空间，并通过<br>&amp;ensp;&amp;ensp;for(p_old &#x3D; head;p_old-&gt;p_next !&#x3D; NULL;p_old &#x3D; p_old-&gt;p_next);<br>&amp;ensp;&amp;ensp;这一个for循环定位原来数据的最后一个，这是一个循环体为空的for循环，大家知道for循环的机制应该是可以明白的，当p_old指向的下一个节点为NULL时，即为最后一个节点，此时p_old就定位在最后一个节点上。<br>&amp;ensp;&amp;ensp;之后就是关联，id递加，赋值，老节点跟进，和前面链表的时候一样的。</p><p>&amp;ensp;&amp;ensp;由于我们开始的时候新建了一个，全局变量Number+1，表示多了一个，很好理解。<br>&amp;ensp;&amp;ensp;之后循环输入，用死循环+条件退出的形式。每次新建，关联，id递加，赋值，老节点跟进，并更新Number，没啥好说的。<br>&amp;ensp;&amp;ensp;<strong>重点是：每次新建的节点，我都会让它的下一个节点指向默认为NULL，这样如果输入结束的话，直接返回头指针，也可以保证链表最后一个指针指向NULL，从而保证链表的完整性。</strong></p><ul><li>查找函数：</li></ul><p>&amp;ensp;&amp;ensp;我们提供除id以外的全因素查找，我这里id是当作内部资源不对外开放的，虽然也有id的查找函数但是内部使用的。缺点是只能返回查找到的第一个，原本我希望的是能返回所有符合结果的id号构成的数组，但这样的话需要一个动态数组来实现，工程量又大了不少，等我以后有空再更新吧。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//查找函数，head-头指针，k-方式选择 </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Find</span><span class="hljs-params">(Node* head,<span class="hljs-type">int</span> k)</span><br>&#123;<br><span class="hljs-type">char</span> n[<span class="hljs-number">50</span>];<br><span class="hljs-type">int</span> m;<br>Node *p = head;<br><span class="hljs-keyword">switch</span>(k)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-comment">//名字查 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入查找姓名:&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,n);<br>FindName(n,head);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-comment">//年龄查 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入查看的年龄：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);<br>FindAge(m,head);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-comment">//手机号查</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入查找的手机号:&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,n);<br>FindPhone(n,head);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-comment">//地址查</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入查找地址:&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,n);<br>FindAd(n,head);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<span class="hljs-comment">//性别查</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入查找性别m-男，f-女:&quot;</span>);<br>getchar();<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;n[<span class="hljs-number">0</span>]);<br>FindSex(n[<span class="hljs-number">0</span>],head);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<span class="hljs-comment">//工号查</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入查找工号:&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,n);<br>FindNum(n,head);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<span class="hljs-comment">//全部显示</span><br>ShowAll(head);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>: <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入错误\a\n&quot;</span>);<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里我对于每种方式的查找都封装了自己函数，其实它们大同小异。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//想实现能全部找到返回各个序号的，但这需要动态数组，比较麻烦 </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">FindName</span><span class="hljs-params">(<span class="hljs-type">char</span> name[],Node* head)</span><br>&#123;<br>Node *p = head;<br><span class="hljs-keyword">for</span>(;p;p = p-&gt;p_next)<br>&#123;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(p-&gt;peo.name,name))<br>&#123;<br>Print(&amp;p-&gt;peo);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查无此人\a&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">FindAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age,Node *head)</span><br>&#123;<br>Node *p = head;<br><span class="hljs-keyword">for</span>(;p;p = p-&gt;p_next)<br>&#123;<br><span class="hljs-keyword">if</span>(p-&gt;peo.age == age)<br>&#123;<br>Print(&amp;p-&gt;peo);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查无此人\a&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">FindPhone</span><span class="hljs-params">(<span class="hljs-type">char</span> Phone[],Node* head)</span><br>&#123;<br>Node *p = head;<br><span class="hljs-keyword">for</span>(;p;p = p-&gt;p_next)<br>&#123;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(p-&gt;peo.phone,Phone))<br>&#123;<br>Print(&amp;p-&gt;peo);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查无此人\a&quot;</span>);<br><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">FindAd</span><span class="hljs-params">(<span class="hljs-type">char</span> ad[],Node* head)</span><br>&#123;<br>Node *p = head;<br><span class="hljs-keyword">for</span>(;p;p = p-&gt;p_next)<br>&#123;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(p-&gt;peo.ad,ad))<br>&#123;<br>Print(&amp;p-&gt;peo);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查无此人\a&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">FindSex</span><span class="hljs-params">(<span class="hljs-type">char</span> sex,Node* head)</span><br>&#123;<br>Node *p = head;<br><span class="hljs-keyword">for</span>(;p;p = p-&gt;p_next)<br>&#123;<br><span class="hljs-keyword">if</span>(sex == p-&gt;peo.sex)<br>&#123;<br>Print(&amp;p-&gt;peo);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查无此人\a&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">FindNum</span><span class="hljs-params">(<span class="hljs-type">char</span> num[],Node* head)</span><br>&#123;<br>Node *p = head;<br><span class="hljs-keyword">for</span>(;p;p = p-&gt;p_next)<br>&#123;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(p-&gt;peo.num,num))<br>&#123;<br>Print(&amp;p-&gt;peo);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查无此人\a&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//id查找 </span><br>Node* <span class="hljs-title function_">FindId</span><span class="hljs-params">(<span class="hljs-type">int</span> id,Node* head)</span><br>&#123;<br>Node *p = head;<br><span class="hljs-keyword">for</span>(;p;p = p-&gt;p_next)<br>&#123;<br><span class="hljs-keyword">if</span>(p-&gt;id == id)<br>&#123;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(!p)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;通过for循环遍历，找到就打印，没有找到就输出提示，大体都是这个思路，只不过字符串比较要用strcmp函数。<br>&amp;ensp;&amp;ensp;所有查找函数中，只有姓名查找和id查找有返回值，姓名查找返回是否存在，id查找返回节点指针，为什么这样设计，这是和我之后的安排相关的，因为之后的改和删都需要这两个查找函数。所以它们要顶一点。<br>&amp;ensp;&amp;ensp;同时，我也编写了打印函数，作为基础的输入输出函数使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//打印函数 </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Print</span><span class="hljs-params">(People *p)</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n姓名：%s\n&quot;</span>,p-&gt;name);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;年龄：%d\n&quot;</span>,p-&gt;age);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;性别：%c\n&quot;</span>,p-&gt;sex);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;电话：%s\n&quot;</span>,p-&gt;phone);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;地址：%s\n&quot;</span>,p-&gt;ad);<br><span class="hljs-keyword">if</span>((p-&gt;num)[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;工号：%s\n&quot;</span>,p-&gt;num);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ShowAll</span><span class="hljs-params">(Node* head)</span><br>&#123;<br>Node* temp = head;<br><span class="hljs-keyword">while</span>(temp)<br>&#123;<br>Print(&amp;temp-&gt;peo);<br>temp = temp-&gt;p_next;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Print函数是对一个People类型的打印，ShowAll是输出所有people的数据，按照前面规定的，如果没有工号，就不输出。</p><ul><li>修改函数：</li></ul><p>&amp;ensp;&amp;ensp;这个有了前面查找函数的思路很简单，就是找到对应的节点数据，然后重新写值就OK，如果没有找到，就提示并退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//现在只能支持直接查找，等动态数组出来就可以随意处理了</span><br><span class="hljs-comment">//修改函数 （名字） </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Correct</span><span class="hljs-params">(<span class="hljs-type">char</span> a[],Node *head)</span><br>&#123;<br>Node *p = head;<br><span class="hljs-type">int</span> choice;<br><span class="hljs-keyword">for</span>(;p;p = p-&gt;p_next)<br>&#123;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(p-&gt;peo.name,a))<br>&#123;<br>Print(&amp;p-&gt;peo);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(!p)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查无此人\a&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查到这个人，要修改什么:&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1.姓名\t2.性别\t3.年龄\t4.地址\t5.工号\t6.电话7.全部重写\n请输入：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;choice);<br><span class="hljs-keyword">switch</span>(choice)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入新姓名：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;p-&gt;peo.name);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入新性别：&quot;</span>);<br>getchar();<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;p-&gt;peo.sex);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入新年龄：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;p-&gt;peo.age);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入新地址：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;p-&gt;peo.ad);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入新工号：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;p-&gt;peo.num);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入新电话：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;p-&gt;peo.phone);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>Input(&amp;p-&gt;peo);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入错误\a&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个函数需要头指针指向的链表数据，和待查找的名字。</p><ul><li>删除函数：</li></ul><p>&amp;ensp;&amp;ensp;通过查找，找寻待删除的信息，如果删除，就进行链表的操作。<br>    &amp;ensp;&amp;ensp;链表的删除前面讲过了，这里再说一下，如果是头节点，就让头节点的下一个节点当头节点，如果是尾节点，就让倒数第二个节点的下一个节点指向空，如果是中间，就让前一个结点的下一节点指向后一个结点，需要注意的是，最后一定要释放删除的结点。<br>    &amp;ensp;&amp;ensp;每删除一个节点，Number就--。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//删除函数_目前只能看人名 </span><br> <span class="hljs-type">void</span> <span class="hljs-title function_">Det</span><span class="hljs-params">(Node* head,<span class="hljs-type">char</span> name[])</span><br>&#123;<br>Node *p = head;<br><span class="hljs-type">char</span> temp;<br><span class="hljs-keyword">for</span>(;p;p = p-&gt;p_next)<br>&#123;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(p-&gt;peo.name,name))<br>&#123;<br>Print(&amp;p-&gt;peo);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;确认删除吗:y-是，n-否&quot;</span>);<br>getchar();<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;temp);<br><span class="hljs-keyword">if</span>(temp == <span class="hljs-string">&#x27;y&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(p == head)<br>&#123;<br>head = p-&gt;p_next;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;p_next == <span class="hljs-literal">NULL</span>)&#123;<br>Node *p1 = FindId(p-&gt;id<span class="hljs-number">-1</span>,head);<br>p1-&gt;p_next =<span class="hljs-literal">NULL</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>Node *p1 = FindId(p-&gt;id<span class="hljs-number">-1</span>,head);<br>p1-&gt;p_next = p-&gt;p_next;<br>&#125;<br><span class="hljs-built_in">free</span>(p);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OK\a\n&quot;</span>);<br>Number--;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;我们还是通过和名字查找一样的方法得到指向待删除元素的指针。<br>&amp;ensp;&amp;ensp;我们首先提示一下，防止误操作，当得到确定的删除命令后，对上面的3中情况判断，然后释放删除空间，Number--，Ok。<br>&amp;ensp;&amp;ensp;大家可能会发现我这里没有查找失败，没有找到的情况，这是因为现在介绍的都是功能的核心程序，真正使用的话还要一个辅助程序，这个我们后面会讲。</p><ul><li>清空函数：</li></ul><p>&amp;ensp;&amp;ensp;大家或许有很多想法，但这个实现其实很简单，我们运用w方式打开文件时会格式化文件这个特性，就很方便了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Clear</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> temp;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;确定吗\a:y-确定，n-手滑了:&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;temp);<br><span class="hljs-keyword">if</span>(temp == <span class="hljs-string">&#x27;y&#x27;</span>)<br>&#123;<br>FILE* fp ;<br><span class="hljs-keyword">if</span>(!(fp = fopen(TXT,<span class="hljs-string">&quot;wb&quot;</span>)))<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error\a\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br>fclose(fp);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OK&quot;</span>);<br>Number = <span class="hljs-number">0</span>; <br>getchar();<br><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;我们打开，什么都不写立刻关闭文件，文件就清空了，是不是很方便。<br>&amp;ensp;&amp;ensp;这里的TXT是一个宏定义，表示文件名，后面文件操作函数会介绍。<br>&amp;ensp;&amp;ensp;<strong>要注意的是，Number同时置0（这个BUG我找了好久……）</strong>。<br>&amp;ensp;&amp;ensp;大家或许发现我只是把文件清空了，但程序运行的时候，其实数据已经从文件中读到程序里了，这就意味着程序中仍然可以通过头指针访问这些数据。实际上，我的构想是每次进行数据操作时，都是先从文件中读出，再修改，再写入。所以下次的任何操作都会先读取文件，这样将会刷新head。<br>&amp;ensp;&amp;ensp;<strong>注：这样的构造思路存在一个BUG，就是每次刷新都会开辟新内存空间，而原来的空间得不到释放，造成内存的严重浪费，虽然好像不怎么影响程序运行，但这对于C语言程序其实比较BUG的，虽然现在电脑性能有很大的提升，这点空间不足以挂齿，但这种思维的疏忽应当是写C程序的人所应当注意的，或许更好的解决方法是每次只在打开程序时读入，在结束程序时写入，而不是在每次操作中刷新，后面有时间我会更新这个BUG。</strong></p><h2 id="四、文件操作函数"><a href="#四、文件操作函数" class="headerlink" title="四、文件操作函数"></a>四、文件操作函数</h2><p>&amp;ensp;&amp;ensp;好了，这些基本核心函数就完成了，下面是文件操作函数。<br>&amp;ensp;&amp;ensp;文件的操作，最简单的就是<strong>读写</strong>，所以我们来编写这两个函数。</p><ul><li>文件加载</li></ul><p>&amp;ensp;&amp;ensp;首先是文件加载，将文件中的数据加载到程序中。<br>&amp;ensp;&amp;ensp;我们用#define TXT “dat.txt”这个宏定义语句来定义打开的文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c">Node* <span class="hljs-title function_">Load</span><span class="hljs-params">()</span><span class="hljs-comment">//失败返回空，没有返回空，有返回首地址 </span><br>&#123;<br>FILE *fp;<br><span class="hljs-type">int</span> i;<br>Node *head = (Node*)<span class="hljs-built_in">malloc</span>(LEN);<br>Node *p_old = head;<br>Node *p_new = head;<br><span class="hljs-keyword">if</span>(access(TXT,<span class="hljs-number">0</span>))<br>&#123;<br>fp = fopen(TXT,<span class="hljs-string">&quot;w&quot;</span>);<br>fclose(fp);<br><span class="hljs-keyword">if</span>(!(fp = fopen(TXT,<span class="hljs-string">&quot;rb&quot;</span>)))<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!(fp = fopen(TXT,<span class="hljs-string">&quot;rb&quot;</span>)))<span class="hljs-comment">//存在，打开 </span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error\a\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-comment">//空文件？ </span><br>rewind(fp);<br><span class="hljs-keyword">if</span>(fgetc(fp) == EOF)<br>&#123;<br><span class="hljs-built_in">free</span>(head);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<span class="hljs-keyword">else</span><br>&#123;<br>rewind(fp);<br>&#125;<br><br>fread(&amp;Number,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>),<span class="hljs-number">1</span>,fp);<br><br><span class="hljs-keyword">if</span>(!Number)<br>&#123;<br><span class="hljs-built_in">free</span>(head);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=Number;i++)<br>&#123;<br>fread(p_new,LEN,<span class="hljs-number">1</span>,fp);<br>p_new = (Node*)<span class="hljs-built_in">malloc</span>(LEN);<br>p_old-&gt;p_next = p_new;<br>p_old-&gt;id = i;<br>p_old = p_new;<br>&#125;<br><span class="hljs-built_in">free</span>(p_new);<br>p_old = head;<br><br><span class="hljs-keyword">for</span>(;p_old-&gt;id != Number;p_old = p_old-&gt;p_next);<br><br>p_old-&gt;p_next = <span class="hljs-literal">NULL</span>;<br>fclose(fp);<br><span class="hljs-keyword">return</span> head;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;Load函数遵循规定，没有数据时就返回空。<br>&amp;ensp;&amp;ensp;access(TXT,0)这是一个新函数，其声明在头文件io.h中，这个函数用来判断文件的状态，我们这里用参数0的功能，来判断文件是否存在，如果文件不存在，就用w方式打开不存在文件时会新建文件这个功能来新建。如果文件本身存在，直接打开就OK。<br>&amp;ensp;&amp;ensp;之后我们判断是否是空文件，先将文件位置标志归位（文件开头）（其实这一步可以不用，但这样写更好理解），然后读取一个字符，判断是否是文件结束标志，如果是，说明文件是空的，就释放刚新建的空间，&amp;ensp;&amp;ensp;返回空指针，如果不是，就归位文件标志。<br>&amp;ensp;&amp;ensp;首先读入文件中数据个数Number（我们写的时候也是先写这个），如果个数为0，说明没有数据，就返回空指针。（文件空和没有数据是两种情况，因为我们的文件中还有一个数据个数参数）<br>&amp;ensp;&amp;ensp;之后就读入Number个数据，并用链表存放。<br>&amp;ensp;&amp;ensp;读完后，由于我们是开辟的下一个待读取的单元，所以会多开一个，我们把它释放掉，并找到读取的最后一个结点，让它的下一个指向空，关闭文件，返回头指针。</p><ul><li>保存函数：<br>先保存个数，再保存数据</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Save</span><span class="hljs-params">(Node* head)</span><br>&#123;<br>FILE *fp;<br>Node* p = head;<br><span class="hljs-keyword">if</span>(!head)<span class="hljs-comment">//没有 </span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;kong&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(!(fp = fopen(TXT,<span class="hljs-string">&quot;wb&quot;</span>)))<span class="hljs-comment">//打开文件 </span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>fwrite(&amp;Number,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>),<span class="hljs-number">1</span>,fp);<span class="hljs-comment">//写 </span><br><br><span class="hljs-keyword">for</span>(;p;p = p-&gt;p_next)<span class="hljs-comment">//写 </span><br>&#123;<br>fwrite(p,LEN,<span class="hljs-number">1</span>,fp);<br>&#125;<br>fclose(fp);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;如果头文件为空说明没有数据，就不报错，并提示，有数据的话，打开文件，写个数，循环写结点信息，OK。</p><h2 id="五、函数的辅助函数"><a href="#五、函数的辅助函数" class="headerlink" title="五、函数的辅助函数"></a>五、函数的辅助函数</h2><p>&amp;ensp;&amp;ensp;我们对核心函数提供外围服务，使之成为可以真正使用的函数。</p><ul><li>新建函数：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Build</span><span class="hljs-params">()</span><br>&#123;<br><br>Node* head = Load();<br>head = Create(head);<br>Save(head);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nOK\n&quot;</span>);<br>getchar();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;这个很简单，先加载，再新建刷新头指针，之后再保存。</p><ul><li>查找函数：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Seek</span><span class="hljs-params">()</span><br>&#123;<br>Node* head = Load();<br><span class="hljs-type">int</span> temp;<br><span class="hljs-keyword">if</span>(!head)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;列表空&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入查找方式：\n\t1.姓名\t2.年龄\t3.手机号\n\t4.地址\t5.性别\t6.工号\t7.全部显示:\n&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;temp);<br>Find(head,temp<span class="hljs-number">-1</span>);<br>getchar();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>同样的先加载，如果为空，还找啥，输出提示完事，否则选择查找方式，调用查找函数，OK</p><ul><li>修改函数：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Amend</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> a[<span class="hljs-number">50</span>];<br>Node* head = Load();<br><span class="hljs-keyword">if</span>(!head)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;列表空&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入修改的姓名:&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,a);<br>Correct(a,head);<br>Save(head);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nOK\n&quot;</span>);<br>getchar();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>和查找函数大同小异，载入，获取修改姓名，调用函数，保存，OK</p><ul><li>删除函数：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Delete</span><span class="hljs-params">()</span><br>&#123;<br>Node* head = Load();<br><span class="hljs-type">char</span> a[<span class="hljs-number">50</span>];<br><span class="hljs-keyword">if</span>(!head)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;列表空&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入删除的姓名:&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,a);<br><span class="hljs-keyword">if</span>(FindName(a,head))<br>&#123;<br>Det(head,a);<br>Save(head);<br>&#125;<br><br>getchar();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;和查找函数一样，载入，获取姓名，如果没有找到（这里就用到了姓名查找函数的返回值），就提示（这个提示在查找函数中就有了），啥也不干。如果找到了，就删除，保存，OK。<br>&amp;ensp;&amp;ensp;修改函数好像没有对未找到函数的判断，这是因为在correct函数中内含了，而det函数没有内涵没有名字的处理，所以要用外围辅助判断。这是两种函数的区别。<br>&amp;ensp;&amp;ensp;清空函数本身就能干大事，不用外围函数。</p><h2 id="六、多文件编程和联系"><a href="#六、多文件编程和联系" class="headerlink" title="六、多文件编程和联系"></a>六、多文件编程和联系</h2><p>&amp;ensp;&amp;ensp;这一块我们将编写头文件，并对各个头文件之间进行关联。<br>&amp;ensp;&amp;ensp;先来写fun的头文件，头文件中包含所有fun中的函数的声明，这个就不用说，头文件中还可以包含结构体的定义，宏定义。</p><p><strong>这里我们先介绍头文件编写的格式，</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BASE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BASE</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;#ifndef XXX……#endif，这是预处理指令，预处理指令是用来协调多文件的编译工作的，这个格式的意思是如果没有编译过XXX，就编译下面的指令。</p><p>&amp;ensp;&amp;ensp;这个XXX是一个标志，要符合命名规则，我这里用BASE这个标志来标注下面这段代码（只有一个头文件包含指令）</p><p>&amp;ensp;&amp;ensp;这个的用途是什么，<strong>当我们有多个文件都要用的时候，如这个头文件，很常用，每个文件都要用，如果你不包含这个头文件，你这个文件的函数就出错了，但如果直接包含，多个文件一起编译的时候，由于每个都包含一遍这个头文件，就会出现头文件重复包含的错误，这个结构就是解决这个问题的</strong>，对于每个单个文件，我本身没有定义BASE，当然会包含下面的头文件，对于多文件编译，当编译器编译了第一个BASE后，后面的BASE就会由于编译过而不在编译这一块，也是实现单次编译，OK。</p><p>&amp;ensp;&amp;ensp;应当说明，<strong>实现这个效果，同一块编译的标志应该一样，不然你前面是BASE，后面编程BASS，编译器集体编译，发现没讲过BASS，一编译，发现里面一样，重复定义，没有用了</strong>。</p><p>&amp;ensp;&amp;ensp;这个标志也有讲究，一般来说，会把本文件对应的所有编译块用和本文件相关的标志框起来。对于通用的编译文件，用统一的标识标注（上面的BASE）。</p><p>&amp;ensp;&amp;ensp;说起来比较难理解，大家看实例就OK。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c">fun.h头文件：<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BASE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BASE</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> FUN_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FUN_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEN sizeof(Node)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TXT <span class="hljs-string">&quot;dat.txt&quot;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> Number;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br><span class="hljs-type">char</span> phone[<span class="hljs-number">15</span>];<span class="hljs-comment">//手机 </span><br><span class="hljs-type">char</span> name[<span class="hljs-number">100</span>];<span class="hljs-comment">//名字 </span><br><span class="hljs-type">char</span> num[<span class="hljs-number">20</span>];<span class="hljs-comment">//工号 </span><br><span class="hljs-type">char</span> ad[<span class="hljs-number">50</span>];<span class="hljs-comment">//地址 </span><br><span class="hljs-type">char</span> sex;<span class="hljs-comment">//性别 </span><br><span class="hljs-type">int</span> age;<span class="hljs-comment">//年龄 </span><br>&#125;People;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>People peo;<br><span class="hljs-type">int</span> id;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>* <span class="hljs-title">p_next</span>;</span><br>&#125;Node;<br><br><br>Node* <span class="hljs-title function_">New</span><span class="hljs-params">(Node *)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">Input</span><span class="hljs-params">(People* p)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Print</span><span class="hljs-params">(People *p)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">FindName</span><span class="hljs-params">(<span class="hljs-type">char</span> name[],Node* head)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">FindAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age,Node *head)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">FindPhone</span><span class="hljs-params">(<span class="hljs-type">char</span> Phone[],Node* head)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">FindAd</span><span class="hljs-params">(<span class="hljs-type">char</span> ad[],Node* head)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">FindSex</span><span class="hljs-params">(<span class="hljs-type">char</span> sex,Node* head)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">FindNum</span><span class="hljs-params">(<span class="hljs-type">char</span> num[],Node* head)</span>;<br>Node* <span class="hljs-title function_">FindId</span><span class="hljs-params">(<span class="hljs-type">int</span> id,Node* head)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ShowAll</span><span class="hljs-params">(Node* head)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Det</span><span class="hljs-params">(Node* head,<span class="hljs-type">char</span> name[])</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Correct</span><span class="hljs-params">(<span class="hljs-type">char</span> a[],Node *head)</span>;<br><br>Node* <span class="hljs-title function_">Create</span><span class="hljs-params">(Node* head)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Seek</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Build</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Clear</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Delete</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Amend</span><span class="hljs-params">()</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;我们用FUN_H标注这个fun文件的编译代码。<br>&amp;ensp;&amp;ensp;大家发现一个问题：我们哪里都用到了Number这个变量，fun和save的文件中的函数都有用到，但这个变量定义在哪里呢？我这里把它定义在了main函数的文件中，<strong>这意味着，如果不做处理，fun和save的文件中的函数将无法识别到这个变量</strong>。</p><p>&amp;ensp;&amp;ensp;这个变量跨过多个文件，还要保证是同一个变量，这是什么，<strong>外部变量</strong>。<br>&amp;ensp;&amp;ensp;关于<strong>外部变量的多文件使用</strong>，比较麻烦，首先我们可以在头文件中声明外部变量，如上面的extern int Number;这就是对Number进行外部声明，但头文件中不能定义变量，所以不能对Number赋值，赋值操作必须在c文件中，这也是我们为什么要定义在main文件中的一个原因。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">Save.h头文件<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BASE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BASE</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SAVE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SAVE_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;fun.h&quot;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> Number;<br><br>Node* <span class="hljs-title function_">Load</span><span class="hljs-params">()</span>;<span class="hljs-comment">//失败返回空，没有返回空，有返回首地址 </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Save</span><span class="hljs-params">(Node* head)</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;由于我们文件操作中也有用到fun文件中的函数，所以干脆包含进来吧。<br>&amp;ensp;&amp;ensp;在main函数文件中：<br><img src="https://img-blog.csdnimg.cn/b02079655ad34bcf96ddf025b9e6ed02.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pif5aScLueni-WjsA==,size_15,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;<strong>虽然我们save.h文件包含了fun.h文件，但由于我们的预编译的作用，它们可以同时在main函数文件中包含而不会发生重定义，预编译标志的重要性可见一斑。</strong><br>&amp;ensp;&amp;ensp;当然我们知道fun头文件在save中，我们就直接包含save就OK了。<br>&amp;ensp;&amp;ensp;大家会发现，Number外部变量声明其实是声明了两次，一次在fun中，一次在save中，但没有问题，因为这是声明，只有声明不冲突，声明几次都没啥问题。</p><h2 id="七、文件编译"><a href="#七、文件编译" class="headerlink" title="七、文件编译"></a>七、文件编译</h2><p><img src="https://img-blog.csdnimg.cn/ab3e5076b0234d20a5c1a34ea2106185.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;用了这么久，我们终于用到了最后一个编译按钮，全部重新编译，这个就是针对多文件项目的。点击这个按钮，就可以对所有文件进行编译。<br>&amp;ensp;&amp;ensp;编译之后运行，一个成功的程序，信息管理系统就OK了。<br>&amp;ensp;&amp;ensp;运行情况：<br><img src="https://img-blog.csdnimg.cn/2452194f9b4345608de49c29da68719d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pif5aScLueni-WjsA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/bea3be01d4c345c0af14329b3055a882.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pif5aScLueni-WjsA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/b479aebe3b2d400a87d8b42e2bf77001.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pif5aScLueni-WjsA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/5c7efb79a57f4b159169ea4c55ad2105.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pif5aScLueni-WjsA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/bf67fb67a9754400b3edb368d30d53a3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pif5aScLueni-WjsA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/f225109d22df4317967631e0e1307e5c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pif5aScLueni-WjsA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/f36674d3e9b04337bac544c429563f48.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pif5aScLueni-WjsA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/c387475bb4f84506a5ed75f47cd2074a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pif5aScLueni-WjsA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>这个系统还是很简陋的，高级的系统更为复杂。</p><h2 id="八、全部代码："><a href="#八、全部代码：" class="headerlink" title="八、全部代码："></a>八、全部代码：</h2><p>&amp;ensp;&amp;ensp;<strong>希望大家能有所收获，如果是做作业的话，尽量不要CV大法，看看前面的分析过程，自己写出来的代码更有成就感！</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br></pre></td><td class="code"><pre><code class="hljs c">Main.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;save.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Menu</span><span class="hljs-params">()</span>;<br><span class="hljs-type">int</span> Number = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> temp=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(temp)<br>&#123;<br><span class="hljs-keyword">switch</span>(Menu())<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>Build();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>Seek();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>Amend();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>Delete();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>Clear();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>temp = <span class="hljs-number">0</span>;<br>&#125;<br>getchar();<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Menu</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-keyword">do</span>&#123;<br>system(<span class="hljs-string">&quot;cls&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n\n\n\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t\t\t   \n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t\t|----------信息管理系统----------|\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t\t|\t1.新建联系人             |\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t\t|\t2.查看联系人             |\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t\t|\t3.修改联系人             |\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t\t|\t4.删除联系人             |\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t\t|\t5.清空联系人             |\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t\t|\t6.退出                   |\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t\t|--------------------------------|\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t\t请输入选项&lt;1~6&gt;:&quot;</span>);<br><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">6</span>||n&lt;<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入有误，请重新输入\a&quot;</span>);<br>getchar();<br>getchar();<br>system(<span class="hljs-string">&quot;cls&quot;</span>);<br>&#125;<br>&#125;<span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">6</span>||n&lt;<span class="hljs-number">1</span>);<br>getchar();<br><span class="hljs-keyword">return</span> n;<br>&#125;<br><br>Fun.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;fun.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><br><br><span class="hljs-comment">//查找函数，head-头指针，k-方式选择 </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Find</span><span class="hljs-params">(Node* head,<span class="hljs-type">int</span> k)</span><br>&#123;<br><span class="hljs-type">char</span> n[<span class="hljs-number">50</span>];<br><span class="hljs-type">int</span> m;<br>Node *p = head;<br><span class="hljs-keyword">switch</span>(k)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-comment">//名字查 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入查找姓名:&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,n);<br>FindName(n,head);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-comment">//年龄查 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入查看的年龄：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);<br>FindAge(m,head);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-comment">//手机号查</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入查找的手机号:&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,n);<br>FindPhone(n,head);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-comment">//地址查</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入查找地址:&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,n);<br>FindAd(n,head);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<span class="hljs-comment">//性别查</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入查找性别m-男，f-女:&quot;</span>);<br>getchar();<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;n[<span class="hljs-number">0</span>]);<br>FindSex(n[<span class="hljs-number">0</span>],head);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<span class="hljs-comment">//工号查</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入查找工号:&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,n);<br>FindNum(n,head);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<span class="hljs-comment">//全部显示</span><br>ShowAll(head);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>: <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入错误\a\n&quot;</span>);<br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">//想实现能全部找到返回各个序号的，但这需要动态数组，比较麻烦 </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">FindName</span><span class="hljs-params">(<span class="hljs-type">char</span> name[],Node* head)</span><br>&#123;<br>Node *p = head;<br><span class="hljs-keyword">for</span>(;p;p = p-&gt;p_next)<br>&#123;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(p-&gt;peo.name,name))<br>&#123;<br>Print(&amp;p-&gt;peo);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查无此人\a&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">FindAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age,Node *head)</span><br>&#123;<br>Node *p = head;<br><span class="hljs-keyword">for</span>(;p;p = p-&gt;p_next)<br>&#123;<br><span class="hljs-keyword">if</span>(p-&gt;peo.age == age)<br>&#123;<br>Print(&amp;p-&gt;peo);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查无此人\a&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">FindPhone</span><span class="hljs-params">(<span class="hljs-type">char</span> Phone[],Node* head)</span><br>&#123;<br>Node *p = head;<br><span class="hljs-keyword">for</span>(;p;p = p-&gt;p_next)<br>&#123;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(p-&gt;peo.phone,Phone))<br>&#123;<br>Print(&amp;p-&gt;peo);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查无此人\a&quot;</span>);<br><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">FindAd</span><span class="hljs-params">(<span class="hljs-type">char</span> ad[],Node* head)</span><br>&#123;<br>Node *p = head;<br><span class="hljs-keyword">for</span>(;p;p = p-&gt;p_next)<br>&#123;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(p-&gt;peo.ad,ad))<br>&#123;<br>Print(&amp;p-&gt;peo);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查无此人\a&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">FindSex</span><span class="hljs-params">(<span class="hljs-type">char</span> sex,Node* head)</span><br>&#123;<br>Node *p = head;<br><span class="hljs-keyword">for</span>(;p;p = p-&gt;p_next)<br>&#123;<br><span class="hljs-keyword">if</span>(sex == p-&gt;peo.sex)<br>&#123;<br>Print(&amp;p-&gt;peo);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查无此人\a&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">FindNum</span><span class="hljs-params">(<span class="hljs-type">char</span> num[],Node* head)</span><br>&#123;<br>Node *p = head;<br><span class="hljs-keyword">for</span>(;p;p = p-&gt;p_next)<br>&#123;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(p-&gt;peo.num,num))<br>&#123;<br>Print(&amp;p-&gt;peo);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查无此人\a&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//id查找 </span><br>Node* <span class="hljs-title function_">FindId</span><span class="hljs-params">(<span class="hljs-type">int</span> id,Node* head)</span><br>&#123;<br>Node *p = head;<br><span class="hljs-keyword">for</span>(;p;p = p-&gt;p_next)<br>&#123;<br><span class="hljs-keyword">if</span>(p-&gt;id == id)<br>&#123;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(!p)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><br><br><br><span class="hljs-comment">//输入函数 </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Input</span><span class="hljs-params">(People* p)</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n输入姓名（输入#中止）：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;p-&gt;name);<br><span class="hljs-keyword">if</span>(p-&gt;name[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入年龄：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;p-&gt;age);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入性别(m-男,f-女)：&quot;</span>);<br>getchar();<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;p-&gt;sex);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入手机号：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;p-&gt;phone);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入地址：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;p-&gt;ad);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入工号:(没有输入-1)&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;p-&gt;num);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><br><span class="hljs-comment">//打印函数 </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Print</span><span class="hljs-params">(People *p)</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n姓名：%s\n&quot;</span>,p-&gt;name);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;年龄：%d\n&quot;</span>,p-&gt;age);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;性别：%c\n&quot;</span>,p-&gt;sex);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;电话：%s\n&quot;</span>,p-&gt;phone);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;地址：%s\n&quot;</span>,p-&gt;ad);<br><span class="hljs-keyword">if</span>((p-&gt;num)[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;工号：%s\n&quot;</span>,p-&gt;num);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Amend</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> a[<span class="hljs-number">50</span>];<br>Node* head = Load();<br><span class="hljs-keyword">if</span>(!head)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;列表空&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入修改的姓名:&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,a);<br>Correct(a,head);<br>Save(head);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nOK\n&quot;</span>);<br>getchar();<br>&#125;<br><br><span class="hljs-comment">//现在只能支持直接查找，等动态数组出来就可以随意处理了</span><br><span class="hljs-comment">//修改函数 （名字） </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Correct</span><span class="hljs-params">(<span class="hljs-type">char</span> a[],Node *head)</span><br>&#123;<br>Node *p = head;<br><span class="hljs-type">int</span> choice;<br><span class="hljs-keyword">for</span>(;p;p = p-&gt;p_next)<br>&#123;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(p-&gt;peo.name,a))<br>&#123;<br>Print(&amp;p-&gt;peo);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(!p)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查无此人\a&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查到这个人，要修改什么:&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1.姓名\t2.性别\t3.年龄\t4.地址\t5.工号\t6.电话7.全部重写\n请输入：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;choice);<br><span class="hljs-keyword">switch</span>(choice)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入新姓名：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;p-&gt;peo.name);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入新性别：&quot;</span>);<br>getchar();<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;p-&gt;peo.sex);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入新年龄：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;p-&gt;peo.age);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入新地址：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;p-&gt;peo.ad);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入新工号：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;p-&gt;peo.num);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入新电话：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;p-&gt;peo.phone);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>Input(&amp;p-&gt;peo);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入错误\a&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-comment">//删除函数_目前只能看人名 </span><br> <span class="hljs-type">void</span> <span class="hljs-title function_">Det</span><span class="hljs-params">(Node* head,<span class="hljs-type">char</span> name[])</span><br>&#123;<br>Node *p = head;<br><span class="hljs-type">char</span> temp ;<br><span class="hljs-keyword">for</span>(;p;p = p-&gt;p_next)<br>&#123;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(p-&gt;peo.name,name))<br>&#123;<br>Print(&amp;p-&gt;peo);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;确认删除吗:y-是，n-否&quot;</span>);<br>getchar();<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;temp);<br><span class="hljs-keyword">if</span>(temp == <span class="hljs-string">&#x27;y&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(p == head)<br>&#123;<br>head = p-&gt;p_next;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;p_next == <span class="hljs-literal">NULL</span>)&#123;<br>Node *p1 = FindId(p-&gt;id<span class="hljs-number">-1</span>,head);<br>p1-&gt;p_next =<span class="hljs-literal">NULL</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>Node *p1 = FindId(p-&gt;id<span class="hljs-number">-1</span>,head);<br>p1-&gt;p_next = p-&gt;p_next;<br>&#125;<br><span class="hljs-built_in">free</span>(p);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OK\a\n&quot;</span>);<br>Number--;<br>&#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Build</span><span class="hljs-params">()</span><br>&#123;<br><br>Node* head = Load();<br>head = Create(head);<br>Save(head);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nOK\n&quot;</span>);<br>getchar();<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ShowAll</span><span class="hljs-params">(Node* head)</span><br>&#123;<br>Node* temp = head;<br><span class="hljs-keyword">while</span>(temp)<br>&#123;<br>Print(&amp;temp-&gt;peo);<br>temp = temp-&gt;p_next;<br>&#125;<br>&#125;<br><br><br>Node* <span class="hljs-title function_">Create</span><span class="hljs-params">(Node* head)</span><br>&#123;<br>Node* p_old,*p_new;<br>People t;<br><br><span class="hljs-keyword">if</span>(!Input(&amp;t))<br>&#123;<br><span class="hljs-keyword">return</span> head;<span class="hljs-comment">//没有新建 </span><br>&#125;<br><span class="hljs-keyword">if</span>(!head)<br>&#123;<br>head = (Node*)<span class="hljs-built_in">malloc</span>(LEN);<br>p_old = head;<br>p_new = head;<br>p_new-&gt;id = <span class="hljs-number">0</span>;<br>p_new-&gt;peo = t;<br>p_new-&gt;p_next = <span class="hljs-literal">NULL</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>p_new = (Node*)<span class="hljs-built_in">malloc</span>(LEN);<br><span class="hljs-keyword">for</span>(p_old = head;p_old-&gt;p_next != <span class="hljs-literal">NULL</span>;p_old = p_old-&gt;p_next);<br>p_old-&gt;p_next = p_new;<br>p_new-&gt;id = p_old-&gt;id+<span class="hljs-number">1</span>;<br>p_old = p_new;<br>p_new-&gt;peo = t;<br>p_new-&gt;p_next = <span class="hljs-literal">NULL</span>;<br>&#125;<br>Number++;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(!Input(&amp;t))<br>&#123;<br><span class="hljs-keyword">return</span> head; <br>&#125;<br><br>p_new = (Node*)<span class="hljs-built_in">malloc</span>(LEN);<br>Number++;<br>p_new-&gt;id = p_old-&gt;id+<span class="hljs-number">1</span>;<br>p_new-&gt;peo = t;<br>p_old-&gt;p_next = p_new;<br>p_new-&gt;p_next = <span class="hljs-literal">NULL</span>;<br>p_old = p_new;<br><br>&#125; <br><br>&#125; <br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Seek</span><span class="hljs-params">()</span><br>&#123;<br>Node* head = Load();<br><span class="hljs-type">int</span> temp;<br><span class="hljs-keyword">if</span>(!head)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;列表空&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入查找方式：\n\t1.姓名\t2.年龄\t3.手机号\n\t4.地址\t5.性别\t6.工号\t7.全部显示:\n&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;temp);<br>Find(head,temp<span class="hljs-number">-1</span>);<br>getchar();<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Clear</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> temp;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;确定吗\a:y-确定，n-手滑了:&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;temp);<br><span class="hljs-keyword">if</span>(temp == <span class="hljs-string">&#x27;y&#x27;</span>)<br>&#123;<br>FILE* fp ;<br><span class="hljs-keyword">if</span>(!(fp = fopen(TXT,<span class="hljs-string">&quot;wb&quot;</span>)))<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error\a\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br>fclose(fp);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OK&quot;</span>);<br>Number = <span class="hljs-number">0</span>; <br>getchar();<br><br>&#125;<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Delete</span><span class="hljs-params">()</span><br>&#123;<br>Node* head = Load();<br><span class="hljs-type">char</span> a[<span class="hljs-number">50</span>];<br><span class="hljs-keyword">if</span>(!head)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;列表空&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入删除的姓名:&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,a);<br><span class="hljs-keyword">if</span>(FindName(a,head))<br>&#123;<br>Det(head,a);<br>Save(head);<br>&#125;<br><br>getchar();<br>&#125;<br><br>Fun.h<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BASE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BASE</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> FUN_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FUN_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEN sizeof(Node)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TXT <span class="hljs-string">&quot;dat.txt&quot;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> Number;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br><span class="hljs-type">char</span> phone[<span class="hljs-number">15</span>];<span class="hljs-comment">//手机 </span><br><span class="hljs-type">char</span> name[<span class="hljs-number">100</span>];<span class="hljs-comment">//名字 </span><br><span class="hljs-type">char</span> num[<span class="hljs-number">20</span>];<span class="hljs-comment">//工号 </span><br><span class="hljs-type">char</span> ad[<span class="hljs-number">50</span>];<span class="hljs-comment">//地址 </span><br><span class="hljs-type">char</span> sex;<span class="hljs-comment">//性别 </span><br><span class="hljs-type">int</span> age;<span class="hljs-comment">//年龄 </span><br>&#125;People;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>People peo;<br><span class="hljs-type">int</span> id;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>* <span class="hljs-title">p_next</span>;</span><br>&#125;Node;<br><br><br>Node* <span class="hljs-title function_">New</span><span class="hljs-params">(Node *)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">Input</span><span class="hljs-params">(People* p)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Print</span><span class="hljs-params">(People *p)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">FindName</span><span class="hljs-params">(<span class="hljs-type">char</span> name[],Node* head)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">FindAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age,Node *head)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">FindPhone</span><span class="hljs-params">(<span class="hljs-type">char</span> Phone[],Node* head)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">FindAd</span><span class="hljs-params">(<span class="hljs-type">char</span> ad[],Node* head)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">FindSex</span><span class="hljs-params">(<span class="hljs-type">char</span> sex,Node* head)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">FindNum</span><span class="hljs-params">(<span class="hljs-type">char</span> num[],Node* head)</span>;<br>Node* <span class="hljs-title function_">FindId</span><span class="hljs-params">(<span class="hljs-type">int</span> id,Node* head)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ShowAll</span><span class="hljs-params">(Node* head)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Det</span><span class="hljs-params">(Node* head,<span class="hljs-type">char</span> name[])</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Correct</span><span class="hljs-params">(<span class="hljs-type">char</span> a[],Node *head)</span>;<br><br>Node* <span class="hljs-title function_">Create</span><span class="hljs-params">(Node* head)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Seek</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Build</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Clear</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Delete</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Amend</span><span class="hljs-params">()</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>Save.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;save.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;io.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Save</span><span class="hljs-params">(Node* head)</span><br>&#123;<br>FILE *fp;<br>Node* p = head;<br><span class="hljs-keyword">if</span>(!head)<span class="hljs-comment">//没有 </span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;kong&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(!(fp = fopen(TXT,<span class="hljs-string">&quot;wb&quot;</span>)))<span class="hljs-comment">//打开文件 </span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>fwrite(&amp;Number,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>),<span class="hljs-number">1</span>,fp);<span class="hljs-comment">//写 </span><br><br><span class="hljs-keyword">for</span>(;p;p = p-&gt;p_next)<span class="hljs-comment">//写 </span><br>&#123;<br>fwrite(p,LEN,<span class="hljs-number">1</span>,fp);<br>&#125;<br>fclose(fp);<br>&#125;<br><br><br>Node* <span class="hljs-title function_">Load</span><span class="hljs-params">()</span><span class="hljs-comment">//失败返回空，没有返回空，有返回首地址 </span><br>&#123;<br>FILE *fp;<br><span class="hljs-type">int</span> i;<br>Node *head = (Node*)<span class="hljs-built_in">malloc</span>(LEN);<br>Node *p_old = head;<br>Node *p_new = head;<br><span class="hljs-keyword">if</span>(access(TXT,<span class="hljs-number">0</span>))<br>&#123;<br>fp = fopen(TXT,<span class="hljs-string">&quot;w&quot;</span>);<br>fclose(fp);<br><span class="hljs-keyword">if</span>(!(fp = fopen(TXT,<span class="hljs-string">&quot;rb&quot;</span>)))<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!(fp = fopen(TXT,<span class="hljs-string">&quot;rb&quot;</span>)))<span class="hljs-comment">//存在，打开 </span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error\a\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-comment">//空文件？ </span><br>rewind(fp);<br><span class="hljs-keyword">if</span>(fgetc(fp) == EOF)<br>&#123;<br><span class="hljs-built_in">free</span>(head);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<span class="hljs-keyword">else</span><br>&#123;<br>rewind(fp);<br>&#125;<br><br>fread(&amp;Number,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>),<span class="hljs-number">1</span>,fp);<br><br><span class="hljs-keyword">if</span>(!Number)<br>&#123;<br><span class="hljs-built_in">free</span>(head);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=Number;i++)<br>&#123;<br>fread(p_new,LEN,<span class="hljs-number">1</span>,fp);<br>p_new = (Node*)<span class="hljs-built_in">malloc</span>(LEN);<br>p_old-&gt;p_next = p_new;<br>p_old-&gt;id = i;<br>p_old = p_new;<br>&#125;<br><span class="hljs-built_in">free</span>(p_new);<br>p_old = head;<br><br><span class="hljs-keyword">for</span>(;p_old-&gt;id != Number;p_old = p_old-&gt;p_next);<br><br>p_old-&gt;p_next = <span class="hljs-literal">NULL</span>;<br>fclose(fp);<br><span class="hljs-keyword">return</span> head;<br>&#125;<br><br>Save.h<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BASE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BASE</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SAVE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SAVE_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;fun.h&quot;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> Number;<br><br>Node* <span class="hljs-title function_">Load</span><span class="hljs-params">()</span>;<span class="hljs-comment">//失败返回空，没有返回空，有返回首地址 </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Save</span><span class="hljs-params">(Node* head)</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;OK，C语言入门总结就到这里结束了，感谢大家的观看，希望大家能有所收获，如果有空我会更新其他系列的东西，欢迎大家观看，如果本栏目有什么BUG，大家可以在下面评论，我能改的尽量改（我也不是高手……）。</p>]]></content>
    
    
    <categories>
      
      <category>知识总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识总结</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言总结项目和入门——文件操作</title>
    <link href="/2021/08/24/C06/"/>
    <url>/2021/08/24/C06/</url>
    
    <content type="html"><![CDATA[<h1 id="七、C语言入门——文件操作"><a href="#七、C语言入门——文件操作" class="headerlink" title="七、C语言入门——文件操作"></a>七、C语言入门——文件操作</h1><p>&amp;ensp;&amp;ensp;我们前面的所有程序都是暂时的，把程序一关，什么都不会留下来，打开又是从头再来，当我们希望能保留一下处理的数据，或者对现存在的数据进行处理，我们就需要文件操作了。<br>&amp;ensp;&amp;ensp;我们主要讨论如何对数据文件进行操作。<br>&amp;ensp;&amp;ensp;像什么文本文件，都是存储在磁盘上的，这些数据掉电不丢失，我们把程序处理的数据放在这里，就能实现长期保留了。<br>&amp;ensp;&amp;ensp;文件分成2类：ASCII文件和二进制文件。ASCII文件就是所有字符以ASCII形式存储，二进制文件就是原汁原味的（毕竟计算机是二进制的）如存放1000这个数，ASCII要存1和4个0，二进制则存放001111101000，它们的所占大小区别很大。<br>&amp;ensp;&amp;ensp;<strong>文件缓冲区</strong>：系统为每一个正在使用的文件开辟的缓冲区，这个缓冲区在内存，当我们从磁盘读取一定的数据是，数据先从磁盘到缓冲区，缓冲区满后再送程序数据区，给程序使用，对磁盘文件的写操作也是如此。<br>&amp;ensp;&amp;ensp;每个被使用的文件都在内存中有一个存放对应文件信息的区域，叫文件信息区，这些信息放在一个结构体中，这个结构体是系统定义和命名的，就是<strong>FILE</strong>，其定义包含在头文件stdio中。这个结构体通过前面的typedef重名名过，所以可以直接用FILE不用加struct。<br>&amp;ensp;&amp;ensp;<strong>FILE *fp——我们定义了一个FILE类型的指针fp。由于fp指向一个存放打开文件信息的结构体，所以我们可以通过fp访问对应的文件。</strong><br>&amp;ensp;&amp;ensp;这样的fp我们叫做<strong>文件指针</strong>。<br>&amp;ensp;&amp;ensp;关于文件操作，还有一些概念。<br>&amp;ensp;&amp;ensp;文件一定要打开才能操作，这个应该没什么疑问吧。<br>&amp;ensp;&amp;ensp;<strong>文件打开了一定要关闭</strong>，防止其被程序误用，要有始有终。</p><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="1-文件打开：fopen函数"><a href="#1-文件打开：fopen函数" class="headerlink" title="1.文件打开：fopen函数"></a>1.文件打开：fopen函数</h2><p>fopen（文件名，打开方式）；<br>    &amp;ensp;&amp;ensp;fopen函数返回一个指向打开文件的文件指针，通过这个指针我们可以访问我们打开的文件的内容。如fopen（“k”，“r”）；——以只读的方式打开名为k的文件。<br>&amp;ensp;&amp;ensp;我们用一个FILE类型的指针fp来接收：fp &#x3D; fopen（“k”，“r”）；</p><p>打开方式：</p><table><thead><tr><th align="center">r</th><th align="center">只读（文本文件），只能读取不能写入，文件不存在就出错。</th></tr></thead><tbody><tr><td align="center">w</td><td align="center">只写（文本文件），注意是全部格式化写入，文件不存在就新建文件。</td></tr><tr><td align="center">a</td><td align="center">追加，向文本文件尾添加数据，文件不存在就出错。</td></tr><tr><td align="center">rb</td><td align="center">只读（二进制文件），文件不存在就出错</td></tr><tr><td align="center">wb</td><td align="center">只写（二进制文件），文件不存在就新建文件</td></tr><tr><td align="center">ab</td><td align="center">追加（二进制文件），文件不存在就出错</td></tr><tr><td align="center">r+</td><td align="center">读写，能读能写（文本文件），文件不存在就出错</td></tr><tr><td align="center">w+</td><td align="center">读写，能读能写（文本文件），文件不存在就新建文件</td></tr><tr><td align="center">a+</td><td align="center">读写（文本文件）文件不存在就出错</td></tr><tr><td align="center">rb+</td><td align="center">读写（二进制文件），文件不存在就出错</td></tr><tr><td align="center">wb+</td><td align="center">读写（二进制文件），文件不存在就新建文件</td></tr><tr><td align="center">ab+</td><td align="center">读写（二进制文件），文件不存在就出错</td></tr></tbody></table><p>&amp;ensp;&amp;ensp;注：w方式只写，写入时会删除原来存在的，再写入。<br>&amp;ensp;&amp;ensp;a方式，在文件末尾追加数据，不会删除原来的。<br>&amp;ensp;&amp;ensp;用a+方式，能读能写，但文件读写的位置是从最后开始的。<br>&amp;ensp;&amp;ensp;如果文件打开失败，返回空指针。<br>常用的打开格式：</p><pre><code class="hljs">if(!(fp = fopen(&quot;name&quot;,&quot;r&quot;)))&#123;    printf(&quot;Error\a\n&quot;);    exit(0);&#125;</code></pre><p>&amp;ensp;&amp;ensp;exit（0）是使程序停止运行。</p><h2 id="2-文件关闭：fclose"><a href="#2-文件关闭：fclose" class="headerlink" title="2.文件关闭：fclose"></a>2.文件关闭：fclose</h2><p>&amp;ensp;&amp;ensp;fclose（fp）——关闭fp指向的文件。成功返回0，不成功返回EOF（-1）<br>&amp;ensp;&amp;ensp;文件打开后，我们可以对文件操作了</p><h2 id="3-文件读取"><a href="#3-文件读取" class="headerlink" title="3.文件读取"></a>3.文件读取</h2><p><strong>fgetc（fp</strong>）——从fp指向的文件中读一个字符，成功返回该字符，失败返回EOF<br><strong>fputc（ch，fp）</strong>——把ch字符写到fp中的文件中去，成功返回写入字符，失败返回EOF<br><strong>fgets（str，n，fp）</strong>——从fp指向的文件中读长度为n-1的字符放在str数组中，成功返回str地址，失败返回空指针<br><strong>fputs（str，fp）</strong>——把str指向的字符串写入fp指向的文件，成功返回0，不成功返回非0</p><p>&amp;ensp;&amp;ensp;由于字符串有结束标志，所以n长度字符串有效的只有n-1，</p><p>&amp;ensp;&amp;ensp;我们在对文件内部操作时，有一个就向word的光标一样的东西，表示当前要操作的地方， 我们写入，删除时，光标就跟进移动，同时执行操作，这个东西在文件中就是文件读写位置标记，表示当有操作来的时候，对文件的哪里进行操作，新文件就在开头，a方式打开的文件就在文件尾，r方式打开的文件也在文件头。</p><ul><li><p>格式化文件读写<br><strong>fprintf（文件指针，格式化字符串，输出列表）；<br>fscanf（文件指针，格式化字符串，输入列表）；</strong><br>  &amp;ensp;&amp;ensp;如fprintf（fp，“%d，%lf”，a，b）；把a，b写入fp指向文件中，和输出到屏幕中是一样的用法和效果，只不过这个是输出到文件中。<br>  &amp;ensp;&amp;ensp;格式化读写输入输出时都需要将ASCII转换成二进制形式，不适合频繁交换。</p></li><li><pre><code class="hljs">二进制读写</code></pre><p><strong>fread（buffer，size，count，fp）；<br>fwrite（buffer，size，count，fp）；</strong><br>  &amp;ensp;&amp;ensp;这两个函数可以实现一个数据块的写入和读出，适合数组，结构体这种大数据的读写。<br>  buffer——读出的内容存放的地方或者写入这个地方的内容，是个地址。<br>  Size——要读写的一个元素的字节数<br>  Count——读写的个数<br>  fp——文件指针<br><strong>&amp;ensp;&amp;ensp;注意：这两个函数只能以二进制方式读写，所以文件也要用二进制的形式打开。</strong></p></li><li><p>文件的随机读写：<br>  &amp;ensp;&amp;ensp;随机读写是指随意读写文件的任何位置信息，这就要用到前面说过的文件位置标记了。我们可以人为的移动文件标记，从而实现对任何位置的操作。<br>  <strong>rewind（fp）</strong>——使文件标记返回开头<br><strong>fseek（fp，位移量，起始点）</strong>——改变文件标记，表示将文件标记移动到距起始点多少偏移量的位置去。<br>&amp;ensp;&amp;ensp;起始点：0表示从开头，1表示当前，2表示文件末尾。<br>&amp;ensp;&amp;ensp;位移量是以起始点为基点，向前移动的字节数，其类型应该是long，向后移就是负值。<br><strong>ftell（fp）</strong>——获得文件标志当前位置：返回相对于开头的偏移量，出错返回-1</p></li><li><p>文件结束：<br>  <strong>feof（fp）</strong>——判断fp指向的文件是否结束，即文件读写位置是否为文件尾，结束返回1，没结束返回0</p></li><li><p>文件出错检测：<br><strong>ferror（fp）</strong>——对于任何一次读写操作，除了看返回值外，还可以调用这个函数查看是否出错，返回0表示没有出错，非0表示出错。<br>&amp;ensp;&amp;ensp;注意的是，每次新的读写都会改变ferror的返回值，要及时访问。<br><strong>clearerr（fp）</strong>——ferror如果检测出出错，就一直保留非0值，直到下一次更新，我们也可以给它手动复位，clearerr（fp）就负责复位ferror。</p></li></ul><p>&amp;ensp;&amp;ensp;这章说的比较快，因为大家都写过word吧，这个读写的概念很常见，文件的概念也比较常见，我现在打字就能看到这个光标跟着字走，打一个就前进一个，删一个就后退一个，这就是文件位置标记，大家想必也有文件打不开，莫名其妙就弹个警告然后卡退了，或者你把文件删除了，然后还是从快捷方式打开，就会提示快捷方式占不到文件，就是文件打开失败，C语言有函数来判断这些，概念什么的没有很难的，函数又是现成的，用起来还是比较顺手的。</p><p>&amp;ensp;&amp;ensp;文件操作的程序例子单拿出来也写不出啥，下一章会做一个C语言大作业，就一起在下一章来说吧。<br>    &amp;ensp;&amp;ensp;C语言入门学习到这里已经将近结束了，后续或许会补充一些零星的知识。<br>    &amp;ensp;&amp;ensp;可能以后会更新一下C++的知识，复习用，不过都是后话了。<br>    &amp;ensp;&amp;ensp;我们下章再见！</p>]]></content>
    
    
    <categories>
      
      <category>知识总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识总结</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言总结项目和入门——结构体与共用体</title>
    <link href="/2021/08/23/C05/"/>
    <url>/2021/08/23/C05/</url>
    
    <content type="html"><![CDATA[<h1 id="六、C语言入门——结构体"><a href="#六、C语言入门——结构体" class="headerlink" title="六、C语言入门——结构体"></a>六、C语言入门——结构体</h1><p>&amp;ensp;&amp;ensp;实际上，我们处理的东西往往是复杂的，通常需要很多的参数去描述，比如一个人，最起码姓名性别年龄这就3个需要描述的内容了，一个变量能不能同时描述这3个属性，或许可以，比方说用字符数组，不过处理很麻烦，因为名字是字符没有问题，但年龄怎么也应该是个int类型的吧，等过了一年，年龄++，字符串改起来可是比一个数简单加1麻烦的多。<br>&amp;ensp;&amp;ensp;鉴于对实际事物描述的复杂性，C语言引入结构体的概念（面向对象编程则使用更为全面的类结构描述）。<br>&amp;ensp;&amp;ensp;结构体就是一堆类型的集合，用来充分且合适的描述一个对象的特征，比如姓名，我们要一个字符数组，年龄要一个int，性别我们可以要一个bool值（C语言也是用int，因为bool不常见），<strong>现在我们自定义一个集合（类型），包含这三个属性，并给这个集合取名People，这就是用结构体描述人的基本操作。</strong><br>&amp;ensp;&amp;ensp;<strong>结构体是用户自定义的数据类型（这句很重要）</strong>，通过结构体的定义，将一些本身没啥联系的单元（变量所在的地方）联系在一起，组成集合。</p><ul><li><p>结构体的定义</p><pre><code class="hljs">  struct People  &#123;      int age;      char name[50];      char sex;  &#125;;  struct 结构体类型名  &#123;      成员列表；  &#125;;</code></pre></li></ul><p>&amp;ensp;&amp;ensp;我们定义了一个人的类型，<strong>（结尾的分号！！）。</strong></p><p>&amp;ensp;&amp;ensp;有了人的类型，我们怎么用呢？<br>&amp;ensp;&amp;ensp;这里我打算用类和对象的关系来说明一下结构体和其变量的关系，因为我觉得确实这两种可以有相似之处。<br>&amp;ensp;&amp;ensp;我们上面定义了一个人，但这个人是虚假的，因为你不知道它叫啥，性别和年龄，因为我们只是定义，所以<strong>这个人是虚拟的</strong>，但每个人都有我们刚定义的几种属性，这意味着我们可以用这个人去描述其他所有人（不考虑什么同名同姓之类的），所以说我们刚定义的又有通用性，我把它叫框架（类、结构体），其他所有的人（对象、结构体变量）都可以用这个框架搭建出来，它们彼此之间只是赋的值不同，<strong>而结构上没有任何区别</strong>（人和人都是骨头搭建的）。换句话说，有了这个框架，我们想创建多少个人就能搞多少个人，无非就是赋不同的值，而骨架是固定。<strong>从结构到一个个具体的人这个过程，叫实例化，表示我们从一个理论的人（只有类型）为骨架创建了一个实际的人</strong>（这里只是给成员属性赋值，对于类的实例化还可以有行为属性。）<br>&amp;ensp;&amp;ensp;比较抽象？我们现在来创建一个具体的人：<br>&amp;ensp;&amp;ensp;struct People a;<br>&amp;ensp;&amp;ensp;前面我们说过，结构体是一种用户自定义的<strong>类型</strong>，People就是我们对这种自定义的类型起的类型名，前面struct是C语言强调这个类型是结构体类型（好像现在有的版本前面不用struct了，不过还是建议写上）。struct People就是C语言对用户自定义类型的一种识别格式。上面的例子用前面的话来说就是：<strong>我们定义了一个People类型的结构体变量，叫a。</strong><br>&amp;ensp;&amp;ensp;int a；——我们定义了一个int类型的整型变量，叫a<br>&amp;ensp;&amp;ensp;两者没有区别，无非是自定义类型和本来类型的区别。<br><strong>加粗样式</strong>现在我们有了一个人了，是a，struct People a就是实例化，表示创建了一个可以<strong>实际操作</strong>的，真真实实的人，<strong>但是现在a的名字是什么，并不是a，a只是变量名，代表一个人的变量，这个人叫什么我们还没起呢</strong>，这里引出一个<strong>重点</strong>，<strong>变量是真实存在</strong>的（在内存空间中有它的专属地方），所以说它是可以实际操作的（可以对内存空间中的值改变和读写），<strong>类型是虚假的</strong>，就像前面说的，<strong>你不能对int赋值，因为int是类型，同样的你也不能对People赋值，因为People是类型，是自定义的类型，这就是结构体和结构体变量的本质区别，结构体是类型，是虚假的不能赋值，变量是确切存在的，可以操作的</strong>。（类和对象的关系也是这样的）<br>&amp;ensp;&amp;ensp;现在我们给a这个变量代表的人起名字，a是个结构体变量，它里面有结构体所包含的骨架（前面说的），这里就设计到怎么访问里面的属性。<br>&amp;ensp;&amp;ensp;我们访问地址有&amp;，*运算符，访问结构体属性也有自己的。</p><p><strong>点运算符（.）</strong><br>&amp;ensp;&amp;ensp;<strong>想访问什么属性，点出来就好了</strong>。<br>&amp;ensp;&amp;ensp;访问a的名字：a.name；<br>&amp;ensp;&amp;ensp;<strong>注意，结构体有的才能点出来，才能访问，你定义人这个骨架的时候都没写的东西，你怎么能指望你按照这个骨架创建出来的变量有别的东西呢</strong>？<br>&amp;ensp;&amp;ensp;我们给a的名字赋值：a.name &#x3D; “ann”;<br>&amp;ensp;&amp;ensp;a.name表示访问a中名字为name的变量，并给这个变量赋值ann，好像没啥问题，但我们name的类型是什么：数组，a.name就是char数组，数组怎么能在定义完还能直接这样赋值的呢，所以上的语句有问题的。<br>&amp;ensp;&amp;ensp;但我们给年龄什么的赋值，就不会有这样由于char数组自己导致的赋值不行的问题发生了。<br>a.age &#x3D; 15;<br>a.sex &#x3D; ‘男’;<br>&amp;ensp;&amp;ensp;上面由于我们是先定义后赋值，导致数组类型的赋值很是麻烦，我们实际上可以在定义结构体变量a的时候就给a赋值。<br>    &amp;ensp;&amp;ensp;struct People a &#x3D; {15,”ann”,’男’};<br>    &amp;ensp;&amp;ensp;注意，用大括号包含所有属性的初始值，每个属性初值之间用逗号分割，<strong>结构体里面写的顺序是什么，就按这个顺序赋值。</strong><br>    &amp;ensp;&amp;ensp;我们甚至可以直接在声明结构体的时候就定义结构体变量<br>struct People<br>{<br>    &amp;ensp;&amp;ensp;int age;<br>    &amp;ensp;&amp;ensp;char name[50];<br>    &amp;ensp;&amp;ensp;char sex;<br>}a;<br>&amp;ensp;&amp;ensp;跟在屁股后面就行了，a是结构体变量名。<br>&amp;ensp;&amp;ensp;当然也可以赋初值</p><pre><code class="hljs">struct People&#123;int age;char name[50];char sex;&#125;a= &#123;15,&quot;ann&quot;,&#39;男&#39;&#125;;struct 结构体类型名&#123;成员列表；&#125;变量名列表;</code></pre><p>&amp;ensp;&amp;ensp;重要的是，由于<strong>结构体也是变量类型</strong>，结构体里面的属性是变量，所以我们可以在结构体的属性里面定义别的结构体类型的变量，简单来说，<strong>结构体可以嵌套。</strong></p><pre><code class="hljs">struct Favourite&#123;int number;int month;&#125;;struct People&#123;int age;char name[50];char sex;struct Favourite fav;&#125;a= &#123;15,&quot;ann&quot;,&#39;男&#39;,&#123;13,6&#125;&#125;;</code></pre><p>&amp;ensp;&amp;ensp;这个例子中，我们添加了对人的一个描述——最喜欢的东西，我们把它也搞成结构体，类型为Favourite，由于C语言对于结构体变量定义的特殊形式，于是这个变量的定义就变成了struct Favourite fav;对变量a赋初值，前面很好理解，最后一个由于是结构体，所以初值也要用大括号括起来，就形成了大括号嵌套的形式（和结构体嵌套是同样的）<br>&amp;ensp;&amp;ensp;怎么访问结构体的结构体？一级一级点出来就OK了。a.fav.month——访问a的month属性。<br>&amp;ensp;&amp;ensp;<strong>只要抓住点运算符一级一级的访问属性，就能访问任意嵌套的结构体</strong>。<br>&amp;ensp;&amp;ensp;点运算符的优先级是最高的，所以a.age++就是我们期望的先找到age，再对age++。<br>&amp;ensp;&amp;ensp;结构体变量作为变量，当然也有地址，其属性成员也有各自的地址。<br>&amp;ensp;&amp;ensp;注意，结构体只能点名道姓的赋值和访问，不能说希望直接输入各种类型的值对其整体赋值。<br>&amp;ensp;&amp;ensp;如：</p><pre><code class="hljs">struct People&#123;int age;char name[50];char sex;&#125;a;scanf(&quot;%d,%s,%c&quot;,&amp;a);</code></pre><p>&amp;ensp;&amp;ensp;希望通过这种语句直接给a整体赋值是不可以的。<br>&amp;ensp;&amp;ensp;<strong>结构体使可以相互赋值的，两个结构体a，b同类型，我想把a的值全给b，b&#x3D;a就OK，数组是不可以这样的。</strong></p><ul><li>结构体数组</li></ul><p>&amp;ensp;&amp;ensp;顾名思义，就是其元素都是结构体变量的数组。<br>&amp;ensp;&amp;ensp;有了这个，我们就可以创建很多人了。<br>&amp;ensp;&amp;ensp;定义和数组的定义一样：struct People a[5];<br>类型 数组名[大小]（<strong>结构体就是自定义的类型</strong>）</p><p>&amp;ensp;&amp;ensp;数组中的每一个元素都是一个People类型的结构体，访问的话，当然根据层层访问的方法，首先这是一个数组，所以要先访问数组，当我们访问到里面的元素时，发现这是个结构体变量，再使用结构体变量的访问方式。<br>&amp;ensp;&amp;ensp;a[1].age——访问第一个结构体变量的age属性。</p><p>&amp;ensp;&amp;ensp;我们也可以在定义结构体的时候定义其数组</p><pre><code class="hljs">struct People&#123;int age;char sex;&#125;a[2] = &#123;5，‘男’，6，‘女‘&#125;;</code></pre><p>&amp;ensp;&amp;ensp;并采用这种一一对应的初始化方式。</p><ul><li>结构体指针</li></ul><p>&amp;ensp;&amp;ensp;结构体变量是变量，当然有指向结构体的指针了。<br>    &amp;ensp;&amp;ensp;定义和指针的定义一样：struct People *p<br>    &amp;ensp;&amp;ensp;我们让它指向刚才定义的a[0]——p &#x3D; &amp;a[0]<br>    &amp;ensp;&amp;ensp;现在我们可以通过p访问a[0]的属性了，对于指针的问题，首先搞清楚，指针指向了什么，p指向a[0]这个结构体，所以*p当然就是a[0]了，我们访问其中的age属性，再.age就OK，综上——（*p）.age。注意这里的括号是必须的，因为.运算优先级最高比*还高，不加括号就先成了p.age，这什么都不是，因为p不是结构体，怎么能用点运算符呢。<br>    &amp;ensp;&amp;ensp;对于结构体指针，我们还有更为方便的使用方法，我们想访问age属性，<strong>可以使用p-&gt;age这种形式，表示直接访问p指向的结构体的age属性</strong>（-&gt;箭头、指向的，是不是很形象），它的结果当然是age了，所以（*p）.age和p-&gt;age是等价的，当然a[0].age也是等价的，这三种访问方法就看你怎么使用了。<br>    &amp;ensp;&amp;ensp;普通的指针还能直接指向对应的数组，对于结构体指针和结构体数组当然也是如此，结构体数组名代表这个数组的首地址，我们直接p &#x3D; a；就把指针和数组挂钩了，p++呢，根据前面的元素是指向下一个元素，所以是指向数组中下一个结构体。<br>    &amp;ensp;&amp;ensp;P++的时候，p怎么知道要跳过多少个内存空间才能指向下一个元素呢？我们上一章讲过了，我们在定义p的时候就告诉它它指向的内存是多大的空间了。对于结构体也是如此。至于结构体在内存中是怎么存放的，这个还不是简单的说有多少属性就开辟多少空间，比如说我们有一个int类型，一个char[50]，一个double类型的属性的结构体，我们在定义这样的结构体变量的时候，是在内存中开辟了4+50+8&#x3D;62的内存空间吗？看起来好像确实是这样的，但实际上，我们用sizeof看一看。</p><pre><code class="hljs">struct People&#123;    int age;    char name[50];    double k;&#125;a;int main()&#123;    printf(&quot;%d&quot;,sizeof(a));    return 0;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/6386c5a345dc476daa67620176cee2fa.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;平白无故多了2个，为什么，这里涉及一个内存对齐的东西，对于初学来说用处不大，知不知道也不影响咱们编程，在对应的阶段干对应的事才是合适的。<br>    &amp;ensp;&amp;ensp;简单来说，内存对齐就是为了好看，加一些空的内存空间凑个整，64大家都知道是2^6，2的倍数计算机喜欢呀，62就不好看。当然这是感性的认识，内存对齐是有好处的，对于访问的速度加快，减少访问周期什么都挺关键。<br>    &amp;ensp;&amp;ensp;现在我们有结构体指针了，我们说说结构体当函数参数。<br>    &amp;ensp;&amp;ensp;我们当然可以直接把结构体变量当参数：void fun（struct People a）<br>&amp;ensp;&amp;ensp;当我们传入一个结构体的时候，就会拷贝一份结构体给函数。这是我们前面所知道的，实参和形参的知识。<br>    &amp;ensp;&amp;ensp;重要的是，结构体不同于普通变量，它是一堆数据的集合，和数组比较像，通常一个结构体是很大的，上面的例子就有64byte，这还是很简单的一个结构体，复杂的结构体里套结构体，占的空间相当大，你现在还要拷贝一份传给函数，原本不富裕的内存更加雪上加霜。我们数组传进来的时候其实是一个指针，指针只用存储地址，通常都很小，所以从花销上来看，对于函数的参数需要结构体的时候，我们更倾向于传结构体的指针。（当然不是说直接给结构体不行）</p><h1 id="共用体类型"><a href="#共用体类型" class="headerlink" title="共用体类型"></a>共用体类型</h1><p>&amp;ensp;&amp;ensp;共用体和结构体很像，但却是不同的内存分配方式。</p><ul><li><p>共用体类型定义：</p><pre><code class="hljs">  union 共用体  &#123;      成员列表  &#125;；      union Data  &#123;      int i；      double k；      char m；  &#125;</code></pre></li></ul><p>&amp;ensp;&amp;ensp;变量定义：union Data a；当然和结构体一样的初始化和变量定义的形式都有，这里只是举个例子。<br>&amp;ensp;&amp;ensp;看起来和结构体没啥差别，<strong>但共用体共用一个内存空间</strong>，结构体是各个元素的集合，每个元素是有自己的位置的，共用体是只开辟最大变量类型的空间，里面的值由全体成员共享。<br>&amp;ensp;&amp;ensp;例如上面的Data，它实际上占了多大空间呢，答案是8byte，等于其最大的成员类型double的大小，假设我们对a.i &#x3D; 2这样付个值，由于共用体成员共用这一片内存空间，所以一变都变，k的值就变成了2.0，char的值就是2，代表的ASCII是STX。<br>&amp;ensp;&amp;ensp;<strong>共用体可以使同一存储区域的内容有多种解读形式。</strong></p><h1 id="枚举类型："><a href="#枚举类型：" class="headerlink" title="枚举类型："></a>枚举类型：</h1><p>&amp;ensp;&amp;ensp;枚举类型提供一个变量的几种可能。<br>    &amp;ensp;&amp;ensp;比如一个表示星期的变量，它的值只能有7中，取值情况是完全确定的，这时就可以用枚举来定义。</p><ul><li><p>枚举类型：</p><pre><code class="hljs">  enum 枚举名  &#123;      情况  &#125;；  enum Weekday  &#123;      Mon，      Thu，  &#125;;</code></pre></li></ul><p>&amp;ensp;&amp;ensp;这里只写2个举个例子。<strong>注意用逗号分开</strong><br>&amp;ensp;&amp;ensp;同样的，定义变量和前面的相同：enum Weekday a；<br>&amp;ensp;&amp;ensp;<strong>枚举类型的变量，只能取枚举类型中有的值</strong>，如a&#x3D;2.3，a&#x3D;‘k’是不行的，a&#x3D;Mon是OK的，a&#x3D;Fri是不行的（因为我里面还没写），a&#x3D;Monday是不行的（因为里面没有）。<br>    &amp;ensp;&amp;ensp;这个Mon只在对应枚举类型中才有，平常没有说明的话谁也不知道Mon是什么，所以int I &#x3D; Mon是不行的。<br>    &amp;ensp;&amp;ensp;声明枚举类型的时候，编译器将里面的东西按常量处理，所以Mon这个符号就能像常量一样使用了。<br>    &amp;ensp;&amp;ensp;实际上，每一个枚举元素代表一个整数，开始的是0，依次往后排，a &#x3D; Thu和a &#x3D; 1是一样的，对于一个枚举类型的变量，它的值为2表示它取枚举类型中从开始往后数的第三个常量。<br>    &amp;ensp;&amp;ensp;枚举元素也可以判断，因为它们被赋予了对应的整数，Mon&gt;Thu的结果是假。</p><ul><li>typedef命名自己的变量类型</li></ul><p>&amp;ensp;&amp;ensp;和define很像，但差别也挺大的。就是给变量类型起别名。<br>&amp;ensp;&amp;ensp;<strong>首先typedef是语句不是宏定义。</strong><br>&amp;ensp;&amp;ensp;<strong>typedef int INT；——我们把整型int重命名成了INT，以后在程序中INT i表示声明一个整型变量。</strong><br>&amp;ensp;&amp;ensp;同样的，我们对结构体什么的也可以这样搞：<br>typedef struct{<br>    int num；<br>} Data；<br>    &amp;ensp;&amp;ensp;表示我们重新声明了一个Data的数据类型，是一个结构体类型。这里的分号是typedef语句的分号，和结构体定义什么的无关。<br>    &amp;ensp;&amp;ensp;Data a表示声明一个结构体变量a，struct什么的都不用写了。<br>&amp;ensp;&amp;ensp;重定义函数指针：<br>&amp;ensp;&amp;ensp;typedef int （*Point）（）；<br>&amp;ensp;&amp;ensp;定义了一个Point的函数指针类型（无参数，返回int）<br>&amp;ensp;&amp;ensp;这里使用书上的一个总结，我觉得说的很好。<br><img src="https://img-blog.csdnimg.cn/337d7b81f1df438e909a0ec224c6bca6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;下一章的文件操作，会有一个FILE的数据类型，就是由这种方法定义出来的。<br>&amp;ensp;&amp;ensp;我们下一章再见！</p><h1 id="代码训练与详解"><a href="#代码训练与详解" class="headerlink" title="代码训练与详解"></a>代码训练与详解</h1><p>&amp;ensp;&amp;ensp;这里我们将要综合指针和结构体的知识，完成链表结构的实现，这算是第一个比较关键的大项目了吧。<br>    &amp;ensp;&amp;ensp;首先，链表是一种数据结构，是动态开辟内存空间对数据进行分配的结构，前面我们说了，数组作为一个放数组的东西，它不能动态开辟，写成多少就是多少，它是静态的，这对我们放数据产生很大的困扰，更多时候我不知道我要放多少个，我希望我希望放多少就能放多少，这个数组明显是不行了，我们可以用更为高级的数据结构来实现，比如链表。</p><ul><li>首先我们来介绍一些知识：</li></ul><p><strong>C语言动态内存空间的分配</strong><br>&amp;ensp;&amp;ensp;我们定义变量，函数的形参传值什么的，都是编译器帮我们自动就开辟了内存空间了，我们能不能自己开辟一块内存空间，放自己想放的东西呢，当然是可以的。但是我们仍然没有办法把空间开在想开的地址上（汇编能轻松实现这个功能，这就是更底层语言的优势），地址仍是编译器选择，我们只是选择了一个自己开辟的内存。<br>&amp;ensp;&amp;ensp;系统提供了很大库函数，来实现这种操作。<br><strong>malloc函数——void* malloc(unsigned int size)</strong><br>&amp;ensp;&amp;ensp;这个函数在内存中开辟一块size大小的空间，返回这个开辟空间的首地址，这里void<em>表示这个指针没有指向任何类型，*<em>他是一个不知道指向什么类型，但确实指向了一个地方的指针，听起来比较奇怪，实际原因是手动开辟的内存没有变量属性，他就是单单一个空间，不像定义变量时开辟的内存，明确知道这是一个变量类型的区域。</em></em><br>&amp;ensp;&amp;ensp;如果函数没能成功开辟空间，就返回NULL空指针。<br>malloc（100）——开辟内存大小时100byte的空间。</p><p><strong>calloc函数——void* calloc(unsigned int n,unsigned int size)</strong><br>&amp;ensp;&amp;ensp;这个函数也是开辟一块空间，不同的是他是连续开辟n个大小为size的空间，这个空间的形式是不是和数组很像。<br>&amp;ensp;&amp;ensp;<strong>用这个函数可以实现动态数组，n是数组长度，size是数组元素的大小。</strong>同样的不成功放回空指针。<br>calloc（50，4）——连续开辟50个大小是4byte的空间（其内存格式和int a[50]开辟的内存格式是一样的）</p><p><strong>free函数——void* free(void *p)</strong><br>&amp;ensp;&amp;ensp;我们要知道，我们自己开辟的空间和编译器开的有什么区别。编译器开辟的空间受编译器管理，其空间的有效时间（存活时间）遵循生存周期的控制（前面讲的），而我们自己开的空间，编译器管不了，他只能乖乖听话说开一个多大的就开一个多大的，我们自己不释放这片空间（使其无效，相当于生存周期结束），编译器动也不感动这片区域，<strong>这就是自己开辟空间的好处，不受生存周期控制，跳出三界之外，不在五行之中。我们开辟的空间，只能由我们释放。</strong><br>&amp;ensp;&amp;ensp;但是别忘了，开辟完空间一定要记得手动释放（C和C++还是保留了手动释放内存空间的需求，C#什么的都还给编译器了不在用自己手动管了）。不然你不用了编译器也不会释放的，浪费空间。<br>&amp;ensp;&amp;ensp;free函数就是释放空间的函数，p是使用malloc或calloc函数开辟的空间的返回值，即开辟的地址。</p><p><strong>realloc函数——void* realloc(void* p,unsigned int size)</strong><br>&amp;ensp;&amp;ensp;对于已经用malloc或calloc函数开辟的空间，想改变其空间大小，可以用这个。<br>&amp;ensp;&amp;ensp;P是待改变的空间指针，size是新空间的大小，函数会将p指针指向的地方进行相应的改变，p指针不变。<br>&amp;ensp;&amp;ensp;<strong>这4个函数都在头文件stdlib.h中。</strong></p><p>&amp;ensp;&amp;ensp;现在我们来说说链表的事，我们这里只说最简单的单向链表<br>&amp;ensp;&amp;ensp;链表就是链子，把每一个单元串起来，链表中的每一个单元叫<strong>结点</strong>，每一个结点包含2部分，首先是我们要存放的数据，还有就是指向下一个结点的指针，每个结点通过这样的链式指针一个一个的指下去，从而形成了连续不断的链表结构，除结点外，链表还要有一个<strong>头指针</strong>，用来指向第一个结点，从而可以访问整个链表，同样的，对于链表的末尾，其指针应当指向空。表示后面没有结点。<br><img src="https://img-blog.csdnimg.cn/a59e49c412ad4a9e891c852047b80b4f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;<strong>链表的地址可以是不连续的，因为链表的每个元素（结点）之间是通过地址直接跳转访问，而数组的元素地址是连续的，因为数组的访问是通过地址简单的加减来访问的。</strong><br>&amp;ensp;&amp;ensp;这里的结点，很明显要包含数据和一个指针，所以结点应该是结构体。</p><pre><code class="hljs">struct Node&#123;    int num;    struct Node *p;&#125;;</code></pre><p>&amp;ensp;&amp;ensp;我们这里写一个简单的结点，用num表示数据，p指向下一个结点。<br>&amp;ensp;&amp;ensp;静态链表很简单，因为他的数据是现成的，只要把它们串起来就好说了<br>&amp;ensp;&amp;ensp;比如a，b，c三个结构体，里放着数据，我们来把他们串成链表<br>head &#x3D; &amp;a;<br>a.p &#x3D; &amp;b;<br>b.p &#x3D; &amp;c;<br>c,p &#x3D; NULL;<br>&amp;ensp;&amp;ensp;其中head是头指针，就这样一层一层的串下去，别忘了最后要置为NULL。</p><p>&amp;ensp;&amp;ensp;对于动态的链表，就麻烦一点了。<br>&amp;ensp;&amp;ensp;首先，我们要开辟一个空间来当结点，然后把数据写进去，然后再开辟一个结点，并把原来开辟的结点的指向下一个的指针指向新开的结点，逻辑很清楚，让我们来试试。<br>&amp;ensp;&amp;ensp;我们可以写下这样的代码：<br>    struct Node <em>p_next;<br>    struct Node <em>head &#x3D; malloc(sizeof(struct Node));<br>    head-&gt;num &#x3D; 0;<br>    p_next &#x3D; malloc(sizeof(struct Node));<br>    head-&gt;p &#x3D; p_next;<br>    p_next-&gt;num &#x3D; 1;<br>&amp;ensp;&amp;ensp;首先我们给头结点head开了空间，然后给他赋值为0，又开了下一个空间，用p_next来指向，并成功把head的下一个指针指向了p_next，然后赋值，现在，我们应该再新建下一个结点了，但我们发现没有可以使用的指针变量了，头节点要始终指向链表的开头，所以头节点不能再变了，我们现在还有一个p_next指针，**但我们开辟新的空间并用p_next接收的话，我们就完全失去了和前面节点的联系，还怎么让前节点的指针指向后节点呢？</em></em><br>&amp;ensp;&amp;ensp;所以实际上链表的生成是要靠2个指针完成的，它们交替前进，一个提供新开节点的信息，另一个提供上一个节点的信息，并通过这两个节点将链表串起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEN sizeof(struct Node)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">head</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">p_old</span>;</span><span class="hljs-comment">//老指针 </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">p_new</span>;</span><span class="hljs-comment">//新指针 </span><br>head = <span class="hljs-built_in">malloc</span>(LEN);<br>p_old = head;<br>p_new = head; <span class="hljs-comment">//三个指针指向开始节点 </span><br><br>p_old-&gt;num = <span class="hljs-number">0</span>;<span class="hljs-comment">//对起始节点赋值 </span><br>p_new = <span class="hljs-built_in">malloc</span>(LEN);<span class="hljs-comment">//新节点的开辟，并用新指针接收 </span><br>p_old-&gt;p = p_new;<span class="hljs-comment">//老指针（上一个）的p指向新指针（下一个） </span><br>p_new-&gt;num = <span class="hljs-number">1</span>;<span class="hljs-comment">//新节点赋值 </span><br>p_old = p_new;<span class="hljs-comment">//老指针跟进——这一步很重要 </span><br><br>p_new = <span class="hljs-built_in">malloc</span>(LEN);<span class="hljs-comment">//新指针再开辟，原来的变成老的节点，正好由老指针指向着</span><br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;这里两个指针的变化需要注意，总是新指针先指向开辟的空间，然后和老指针实现前面节点和新开节点的关联，然后老指针跟进，新指针再开辟，这样的一个循环过程。<br>&amp;ensp;&amp;ensp;完整代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEN sizeof(struct Node)</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> num;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">p</span>;</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> Node* <span class="hljs-title function_">Link</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Print</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node* head)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>Print(Link());<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">struct</span> Node* <span class="hljs-title function_">Link</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">head</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">p_old</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">p_new</span>;</span><br><span class="hljs-type">int</span> i;<br><br>head = (<span class="hljs-keyword">struct</span> Node*)<span class="hljs-built_in">malloc</span>(LEN);<br>p_old = head;<br>p_new = head;<br>p_old-&gt;num = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">50</span>;i++)<br>&#123;<br>p_new = (<span class="hljs-keyword">struct</span> Node*)<span class="hljs-built_in">malloc</span>(LEN);<span class="hljs-comment">//开辟 </span><br>p_new-&gt;num = i;<span class="hljs-comment">//赋值 </span><br>p_old-&gt;p = p_new;<span class="hljs-comment">//连接 </span><br>p_old = p_new;<span class="hljs-comment">//跟进</span><br>&#125;<br>p_old-&gt;p = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Print</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node* head)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">p_temp</span> =</span> head;<br><span class="hljs-keyword">for</span>(;p_temp != <span class="hljs-literal">NULL</span>;p_temp = p_temp-&gt;p)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,p_temp-&gt;num);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;这里我编了两个函数，一个是链表的创建，另一个是链表的显示（这个待会会说）<br>&amp;ensp;&amp;ensp;#define LEN sizeof(struct Node)——这是宏定义，表示将LEN和sizeof(struct Node)挂钩，编译器看见LEN就用sizeof(struct Node)替换，所以LEN 就是表示Node结构体的大小。<br>&amp;ensp;&amp;ensp;head &#x3D; (struct Node*)malloc(LEN);这里用了(struct Node*)，这是强制类型转换，因为malloc返回的是void<em>，虽然可以用struct Node</em>的指针head接收，但有得时候会报错，而且为了突出开辟空间的真实类型，可以使用强制类型转换。<br>&amp;ensp;&amp;ensp;p_old-&gt;p &#x3D; NULL;——别忘了最后一个指针指向空。<br><img src="https://img-blog.csdnimg.cn/e24474c9f97a47ebaab958ae21d3b1e9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>显示1到49（截不全），说明是成功的。<br><strong>下面我们来说说链表的操作：</strong><br><strong>链表打印</strong>:由于每一个节点存储着下一个节点的地址，这个访问就很简单了，每次访问完，让指针指向下一个，再加上最后一个指针会指向空的结束标志，就能写出上面Print函数的效果了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Find</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node* head,<span class="hljs-type">int</span> num)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">p_temp</span> =</span> head;<br><span class="hljs-keyword">for</span>(;p_temp != <span class="hljs-literal">NULL</span>;p_temp = p_temp-&gt;p)<br>&#123;<br><span class="hljs-keyword">if</span>(p_temp-&gt;num == num)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;FIND!--%d&quot;</span>,p_temp-&gt;num);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;找到返回1，没有找到返回0.</p><p><strong>链表修改</strong>:找到后就能访问对于属性了，修改就很方便。<br><strong>链表插入</strong>:这个就比较麻烦了。<br>&amp;ensp;&amp;ensp;首先我们找到待插入的节点，然后让前一个的节点指向这个节点，让这个节点指向后面的节点，就实现了插入。但注意的是，如果插在最后，最后指向的应当为空，如果插在最前面，需要改变head头指针的指向。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node* head,<span class="hljs-keyword">struct</span> Node* temp,<span class="hljs-type">int</span> num)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">p_temp</span> =</span> head;<br><span class="hljs-keyword">if</span>(num == head-&gt;num)<br>&#123;<br>temp-&gt;p = head-&gt;p;<br>head = temp;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span>(;p_temp != <span class="hljs-literal">NULL</span>;p_temp = p_temp-&gt;p)<br>&#123;<br><span class="hljs-keyword">if</span>(p_temp-&gt;num == num)<br>&#123;<br>temp-&gt;p = p_temp-&gt;p;<br>p_temp-&gt;p = temp;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(p_temp-&gt;p == <span class="hljs-literal">NULL</span>)<br>&#123;<br>p_temp-&gt;p = temp;<br>temp-&gt;p = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><strong>链表删除</strong>:<br>&amp;ensp;&amp;ensp;让前面的指向后面的，然后直接把中间free就OK。注意删除的是头节点和尾节点的时候。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Del</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node* head,<span class="hljs-type">int</span> num)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">p_temp</span> =</span> head;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">p_now</span> =</span> head;<br><span class="hljs-keyword">if</span>(num == head-&gt;num)<br>&#123;<br>head = head-&gt;p;<br><span class="hljs-built_in">free</span>(p_temp);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(;p_temp != <span class="hljs-literal">NULL</span>;p_now = p_temp,p_temp = p_temp-&gt;p)<br>&#123;<br><span class="hljs-keyword">if</span>(p_temp-&gt;num == num)<br>&#123;<br>p_now-&gt;p = p_temp-&gt;p;<br><span class="hljs-built_in">free</span>(p_temp);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(p_temp-&gt;p == <span class="hljs-literal">NULL</span> &amp;&amp; p_temp-&gt;p-&gt;num == num)<br>&#123;<br><span class="hljs-built_in">free</span>(p_temp-&gt;p);<br>p_temp-&gt;p = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>知识总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识总结</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习入门（个人版）</title>
    <link href="/2021/08/19/py01/"/>
    <url>/2021/08/19/py01/</url>
    
    <content type="html"><![CDATA[<h1 id="一、输入和循环"><a href="#一、输入和循环" class="headerlink" title="一、输入和循环"></a>一、输入和循环</h1><p>用户输入：函数input（“输出的文本内容”）——等待用户输入，返回字符串<br>函数int（字符串）——字符串变数字，返回数字</p><p>while循环：<br>for循环用于针对集合中的每个元素（遍历），while循环不断执行直到满足特定条件。</p><p>格式：</p><pre><code class="hljs">while 条件：    操作；</code></pre><p>for-&gt;遍历列表，但不应修改，否则py将难以追踪元素。<br>while-&gt;遍历时修改。</p><h1 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h1><p>py的函数好方便，想怎么用就怎么用</p><p>定义：</p><pre><code class="hljs">def  函数名（参数）    函数体    return</code></pre><ul><li><p>参数</p><ol><li><pre><code class="hljs">位置实参——按位置给形参传值，普遍的</code></pre><ol start="2"><li><pre><code class="hljs">关键字实参——**形参名 = 实参**——**指定实参给哪个形参**（A=a，B=b）——不会出错，顺序可变</code></pre><ol start="3"><li><pre><code class="hljs">参数可以有默认值</code></pre>列表当参数——<strong>直接传列表名</strong>就OK，fun（A），A是列表名，与使用数组一样</li></ol></li></ol></li></ol></li><li><p>返回值：可以返回字典，列表</p></li><li><p>对列表的修改：给一个空列表，把原来的pop出来，处理好放在新的里</p></li><li><p>参数可以传列表的副本A[ : ]，<strong>保证原来的列表不被破坏</strong>（py没有类似const的声明吗？应该有吧）。</p></li></ul><p><strong>传任意个数的实参——形参用*k来写</strong><br>形参——（*k）——会在函数中创建一个名为k的元组，传几个参数都放元组中，一个也是（太方便了）</p><p>形参（A，*b）——第一个给A，剩下的都给b<br>形参（**a）——创建名为a的字典，并接收任意数量的键值对<br>如：实参列表：（K，‘name’ &#x3D; ‘a’，‘age‘ &#x3D; 25）——K是普通参数，剩下的需要**a，即字典接收。</p><ul><li><strong>导入模块——包含头文件</strong></li></ul><p>模块——.py文件（好像啥都是），里面有函数的定义（def）</p><p>导入：import A，导入A——<strong>使用A的函数时，要A.点出来</strong></p><p>导入特定函数：<br>from A import B——从A模块中导入B（函数名）<br>注：可以一次导多个（B，C，D……），这时再使用就不用.点出来了，可以直接用</p><p>给导入的函数起别名：<br>from A import B as C——C是B的别名<br>给导入的模块起别名：<br>import A as B——B是A的别名<br>导入所有函数：（不好，可能会有函数被覆盖）<br>from A import *</p><h1 id="三、类"><a href="#三、类" class="headerlink" title="三、类"></a>三、类</h1><ul><li><p>类的定义：<br>class Dog（）：<br>首字母大写的是类</p></li><li><p>构造函数——</p><pre><code class="hljs">  def __init__(self,传入参数):      函数体；</code></pre></li></ul><p><strong>注：init前后是两个下划线，为什么就没有书强调这一点？？？</strong><br>self——指向自己，不用传（感觉和this指针可能差不多）</p><p><strong>在构造函数中可以直接定义类的属性</strong>（因为py不用定义变量就能直接用），但每个属性要有初始值。</p><p>方法和函数没有区别，就是要加self参数<br>方法</p><pre><code class="hljs">def fun（self，参数）：    函数体；</code></pre><p>访问成员属性——点出来</p><ul><li><p>类的实例化：对象 &#x3D; 类（构造参数）；</p></li><li><p>继承：<br>class Dog（父类）：<br><strong>创建子类时也要把父类给搞定了，用子类的构造函数实现父类的创建。</strong><br>在子类的构造函数中可以使用特殊函数：<strong>super（），将父类和子类关联起来，在子类中调用父类的构造函数：super（）.<strong>init</strong>(传入父类构造函数的参数)；</strong>（C++初始化父类太绕了……晕）</p></li><li><p>重写——子类重写父类函数：函数名相同覆盖就OK</p></li><li><p>导入类：还是.py文件<br>form A import B——从A（文件名）中导入B（类名）<br>form A import *——导入所有类</p></li></ul><h1 id="五、文件操作"><a href="#五、文件操作" class="headerlink" title="五、文件操作"></a>五、文件操作</h1><ul><li><p>打开文件</p><pre><code class="hljs">  with open（‘文件名’） as B：</code></pre></li></ul><p>‘文件名’——是一个字符串，可以用变量替换<br>B——文件对象（类似fp指针，FILE结构体变量）<br>with——<strong>py自己看啥时候关，不用close了（py太省心了）</strong></p><ul><li><p>读文件——<br>B.read()——返回字符串形式，<strong>读到最后一个字符会多返回一个空字符</strong></p></li><li><p>文件路径：<br>1.在py程序的子文件夹中——‘子文件夹名\文件名’<br>2.绝对文件路径：‘C：\文件夹\文件夹\……’</p></li><li><p>逐行读取：<br>先打开，再——for line in B：——行遍历（每行末尾有个回车，可以用rstrip（）去掉）</p></li></ul><p>注：<strong>with返回的对象只有在with中才有效，想在别的地方用要把每行放列表中</strong>：lines &#x3D; B.readlines（）</p><ul><li><p>文件写入——只能写字符串</p><pre><code class="hljs">  with open（‘文件’，‘方式’）as B：      B.write（“字符串”）</code></pre></li></ul><p>方式<br>r——只读（默认）<br>w——格式化写入<br>a——追加<br>r+——读写</p><p>对w和a，文件不存在则创建</p><h1 id="六、异常处理"><a href="#六、异常处理" class="headerlink" title="六、异常处理"></a>六、异常处理</h1><p><strong>异常处理：try——expect（和try——catch差不多）</strong><br><strong>异常处理可以保证程序的顺利执行，而不中断</strong><br>1.除0:ZeroDivisionError</p><pre><code class="hljs">try：    代码块expect ZeroDivisionError：    处理</code></pre><p>当try代码块发生异常，expect查找对应异常的处理办法（这里给了除0的）</p><pre><code class="hljs">try：expect：else：</code></pre><p>其中else部分是try is OK的时候进入执行的。</p><p>2.FileNotFoundError——文件不存在</p><ul><li><p>异常时什么都不做：pass语句</p><pre><code class="hljs">  expect ……：      pass</code></pre></li></ul><h1 id="七、数据存储：json模块"><a href="#七、数据存储：json模块" class="headerlink" title="七、数据存储：json模块"></a>七、数据存储：json模块</h1><p><strong>import json</strong></p><p>存——json.dump(待存放数据，文件对象（fp）)<br>待存放数据可以是列表，字典</p><p>读——json.load（文件对象）</p><h1 id="八、杂记"><a href="#八、杂记" class="headerlink" title="八、杂记"></a>八、杂记</h1><p>字符串方法replace（）——可以把字符串中的特定部分换掉<br>A.replace（‘待换的’，‘换成什么’）</p><p>方法A.split（）——根据字符串创建一个列表，包含字符串中的单词</p><p>函数返回空：return None</p>]]></content>
    
    
    <categories>
      
      <category>知识分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识总结</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言总结项目和入门——指针篇</title>
    <link href="/2021/08/16/C04/"/>
    <url>/2021/08/16/C04/</url>
    
    <content type="html"><![CDATA[<h1 id="五、C语言入门——指针"><a href="#五、C语言入门——指针" class="headerlink" title="五、C语言入门——指针"></a>五、C语言入门——指针</h1><p><font color=#999AAA ><strong>注：本文中所有指针变量的名字遵循变量命名规则就OK，不用非要命名成p，p只是因为是pointer（指针）的首字母，所以大家都约定俗成的将指针命名成带p的。</strong></font></p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><p>&amp;ensp;&amp;ensp;OK，前面说了那么多嘴的指针，它终于来了！<br>&amp;ensp;&amp;ensp;学习C不学指针，相当于没学，C语言中最精彩的就是指针。<br>&amp;ensp;&amp;ensp;本章我将尽我最大的能力，争取带来比较清晰的理解，这应该是本系列功夫最大的文章。<br>&amp;ensp;&amp;ensp;好了废话不多说，我们开始吧，C语言的灵魂。</p><h1 id="一、地址、指针是什么"><a href="#一、地址、指针是什么" class="headerlink" title="一、地址、指针是什么"></a>一、地址、指针是什么</h1><p>&amp;ensp;&amp;ensp;前面我们将变量的定义比喻成开辟房间，定义一个变量，就会在内存中为这个变量开辟一定大小的空间来用于存放这个变量，开辟空间的大小取决于这个变量的类型（int型和double型的大小当然不一样了），我们可以用sizeof这个函数来查看某个变量所占的空间，数组类型的数据就是编译器在内存中连续开辟一长条空间，相当于数组包场子，包了数组元素个数*每个元素所用空间这么多的地方，打头的就是数组的第一个元素，这样依次往后排。<br>    &amp;ensp;&amp;ensp;如果不指定，变量被分到内存的哪里都是随机的，我们能不能知道它被分到哪里了呢，答案是可以的，变量被分到内存中哪里我们可以通过<strong>地址</strong>来描述，<strong>内存地址</strong>和我们的家庭地址什么的很像，它是用来描述一个变量住哪的，内存中的空间都是按地址大小依次排序组织的比如在内存开始的地方，它的地址就被编为0x0000（0x表示是16进制），它的下一个单元就被编为0x0001，以此类推。给变量分配地址虽然是随机的，但一定是以整数单元分配的，不可能说一个变量占这个单元的一般在加上另一个单元的一半，所以<strong>变量和地址是一一确定的，一个地址只会被一个变量占用</strong>，这和我们实际中的地址是一样的，总不可能说一个地址能找出来两个房间吧。<br>    &amp;ensp;&amp;ensp;OK，总而言之，<strong>地址就是变量开辟房间在内存中的编号</strong>，有了这个编号，我们能干什么？<br>    &amp;ensp;&amp;ensp;当你去找一个陌生人，你或许不知道他叫什么，但你依然可以通过他提供的地址直接去拜访他，地址就是干这用的，<strong>我们可以通过地址直接访问一个变量，而不用管它叫什么</strong>，我们前面是怎么访问一个变量的，通过变量名，现在有地址，我们就能通过地址去访问了。<br>    &amp;ensp;&amp;ensp;或许有人会说这有什么不同的吗。或许对变量来说，区别并不大，我知道变量名和知道它的地址的操作都差不多，但地址这个概念要是只局限在变量，格局小了。<br>    &amp;ensp;&amp;ensp;前面我们说了这么多，知道了变量的地址，这个地址本身也是数字，如0x0013，那既然是数字，我们当然可以用之前的数据类型来定义一个变量来存放这个数字，不过C语言对于这种表示地址的数字又搞了一个新的数据类型（C语言为了这个地址真是搞了不少），叫做指针，<strong>指针是一种数据类型，用指针声明的变量其值会被认为是一个地址</strong>。<br>    &amp;ensp;&amp;ensp;我并没有直接上指针的定义什么的代码，因为就算知道指针怎么定义又有什么用，理解才能应用，而不是没有感情的码字机器。<br>    &amp;ensp;&amp;ensp;再来说一些概念。<br>    &amp;ensp;&amp;ensp;我们现在有一个指针类型的变量了，里面有一个值，比如0x0000吧，我们就说这个指针<strong>指向</strong>0x0000这个单元，这个很好理解，指针里面就是地址嘛，地址就是指向个某个地方。<br>    &amp;ensp;&amp;ensp;我们通过变量名指名道姓的去访问一个变量的方式叫<strong>直接访问</strong>，我们通过指针，通过地址访问的方式叫<strong>间接访问</strong>，为什么呢？因为通过指针，要先有指针才行，可以这样理解：我们直接访问的是指针，指针再访问变量。<br>    &amp;ensp;&amp;ensp;更进一步的，指针就是放地址的，变量总是会开辟空间的，那么也就是说，指针类型的变量，其值是一个指向某个单元的地址，而它本身也是变量，会在内存中开辟一个空间，这个空间也有地址，有没有想到什么。既然都是地址，那么我<strong>再用一个指针来存放这个指针变量的地址</strong>，可不可以？当然是可以的，指向指针的指针是一个二级指针(有绕口令那味了),现在不理解当然没有问题，因为这个概念比较难了，这里只是强调指针就是放地址的这种观念。<br>    &amp;ensp;&amp;ensp;实际上，到了地址这层，什么变量，什么函数，都不复存在了，只要它们在存储器中，就一定有地址，就可以通过指针去访问，所以到了地址这一层，因为地址这个东西已经足够底层了，它就可以一视同仁。<strong>越基础，越强大，其各个组成的差别就越少，就可以一视同仁。</strong><br>    &amp;ensp;&amp;ensp;好了，回到程序上，指针是怎样定义的。<br>    &amp;ensp;&amp;ensp;首先，指针是有类型的，一种类型的指针只能指向一种类型的地址，比如一个char类型的指针变量只能指向char类型的变量，即它的值是一个char类型变量的地址，要是想让它指向double类型的，是不可以的.</p><ul><li>指针的定义：</li></ul><p>类型 *指针名；<br>    &amp;ensp;&amp;ensp;指针类型就是表示这是一个指向什么变量的指针，如上面的指向char类型的指针a，其定义就是char *a；<br>    &amp;ensp;&amp;ensp;注意*不能少，不然就成了普通变量的定义了。<br>    &amp;ensp;&amp;ensp;要注意的是，在定义过程中，*才表示这时一个指针变量，而没有延续性，如：char a，*b，c；其中只有b是char*类型的指针变量，a和c都是char类型的普通变量，简单来说就是，<strong>谁前面有*谁才是指针变量</strong>。<br>    &amp;ensp;&amp;ensp;同样的，我们还可以有int *a，double *a之类的指向不同数据类型变量的指针。<br>    &amp;ensp;&amp;ensp;<strong>指针为什么要有类型</strong>：我们知道指针就是个地址，我们想完整的访问一个变量需要什么，首先，这个变量在哪肯定是要知道的，但我们还要知道这个变量的界限，或者说，这个变量居住的房子的大小，因为如果这是个小变量，它住的地方就小，但我们却把它当做大变量，访问了后面不属于它而属于别人的空间，这明显是访问出错了，所以我们还需要知道存储这个变量的界限，以<strong>防止越界访问</strong>，这个界限怎么给呢？由于我们已经知道这个界限开始的地址，（变量的地址就是变量所在单元的其实地址），那么我们只要知道这个变量的大小就OK了，这个大小就是由类型提供的，指针类型告诉指针当访问这个地址变量的时候，它应该访问哪几个，不要超出访问。如char类型变量的指针，访问变量的时候就指访问地址这一个单元，后面的不管了，而int类型的指针则访问4个单元的值。所以<strong>指针和其指向的变量的类型要匹配，才能正确的访问这个变量</strong>。<br>&amp;ensp;&amp;ensp;指针的类型：前面把指针类型说的差不多了，<strong>但说法比较随意，这里再来做一些严谨的说法</strong>。指针变量的定义：int* a；其中a是指针变量的名字，它的类型是int*，是int指针（*表示指针），这个指针指向int类型的变量，所以说指针的类型应该是int*，说指针指向的数据类型应该是int。前面的说法或与有些出入，但都是为了好理解，理解最重要。<br>&amp;ensp;&amp;ensp;注意，由于指针类型是带*的（int*），不同于普通数据类型（int），所以a&#x3D;100；其中a是int*的指针，这种赋值是不行的，因为左右类型不匹配。</p><ul><li>指针的使用：</li></ul><p>&amp;ensp;&amp;ensp;首先，我们要介绍如何取得某个变量的地址。<br><strong>取址运算符：&amp;</strong><br>&amp;ensp;&amp;ensp;顾名思义，就是获得某个东西的地址，如&amp;a，就是获得a的地址。<br>那么这个地址当然是用指针来存放了，所以我们有了这样：int *p &#x3D; &amp;a；<br>&amp;ensp;&amp;ensp;p里面就是放这变量a的地址，或者说，指针p指向a。这是指针初始化的一种方法。</p><p><strong>指针运算符：</strong>*<br>&amp;ensp;&amp;ensp;我们知道指针的定义和赋值了，那么怎么通过指针访问变量呢？<br>&amp;ensp;&amp;ensp;我们使用指针运算符（我有时候叫它取值运算符，顾名思义，获取值的），如上面的例子，我们用p指向a，如何获取a的值：*p，就行了。*p就是p指向的变量的值，即a的值，由于p指向一个int类型的变量，或者说p的类型是int*，所以*p必然是int类型的值，需要用一个int类型的变量来接收，如int b&#x3D; *p；我们把这个值给b，那么b的值就和a的值相等，相当于a拷贝了一份给b。<br>&amp;ensp;&amp;ensp;很多人对于指针运算符和指针定义时的<em>感觉很懵。首先，只有在定义的时候才会有int*这种东西的使用（当然定义形参的时候也会有），其余的时候看见*基本都是指针运算符，其次还是抓住定义，int*p表示定义一个变量名是p的int*指针，</em>p表示p指向的值，既可以当左值也可以当右值，*p&#x3D;5表示给p指向的地址空间赋值为5，b&#x3D;*p表示对b赋p指向的地址空间中的值。</p><ul><li>指针当形参：</li></ul><p>&amp;ensp;&amp;ensp;指针也是数据类型，当然可以当形参给函数了，也就是说函数可以接收指针类型的数据，或者说，<strong>可以传地址到函数中</strong>。<br>&amp;ensp;&amp;ensp;前面我们说了，函数的参数列表感觉和变量的声明似的，指针是怎么声明的：int* p；包含指针的类型和指针变量名，形参也是如此：<br>&amp;ensp;&amp;ensp;int fun（int* p）{ }这是一个返回值为int类型的函数，它需要一个int*类型的指针当参数。</p><p>&amp;ensp;&amp;ensp;接下来，献上C语言指针最经典的例题。<br>&amp;ensp;&amp;ensp;<strong>例：编写swap函数实现两变量的交换。</strong><br>&amp;ensp;&amp;ensp;把变量比作水杯，把值比作水杯里的水，我们想交换两个杯中的水，很明显直接倒是不行的。还需要一个空杯当中介，我们就可以写出这样的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span><br>&#123;<br><span class="hljs-type">int</span> temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;看起类没啥问题，但运行后会发现，并没有交换，为什么。<br>&amp;ensp;&amp;ensp;前面都说过，函数的参数之间是值传递，这里的a，b只是我们想交换的数据的拷贝，原来的变量呢，由生存周期的知识，在进入函数后，它们都消失了，唯一留下了的就是它们的拷贝值，所以我们在函数中的交换对原变量没有影响，它们还是自己没变。<br>&amp;ensp;&amp;ensp;如果我们用指针的话呢。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> *b)</span><br>&#123;<br><span class="hljs-type">int</span> temp = *a;<br>*a = *b;<br>*b = temp;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;我们传入两个指针，在函数中对指针指向的值进行操作。<br>&amp;ensp;&amp;ensp;到了地址这一底层的东西，很多东西都不重要了。这个函数就是通过指针交换两个内存空间的值，理解起来和上面并无区别，但这个函数是可以实现功能的，为什么。<br>&amp;ensp;&amp;ensp;原因就是我们是对地址的直接操作，虽然进入函数后，原来是实参变量没了，<strong>虽然我经常这么说，但实际上并不是真的没了，不然函数返回之后还怎么用啊，它只是暂时的隐藏的了</strong>，它的还待在原来的地方，在原来的地址上，这意味着我们虽然无法在函数中通过变量名的方式访问（它已经隐藏了，编译器也无法访问，而形参是拷贝并不是它本身），但它的地址不会变，我们只要事先知道它的地址，就算它藏起来，我们也一样可以访问到它本身。而上面的值传递是什么情况，形参也是变量，值传递是怎么实现的，就是编译器为形参开辟空间，放入实参的值，所以形参和实参不是同一个变量，它们的地址是不同的，当函数返回后，形参的空间被回收了（生存周期结束了），所以我们改变形参的值没有意义。<br>&amp;ensp;&amp;ensp;还有第三种写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> *b)</span><br>&#123;<br><span class="hljs-type">int</span>* temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;我直接交换指针，这样虽然原来的变量的实际位置没有变，但访问的顺序变了。举个栗子，原来1指向a，2指向b，我们想交换a，b的值，其实我们可以交换1和2的指向，让1指向b，2指向a，虽然a，b本身没有交换，但当我们还是按1，2这样的顺序访问的时候，由于指向改变了，就会形成先访问b，再访问a的样子，好像实现了交换的样子。<br>&amp;ensp;&amp;ensp;其实仔细一看就会发现，这个和第一个是一样的，都是值传递，传进来的是他俩的地址没错，交换也交换了，<strong>但你交换形参的值和我实参有什么关系</strong>。所以虽然在函数里把指针的指向互换了，但函数返回后根本没有影响。<br>&amp;ensp;&amp;ensp;从上面的例子还能看出一个东西，以前函数只能返回一个值，想要返回多个值只能用全局变量带回来，现在有了指针，我们可以传指针进来，然后把函数的返回值写在那个指针所指向的区域，这样就算函数退出了，但函数写在那片区域的内容仍保留在那里，我们仍可以用那个地址的指针去访问，从而<strong>实现函数的多值返回</strong>。</p><h1 id="二、数组的指针"><a href="#二、数组的指针" class="headerlink" title="二、数组的指针"></a>二、数组的指针</h1><p>&amp;ensp;&amp;ensp;前面我们将的大多是普通变量的指针，如int<em>，double*之类的，数组也是数据类型，当然也有数组的指针。<br>&amp;ensp;&amp;ensp;指向数组元素的指针，这个很好说，因为一个数组的元素的类型是确定的，我们用相应的指针去指向就OK，如int类型的数组，就可以用int</em>的指针来指向其中的具体元素。<br>&amp;ensp;&amp;ensp;那么整个数组的指针是什么样的，我们知道指针就是放地址的，所以要搞清楚数组的地址是什么概念。<br>&amp;ensp;&amp;ensp;我们定义一个数组int a[10]；这个<strong>数组的地址就是数组第一个元素的地址</strong>，即&amp;a[0]。对于数组来说，<strong>数组名代表这个数组的地址</strong>，所以数组名和数组第一个元素的地址是等价的，即a &#x3D; &amp;a[0]。<br>这样说应该比较清楚，总的来说，我们说的一个数组的地址，就是数组第一个元素的地址，而C语言中数组名就是代表了数组中第一个元素的地址，所以数组的地址就是数组名代表的地址，也是数组中第一个元素的地址。<br>&amp;ensp;&amp;ensp;举个栗子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> *p1;<br><span class="hljs-type">int</span> *p2;<br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br>p1 = a;<br>p2 = &amp;a[<span class="hljs-number">0</span>];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,p1 == p2);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;结果是1，说明p1和p2是相等的，它们都是指向数组a的指针。<br>&amp;ensp;&amp;ensp;假设p是指向数组a的指针，我们直接使用p访问它指向的内存的元素，*p对吧，此时它访问的是a[0]，没有问题。<br>&amp;ensp;&amp;ensp;那么如何用指针访问a[1]呢，前面的知识告诉我们访问数组的元素可以用数组名加下标的方式，如a[2],a[3]。<br>&amp;ensp;&amp;ensp;我们要先搞清指向数组的指针的操作。p指向数组a，p+1指向哪里？实际上p+1也就是p++指向下一个元素单元，即a[1]。对指针的操作，如+1都将使指针指向下一个元素而不是单纯的指向下一个地址，如下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> *p = &amp;a;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x %x&quot;</span>,p,p++);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/26ec907265204e0bbeaeec2e059b61f5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;P++后p指向的地址直接+4，因为这是一个int*的指针，它指向的使int类型的数据，这个数据的内存空间地址是0x62fe18~0x62fe15，正好4个内存单元，和int类型的大小一样，所以指针+1后，会自动跳过这些属于上一个元素的地方，指向下一个元素。<br>&amp;ensp;&amp;ensp;总而言之，指针+1就是指向下一个单元的元素，而不是地址的单纯+1，同理-1也是一样的，当p1，p2指向同一数组的时候，p1-p2的结果为他俩之间的元素个数，没有指针相加的这种运算。<br>&amp;ensp;&amp;ensp;现在我们可以访问数组中的任意元素了，p指向a，可以看成p+0指向a[0]，那么p+1当然指向a[1]了。问题是，应该是*p+1，还是*（p+1）？<br>&amp;ensp;&amp;ensp;这实际上是优先级的问题，以前我们说过，单目运算符的优先级高于双目的，很明显*是单目运算符，所以它的优先级高于四则运算，那么要想正确的访问元素，就需要*（p+1），而*p+1是先取值，在加1，实现了一个自加1的操作。但需要注意的是，*的优先级高于同为单目的++和--，这意味着*p++是先取值，在++。<br>&amp;ensp;&amp;ensp;*（p+i）、a[i]、*（a+i）（首地址加偏移量）这三个的操作是等价的，a作为数组的地址，有一些指针的性质这也不过分。实际上，在编译时a[i]，就是按*（a+i）处理的。<br><strong>举个栗子：<br>遍历数组</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-type">int</span> *p = a;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>,*p++);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;这里*p++就是先执行*p，再执行p++，是符合逻辑的，如果变成*++p，就是先++p，再*p，这样将导致数组第一个元素没有被访问（一上来就++了），而且循环5次时p会超出数组界限访问，我们称为<strong>指针越界访问</strong>，这时非法的，应当避免。<br>&amp;ensp;&amp;ensp;甚至我们可以精简这个for循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-type">int</span> *p = a;<br><span class="hljs-keyword">for</span>(;p-a&lt;<span class="hljs-number">5</span>;p++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>,*p);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;我们不用i当循环变量了，直接用p，p-a，这是两个地址相减，和前面说的类似，结果时这两个地址之间的差的元素个数。<br>&amp;ensp;&amp;ensp;前面我们将函数的时候，对于数组当参数的时候，说过数组的长度其实此时并不关心，为啥呢。如int fun（int a[]）{ }，这是一个需要int类型的数组的函数，没有问题，我们调用这个函数的时候，是直接把数组名当实参传进去了，数组名是什么，数组的首地址，所以真相大白，函数就是需要一个指向int类型的地址，指针能带来地址，数组名也能带来地址，所以int fun（int*p）和上面的函数的参数是等价的，只不过用上面的定义可以让人看出这是要一个数组参数，而下面的这种就多了去了，int的变量也OK，指向性没有那么明确。<br>&amp;ensp;&amp;ensp;由于数组当参数是实际上只要了它的首地址，它的大小什么的是没管的，所以要是没有数组大小的元素传进来，在函数里谁也不知道这个首地址表示的范围是多少，所以一般传数组参数的时候，也要把长度传进来。</p><ul><li>指向多维数组的指针</li></ul><p>这是一大难点，本来多维数组就挺难的了，和指针一搞又复杂了，前面数组的时候多维数组知识简单讲了一下，这里正好来说说。</p><p>主要以二维数组为例。</p><p>二维数组：int a[3][5] &#x3D; {{1，2，3}，{5，6}，{8}}，定义一个3行5列的数组，并对其赋初值，没有的会自动补0。</p><p>二维数组就是一维套一维，它可以看作是两个一维的叠加，二维数组的元素是一些一维数组，我们就按着这个思路用指针去一层一层拨开，就能访问到里面的元素了。</p><p>具体怎么说：a[0]表示什么，按照上面的说法，a[0]应该表示一个一维数组，或者说a[0]表示一个一维数组的数组名，那么我们想访问这个数组里面的元素，怎么说就很简单了，a[0][1]就是访问这里面第2个元素，这样看起类可能容易混，我们用K这个符号代替a[0]这个数组名，就变成了K[1]，是不是明了多了，我们就实现了把一个二维数组拆成2个一维数组。</p><p>从上面的例子可以看出，二维数组的第一维（a[0]）可以理解为第二维的的数组的名字，我们就是先访问的第一维（a[0]）由于二维数组的第一维仍然是一个数组，我们还是使用下标的方式来访问（a[0][1]），这就是二维数组的访问方式。</p><p>由前面的例子，我们知道用下标访问和用指针访问其实是同样的。同样的，二维数组的数组名也代表这个二维数组的地址，那么二维数组第一维当然是*（a+i）访问了，我们访问完数组的第一维，得到的是数组第二维的数组的地址，或者可以理解为是第二维数组的数组名，二维数组第一维是行，第二维是列，我们通过对第一维的访问确定要访问的元素再哪一行，再通过第二维访问确定在那一列，就可以具体的访问到这个元素了。这样看来，我们先访问列，再访问行也行，线代是这么说，但C语言不可以这样搞，和二维数组的存储顺序有关。</p><p>我们现在访问第二维，由于二维数组第二维也是一个一维数组，我们还是按之前的访问，就能得到*（a+i）+j，*（a+i）是第一维，它的结果是一个一维数组，即第二维。*（a+i）+j，由前面的知识我们知道*（a+i）和a[i]是一样的，所以上式变为a[i]+j，a[i]表示的是的第二维的地址，+j表示地址的偏移，所以它还是个地址，想要访问a[i][j]，需要*（*（a+i）+j），这就是二维数组的访问。</p><p>我们总结一下：a是二维数组的数组名，当然也是首地址，是第0行的首地址，即a和a[0]的地址是一样的，都是地址。a[i]（即*（a+i））是数组第一维，是对数组的行选择，a[i]是数组第二维的首地址，即a[i]和&amp;a[i][0]是一样的（由前面的知识，一维数组的数组名和第一个元素的地址是一样的），a[i][j]即*(a[i]+j)即*(*(a+i)+j)，访问的结果是二维数组的具体元素，a[i]访问的结果是一个一维数组（其实是第二维数组）的地址。<br>a+i访问的是什么，*（a+i）是一个数组的地址，那a+i就应该是地址的地址，是一个二级地址，实际上a+i表示的就是第i行的地址的地址，或者说第i行的首地址。</p><ul><li>二维数组指针的定义</li></ul><p>&amp;ensp;&amp;ensp;首先，二维数组在内存中是怎样存储的。答案是线性存储，因为内存空间是线性的，数据的存储必然是线性的。在内存中是一行一行的存储，即先存二维数组的第一行（a[0]），紧接着存第二行(a[1])，以此类推。<br>&amp;ensp;&amp;ensp;按照我们上面的方法，我们首先要想办法搞到二维数组的行，由于二维数组的行也是一个地址（a[i]），其指向本行的列数组（a[i][j]），所以我们需要一个指向地址的指针来当行地址。<br>&amp;ensp;&amp;ensp;指针定义：int （*p）[j]；<br>&amp;ensp;&amp;ensp;这个看起类很麻烦，其实这就是一个行指针的定义，或者说，这是一个指向一维数组的指针的定义，p指针指向一个长度为j的一维数组。<br>注意：（*p）的括号是不可少的，要是变成int *p[j]，由于[ ]的优先级更高，就会先变成p[j]，其类型是int*，这是一个指针数组的定义（后面会讲）。<br>&amp;ensp;&amp;ensp;既然是指向一维数组，那普通的数组能不能用这个来访问，答案是可以的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> (*p)[<span class="hljs-number">5</span>];<br>p = &amp;a;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,(*p)[<span class="hljs-number">2</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;这个东西比较复杂，首先p（指向一维数组的指针）和a（数组名）有什么区别。我们直接使用a[2]的时候，a是代表了这个数组的地址，而p是一个指针，指向了这个数组，所以p需要指向a，才能说p是指向一个一维数组，即指向这个数组的起始地址（a），p怎么指向a，就是p&#x3D;&amp;a，如果p&#x3D;a，表示p的值是&amp;a[0]，即数组a[0]元素的地址，是具体的元素，而不是一个一维数组，要区分p指向起始地址（p是指向地址的指针）和p的值是起始地址（p就是个普通指针，里面放着地址）的区别。<br>&amp;ensp;&amp;ensp;访问的时候，由于p是指向地址（一维数组的起始地址）的指针，我们先取值运算（*p），得到这个一维数组的起始地址，然后就好说了，因为数组的起始地址和数组名不有相同之处啊，直接（*p）[2]，就能访问第二个元素了，更直接的，我们把（*p）用a代替（因为它们就是一样的，*（&amp;a）不就是a嘛），就变成了a[2]，更直接了。<br>&amp;ensp;&amp;ensp;大家可以发现，*和&amp;互为逆运算，使用指针的时候要会带入，就那上面的例子，p &#x3D; &amp;a; (*p)[2]；，把p &#x3D; &amp;a带入，就直接成了a[2]，这样对于理解代码和使用起来更有帮助。<br>&amp;ensp;&amp;ensp;好了，如何用指向一维数组的指针访问二维数组。<br>&amp;ensp;&amp;ensp;二维数组就是好几个一维数组的叠加嘛，它的每一行是一个一维数组，我们就让p指向这些一维数组就OK了。<br>&amp;ensp;&amp;ensp;对于二维数组a[i][j]，它的行对应的一维数组有j个元素，所以我们要用int （*p）[j]来定义指针。<br>&amp;ensp;&amp;ensp;二维数组的数组名是整个数组的起始地址，因为它可以看成(a+0)，即是第一行的首地址，如果我们想访问第二行的地址，就（a+1），这个a好像就是指向数组每一行的一个指针，我们前面访问数组的时候，先通过第一维（行），再访问第二维（列），我们也是用数组名进行操作的，所以数组名可以看成一个指向行数组的指针，和p的类型相同，所以我们直接p&#x3D;a，就能让p指向这个数组的行。<br>&amp;ensp;&amp;ensp;接下来的访问就很简单了，p和a差不多，访问当然也相似，<strong>*（*（p+i）+j）——访问第i行第j列的元素。（*（p+i）+j）——第i行第j列的元素的地址，*（p+i）——第i行的地址，（p+i）——指向第i行的指针（指向一维数组的指针），p——指向第0行的指针（i&#x3D;0）</strong>。<br>&amp;ensp;&amp;ensp;需要注意的是，int （*p）[j]；不同的j是不同的指针，虽然它们都是指向一维int类型数组的指针，但它们并不是同种类型，原因是它们指向空间的大小不同，在二维数组中，我们对p+1，p就能指向下一行，这是怎么做到的。<strong>指向一维数组的指针有一个重要的参数是其指向空间（存储一个一维数组）的大小，当p+1时，它就跳过这些空间，指向下一个</strong>，这和数组的指向下一个有异曲同工之处。那么这些空间大小怎么告诉呢？既然这些空间存放的是数组，那么有数组的类型和个数就能推出这片空间的大小，指针就能正确跳过这些，指向下一个，<strong>这就是我们定义指向一维数组的指针时需要提供其指向的元素个数的原因</strong>。</p><p>指向数组的指针当参数：<br>&amp;ensp;&amp;ensp;一维数组的指针当参数我们很熟悉，普通的指针就能当一维数组的指针，前面的讲的，函数使用数组当参数时其接收的起始就是一个指针。<br>&amp;ensp;&amp;ensp;二维的数组指针当参数，其函数的定义当然是举个例子：int fun（int （*p）[4]，int n），这是一个需要指向4个元素的一维数组的指针和一个整型参数的函数，这个n可以用来表示这个二维数组有多少行，因为这个二维数组的列的信息已经包含在指向一维数组的指针里了。<br>&amp;ensp;&amp;ensp;对于一个指向二维数组的指针p，这个指针一般都是采用指向一维数组的指针来定义的，*（p+i）表示第i行的地址，这个信息可以给需要一维数组的指针的函数，即传给一个指针类型的形参。</p><ul><li>指向字符串的指针</li></ul><p>&amp;ensp;&amp;ensp;对于字符串这个数据类型，C语言用数组来接收，我们前面也提过了，字符串可以这样定义：char a[] &#x3D; “String!”，编译器会认得这是个字符串，在结尾自动加结束标志。我们输出这个字符串：printf（“%s”，a）；这个a是数组名，那就是地址了，这个printf实际上只需要一个指向字符串的指针，它就会一直执行输出，直到碰到结束标志。所以可以用一个指向char类型的指针，即char*类型的指针来接收。<br>&amp;ensp;&amp;ensp;这或许没什么，但实际上我们可以这样：char *p &#x3D; “String!”；<strong>直接用一个指针指向一个字符串，编译器会将p指向这个字符串的地址</strong>，而不是把什么S这个字符放在p里面，int *p &#x3D; 45；这种是不行的，因为你强制p指向地址为45的地方，而没有人知道哪里放着什么，但字符串可以这么用。<br>&amp;ensp;&amp;ensp;需要注意的是，别忘了字符串还有一个隐形的结束标志。<br>&amp;ensp;&amp;ensp;接下来我们来练个手<br>&amp;ensp;&amp;ensp;<strong>例：编写自己的字符串输出函数</strong><br>&amp;ensp;&amp;ensp;思路我们前面说了，直接上码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Print</span><span class="hljs-params">(<span class="hljs-type">char</span> *p)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> *a = <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>Print(a);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Print</span><span class="hljs-params">(<span class="hljs-type">char</span> *p)</span><br>&#123;<br><span class="hljs-keyword">for</span>(;*p != <span class="hljs-string">&#x27;\0&#x27;</span>;p++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,*p);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/314d42c3faf5421eb8e70ae36828a56e.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;其实这个很简单了，我们判断如果不是结束标识，就一直向后输出。<br>&amp;ensp;&amp;ensp;自己写的函数是不是比printf函数用起来方便多了，直接给个a就OK，虽然这个函数还行没啥用，人家能做的比你更好，<strong>但学习C语言，重要的一点就是写自己的函数，别指望有什么能现成用，只有你自己知道自己想要什么样的，什么功能的函数</strong>，这样写出来的函数才是高效的，程序才是简练的。套用别人的东西是没法增强自己代码功底的。<br>&amp;ensp;&amp;ensp;注意：只要是一个char*的指针，就能用来接收字符串，它将指向这些字符串的首地址。</p><p>&amp;ensp;&amp;ensp;<strong>例：字符串复制函数：</strong><br>&amp;ensp;&amp;ensp;前面我们将过strcpy这个字符串复制函数，这里我们自己来尝试实现一下。<br>首先指出<br>    &amp;ensp;&amp;ensp;char *a1  &#x3D; “Hello World!”;<br>    &amp;ensp;&amp;ensp;char *a2 &#x3D; a1;<br>&amp;ensp;&amp;ensp;希望通过这种直接复制的操作是不行的，虽然打印a1，a2出来是一样的，但实际上这样知识让a2和a1指向同一个字符串，这个字符串在内存中还是只有一个。<br>&amp;ensp;&amp;ensp;我们通过一个一个字符复制的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Strcpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *p1,<span class="hljs-type">char</span> *p2)</span>;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> *a = <span class="hljs-string">&quot;Hello World!&quot;</span>;<br><span class="hljs-type">char</span> k[<span class="hljs-number">20</span>];<br>Strcpy(a,k);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,k);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Strcpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *p1,<span class="hljs-type">char</span> *p2)</span><br>&#123;<br><span class="hljs-keyword">for</span>(;;p1++,p2++)<br>&#123;<br>*p2 = *p1;<br><span class="hljs-keyword">if</span>(*p1 == <span class="hljs-string">&#x27;\0&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;这里注意，要把<strong>字符串的结束标志拷过去</strong>，所以if判断要在拷贝之后。<br>&amp;ensp;&amp;ensp;这个return，在void函数中不是不能有，它只是表示函数推出的标志，而不返回任何值，并不冲突（复习了啊）。<br>&amp;ensp;&amp;ensp;这个函数要求复制过去的地方要能放下，这个要求其实很烦人，我们后面会提供一个更号的解决方法。<br>&amp;ensp;&amp;ensp;给大家看一下高级的代码，函数体只有一句：<br>&amp;ensp;&amp;ensp;while（*p2++ &#x3D; *p1++）；<br>&amp;ensp;&amp;ensp;就实现了上面的功能，我虽然可以改进我自己写的函数，但要写成这样怕是很难想到了。这是将运算符运用的很极致的表现，首先根据优先级，会执行*p2 &#x3D; *p1的操作，这是一个赋值操作，之后p1，p2++，指向下一个单元，但赋值表达式是有值的，它的值就是它最后赋的值，这里是刚赋值完成的*p2的值，当*p2 不等于‘\0‘，由于‘\0‘的ASCII值也为0，所以这个表达式的值就不为0，while循环会继续下去，当*p2 等于‘\0‘时，while循环的条件为0，退出循环。<br>&amp;ensp;&amp;ensp;大家会发现，对于数组，或者是字符串，它们的数组名可以直接串给形参指针，因为指针就是放地址的（抓定义），实参是地址，当然能传了，同样的，函数的参数声明中，你说要一个数组，和说要一个指针，没有区别，因为都是传地址过来。</p><ul><li>字符指针和字符数组的区别</li></ul><p>&amp;ensp;&amp;ensp;数组中存放的是这个字符串的各个字符，字符指针存放的是这个字符串的首地址。<br>&amp;ensp;&amp;ensp;可以对字符指针直接赋值字符串，但数组要是不在定义的时候就初始化，就要一个一个元素赋值。<br>&amp;ensp;&amp;ensp;指针变量可以改变其指向，但数组名是地址，不能变。<br>&amp;ensp;&amp;ensp;注意，虽然字符指针可以存放字符串，于是有人希望通过<br>&amp;ensp;&amp;ensp;char *a;<br>&amp;ensp;&amp;ensp;scanf(“%s”,a);<br>&amp;ensp;&amp;ensp;这样的代码来实现脱离数组输入时可能超出数组上限的限制的问题，看起来没错，也可以运行，但这样的危险系数很大，一般都不可以使用的。<br>&amp;ensp;&amp;ensp;原因是a的值没有被初始化，或者说a作为指针没有明确指向，<strong>对于没有初始化，没有明确指向的指针，我们叫它野指针</strong>，野指针的存在是指针使用中非常容易产生bug的地方，因为谁也不知道它把东西写哪去了，我们前面说过，变量不初始化的话，里面的值是未知的，普通变量还好，因为就算是未知的值，但我只是用这个值，大不了程序算出来的结果不对。但指针的特殊性将导致这个问题十分严重，因为指针中的值是地址，而这个地址现在谁也不知道指向哪里，要是指向一些重要的内存单元（如操作系统的内存区），你后面还想写东西进去，直接把操作系统篡改了，这不完了嘛（当然这只是个例子，加深理解，现在的电脑是不能轻易访问这种高权限的内存区域的，指针也不行）。如我们想向0x01这个地方写东西</p><pre><code class="hljs">int main()&#123;    char *a = 0x01;    scanf(&quot;%s&quot;,a);    return 0;&#125;</code></pre><p>运行：<br><img src="https://img-blog.csdnimg.cn/f27f1bf763384c6aa85c32e55e3b7895.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;上面OK是我输入的，看起来也没啥问题，只是运行时间更长了。其实这个程序已经崩了，大家看返回值：322122什么的，<strong>我们main函数执行完应该返回啥，return 0啊</strong>（你以为写了这么多次的return值是白写的嘛，这里就有大用），大家看前面的运行结果，都是返回0，这个返回值明显就不是main函数返回的，所以main函数其实已经崩了，怎么崩的，我们来调试就知道了<br>&amp;ensp;&amp;ensp;我们加断点：<br><img src="https://img-blog.csdnimg.cn/8464410578a049a6a8916222e01dcab4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>调试<br><img src="https://img-blog.csdnimg.cn/97ac9fab3ccd48de836b076e2ba9dbb7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>大家注意，这里我还没按回车，这个输入还没写呢，我一按回车。<br><img src="https://img-blog.csdnimg.cn/2fce84cebc8746f6a812998061369ed5.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;出现这个窗口，就说明程序崩溃了，<br>&amp;ensp;&amp;ensp;然后我点OK，显示CPU窗口，然后电脑cpu就满了，之后直接Dev c++闪退（我也不清楚为啥会这样……）<br>&amp;ensp;&amp;ensp;这个例子就是告诉大家指针要是指向写不明不白的地方，后果很严重，<strong>杜绝野指针，从你我做起。</strong></p><p>&amp;ensp;&amp;ensp;字符指针有很有意思的一点，<br>&amp;ensp;&amp;ensp;char *n &#x3D; “a &#x3D; %d,b &#x3D; %d\n”；<br>&amp;ensp;&amp;ensp;这个字符串定义并给n赋值，没有问题，但这个字符串不眼熟嘛，这不是有很多格式字符，这和printf，scanf双引号里面的东西很想。<br>&amp;ensp;&amp;ensp;确实如此，它们可以直接替换：printf(n,a,b)；把n用它指向的替换就得到<br>printf(“a &#x3D; %d,b &#x3D; %d\n”,a,b);<br>&amp;ensp;&amp;ensp;这是可以的，printf(n,a,b)这种输出函数叫<strong>可变格式输出函数</strong>。</p><h1 id="三、指向函数的指针"><a href="#三、指向函数的指针" class="headerlink" title="三、指向函数的指针"></a>三、指向函数的指针</h1><p>&amp;ensp;&amp;ensp;前面的指针都好理解，因为它们都是指向变量，int* ，char*什么的，但函数是程序，怎么有指向函数的指针。<br>&amp;ensp;&amp;ensp;抓定义：指针就是放地址的，函数是程序，程序放在内存中等待执行，在内存中就有地址，就能用指针指向，<strong>万物皆可指针</strong>，因为万物都在存储单元中，都有地址，所以后面如果还有指向神奇地方的指针，不用惊讶。<br>&amp;ensp;&amp;ensp;指向函数的指针，我们叫函数指针，它里面放的是函数的入口地址，我们的函数在定义好之后，会被放在一个地方，当调用它的时候，程序就会去那个地方去取，这个地方就是函数的入口地址，程序怎么知道那么多代码，那些是函数的？我们有return返回语句，表示一个函数应该回去了，结束了（void可以没有，需要看程序的大括号）。</p><ul><li>函数指针的定义</li></ul><p>&amp;ensp;&amp;ensp;函数类型 （*p）（函数的参数类型）；<br>&amp;ensp;&amp;ensp;p是函数指针的名字，举个例子：<br>&amp;ensp;&amp;ensp;int (*p)(int ,char ,int*);<br>&amp;ensp;&amp;ensp;这是一个指向int类型的，其参数需要int，char，int*三个类型的函数，p是这个函数指针的名字。<br><strong>函数指针只能指向特定类型的函数，这是在它定义的时候写死了的。</strong><br>&amp;ensp;&amp;ensp;注意：（*p）的括号同样不可省，不然就成了返回指针的函数的声明了（后面会说）</p><ul><li>函数指针的调用</li></ul><p>&amp;ensp;&amp;ensp;首先定义指针，然后让指针指向一个函数<br>&amp;ensp;&amp;ensp;p是一个函数指针，max是一个函数名，p指向max函数——p &#x3D; max；OK，很简单。<br>&amp;ensp;&amp;ensp;指完了，怎么调用：首先我们肯定要获取这个函数，我们如何获取一个指针指向的变量——*p，同样的，我们用（<em>p）来获取这个函数，相当于（</em>p）就是max，然后就好说了<br>&amp;ensp;&amp;ensp;c &#x3D; （*p）（a，b）；<br>&amp;ensp;&amp;ensp;假设max函数是有两个int类型的参数，即max的声明：int max（int，int）；a，b，c是三个整型变量，由（<em>p）相当于max，我们替换c &#x3D; max（a，b）；这不就是函数的调用嘛。注意，（*p）（a，b）的（*p）的括号不要少。<br>&amp;ensp;&amp;ensp;既然p是指向函数的入口地址，那可以用p+1直接指向函数后面的命令嘛？当然不可以，*<em>函数必须从入口地址进入，从中间进是不行的。即函数指针不能算术运算。</em></em><br>&amp;ensp;&amp;ensp;<strong>函数指针可以实现同一语句（函数调用语句）实现不同函数的功能。</strong><br>&amp;ensp;&amp;ensp;函数指针还可以当函数的参数，即给函数传函数指针（绕起来了）。<br>&amp;ensp;&amp;ensp;例如：void fun(int (*p)(int,double)){  }；<br>&amp;ensp;&amp;ensp;这样的一个函数，它的形参是一个函数指针，说明它需要传入一个函数指针，可以通过形参名p来直接调用这个函数。<br>&amp;ensp;&amp;ensp;看起来很寡，我直接在函数里用别的函数不就行了，因为函数只要声明为全局的，在这个程序哪里都能用，我还干嘛传个函数进来用指针呢？<br>&amp;ensp;&amp;ensp;话粗理不粗，好像确实是更麻烦了，当我们可以通过函数指针的调用，实现一个基于这些函数上的通用函数，而不用每次更改函数本体，只要改变传入的参数，就能实现对另一个函数的同样操作，这增强了函数的灵活性，结构化设计。<br>&amp;ensp;&amp;ensp;不懂好说，我开始也是蒙蔽的，上例子。<br>&amp;ensp;&amp;ensp;<strong>例：编写计算定积分的函数。</strong><br>&amp;ensp;&amp;ensp;我们有很多函数，我们叫函数1，2，3……，它们都是x和y的单值函数，我们分别要求它们的定积分，怎么办，如果单纯的用函数，我们必然运行先写函数1，然后再把定积分函数中的函数1都换成函数2，再求一遍……，这样导致程序需要每次运行都改了才行，效率很低，我们可以<strong>传入函数指针</strong>，因为求数值定积分对函数是什么没什么大要求（这里涉及数值积分的知识，我一时半会也说不清，不过不影响理解），我们只关心函数的表达式（即对应法则）和节点，<strong>我们更可以用一个指针数组（后面会说），把所有函数的指针放进去，像访问数组那样一个一个的访问函数</strong>。<br>假设我们有这样一些函数：1+x^2^,e^x^+5,3x+2,x^5^+3x^3^+4;<br>&amp;ensp;&amp;ensp;求这些函数的定积分：<br>&amp;ensp;&amp;ensp;上代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;math.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> E 2.71828</span><br><br><span class="hljs-type">double</span> <span class="hljs-title function_">Integral</span><span class="hljs-params">(<span class="hljs-type">double</span>(*p)(<span class="hljs-type">double</span>),<span class="hljs-type">double</span> a,<span class="hljs-type">double</span> b)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">fun1</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">fun2</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">fun3</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">fun4</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Myfunction</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>Myfunction();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Myfunction</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">double</span> a,b;<br><span class="hljs-type">double</span> (*p)(<span class="hljs-type">double</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入上下限:&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf%lf&quot;</span>,&amp;a,&amp;b);<br>p = fun1;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fun1结果为：%lf\n&quot;</span>,Integral(p,a,b));<br>p = fun2;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fun2结果为：%lf\n&quot;</span>,Integral(p,a,b));<br>p = fun3;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fun3结果为：%lf\n&quot;</span>,Integral(p,a,b));<br>p = fun4;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fun4结果为：%lf\n&quot;</span>,Integral(p,a,b));<br><br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">Integral</span><span class="hljs-params">(<span class="hljs-type">double</span>(*p)(<span class="hljs-type">double</span>),<span class="hljs-type">double</span> a,<span class="hljs-type">double</span> b)</span><br>&#123;<br><span class="hljs-type">double</span> res = (b-a)*((*p)(a)+<span class="hljs-number">4</span>*(*p)((a+b)/<span class="hljs-number">2</span>)+(*p)(b))/<span class="hljs-number">6</span>;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">fun1</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+x*x;<br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">fun2</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(E,x)+<span class="hljs-number">5</span>;<br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">fun3</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">3</span>*x+<span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">fun4</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(x,<span class="hljs-number">5</span>)+<span class="hljs-number">3</span>*<span class="hljs-built_in">pow</span>(x,<span class="hljs-number">3</span>)+<span class="hljs-number">4</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/6667664acb2f4d078a8f48f6ee23a7ef.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;同样的结构，产生不同的运行过程，就式函数指针的用处。<br>&amp;ensp;&amp;ensp;上面能用同一个函数指针的关键在于它们都是一个变量，即一个参数，这样才能使指针统一。<br>&amp;ensp;&amp;ensp;对于fun函数，大家应该很容易看出来这是上面提到的几个函数的编程化，对于Integral这个求积函数，没有数值积分基础的话大家可以不用管，<strong>毕竟术业有专攻，我们是来学C语言的，这些东西可以以后慢慢学，循序渐进嘛</strong>，大家只要知道通过这个函数，输入被积函数（这里的fun），积分上下限，这个函数就能返回这个积分值就行了，具体里面res为什么要写成这种的等式，就是数值积分的知识了，有兴趣的话可以了解一下这个<strong>辛普森积分公式</strong>。<br>&amp;ensp;&amp;ensp;对于学过或者了解过数值积分，可以看出来，<strong>这个积分是有误差的</strong>，结果和算出来的值有些误差比较大，有些没有误差，为啥呢？首先我使用的辛普森公式，<strong>它的代数精度是3阶</strong>，即对不超过3次的积分精确成立，上面第一个和第三个被积多项式均小于3阶，所以fun1和fun3的结果是准确的，而对于fun4，是5阶多项式，会存在误差，辛普森公式有误差的表达形式，这里就不算误差上限了。这个结果比较粗糙，我们有几种方法改进：用复化辛普森公式增加节点数量或者用更高阶的求积公式。</p><h1 id="四、返回指针的函数"><a href="#四、返回指针的函数" class="headerlink" title="四、返回指针的函数"></a>四、返回指针的函数</h1><p>&amp;ensp;&amp;ensp;指针作为一种变量类型，当然可以定义返回指针类型的函数了。<br>&amp;ensp;&amp;ensp;<strong>int* fun（）；这是一个返回int*类型的指针的函数的声明。<br>&amp;ensp;&amp;ensp;int（*fun）（）；这是一个指向int函数的名为fun的函数指针。</strong><br>&amp;ensp;&amp;ensp;懂得括号的重要意义了吧。<br>&amp;ensp;&amp;ensp;返回指针这个很好理解，和返回普通类型变量没啥太大区别。需要注意的是，<strong>不要返回函数中定义的变量的地址（一些特殊声明的变量除外），因为没有意义</strong>。</p><pre><code class="hljs">int* fun()&#123;    int a=0;    return &amp;a;&#125;</code></pre><p>&amp;ensp;&amp;ensp;这是一个返回指针的函数，或许有人觉得这是一个返回地址的函数，但我们这样</p><pre><code class="hljs">int* fun()&#123;    int a=0;    int *p = &amp;a;    return p;&#125;</code></pre><p>&amp;ensp;&amp;ensp;函数返回的是变量的值，p是指针，其值是a的地址，那和我直接返回&amp;a有啥区别。<br>&amp;ensp;&amp;ensp;指针里放的是地址，所以我只要返回一个地址，就OK了，<strong>因为函数的返回值是需要同类型的变量接收的</strong>，比如这个函数的返回值就要一个int*类型的指针接收，所以返回一个地址，用对应的指针接收。<br>&amp;ensp;&amp;ensp;问题出在这个a是函数内的变量，由前面生存周期的概念，这个函数一旦返回，a就消失了，<strong>这个消失怎么理解，就是编译器不认你这个变量了，从前你是个变量，但现在你不是了</strong>，我们定义<strong>变量有一个特点是什么，就是变量会一直保留住自己的地盘不会被轻易夺走或改变</strong>，就是说编译器不会再对变量的内存区间做什么开辟变量之类的操作，因为这个地方已经有人（变量）了，而<strong>编译器一旦不认你这个变量，你的地盘就被编译器收回去了</strong>，（编译器就是地霸，所有变量住的地方都是他给的，消失的变量的地它就收回去），收回去的地可就由编译器自己掌控了，指不定就有分给哪个变量了，你希望通过这个指针访问这片地，可以，但这个地的内容可能已经经过好几手变量的改造了，你说你这个值还能读回去吗？</p><h1 id="五、指针数组"><a href="#五、指针数组" class="headerlink" title="五、指针数组"></a>五、指针数组</h1><p>&amp;ensp;&amp;ensp;顾名思义，就是里面全是指针的数组，指针的类型是什么：基本类型*，什么int*，char*，那根据数组的定义规则，指针数组就很好定义了。<br>&amp;ensp;&amp;ensp;<strong>定义：int* p[4]——这是一个4个全是指向整型的指针的数组，叫p，<br>&amp;ensp;&amp;ensp;int（*p）[4]——这是一个指向含4个元素的一维数组的指针。</strong><br>&amp;ensp;&amp;ensp;知道区别了吧。<br>&amp;ensp;&amp;ensp;char* p[4]——当然是char*类型的指针数组了。<br>&amp;ensp;&amp;ensp;指针数组可以存放指向一些字符串的指针，就减少了存储一定量文本使用二维数组带来的开销（二维数组一定是方方正正的，而不同字符串有长有短）</p><h1 id="六、二级指针：指向指针的指针"><a href="#六、二级指针：指向指针的指针" class="headerlink" title="六、二级指针：指向指针的指针"></a>六、二级指针：指向指针的指针</h1><p>&amp;ensp;&amp;ensp;前面已经说了，指针也是变量，有内存单元，可以被指向。<br>&amp;ensp;&amp;ensp;<strong>普通指针（一级指针）：int* p；<br>&amp;ensp;&amp;ensp;二级指针：int**p</strong><br>&amp;ensp;&amp;ensp;是不是很直观形象，相信大家三级指针也会定义了：int***p<br>&amp;ensp;&amp;ensp;注意，int**p表示p是一个指向int*类型的指针，而int*是指针类型。<br>&amp;ensp;&amp;ensp;前面我们说了指针数组中的元素是指针，如果我想通过指针访问这个指针数组，我就需要一个二级指针。</p><h1 id="七、main函数"><a href="#七、main函数" class="headerlink" title="七、main函数"></a>七、main函数</h1><p>&amp;ensp;&amp;ensp;我们以前介绍main函数的时候说过，main函数别看参数写的时候是空的，其实它是有参数的，main函数的原型：<br>&amp;ensp;&amp;ensp;int main（int argc，char* argv[ ]）<br>&amp;ensp;&amp;ensp;这些参数由操作系统调用的时候给出，具体main函数是怎么调用，形参怎么使用的，这里就不展开讲述了，毕竟这里不会讲太深。</p><h1 id="八、小结"><a href="#八、小结" class="headerlink" title="八、小结"></a>八、小结</h1><p>&amp;ensp;&amp;ensp;指针在C语言中的地位就是皇冠上的明珠，这里讲解的都是指针的基础知识和用法，更为高深的还需要努力，对指针做一个小结（以int类型举例）：<br><strong>int *p——指向整型的指针<br>int **p——指向整型的二级指针<br>int a[5]——数组<br>int* p[5]——数组指针<br>int (*p)[5]——指向含5个元素的一维数组指针<br>int (*p)(int)——指向参数为int，返回值为int类型的函数的指针<br>int* p(int)——返回int*类型指针的函数</strong></p><p>&amp;ensp;&amp;ensp;数组名——数组的首地址，二维数组的一维是第二维（也是一个数组）的对应首地址。<br>&amp;ensp;&amp;ensp;指针就是接收地址的。<br>&amp;ensp;&amp;ensp;补充一个知识，指针只定义不赋值，它就是野指针，我们要避免这种东西的发生，<strong>而有时候我们又不希望它指向什么地方，怎么给指针赋值？答案是赋值为NULL</strong>，NULL是一个宏定义，表示0，系统可以保证0这个单元没有有效的东西，访问读写不会产生影响.</p><p>&amp;ensp;&amp;ensp;这一章真是费工夫了居然写了2w字(￣_,￣ )，我们下一章再见！</p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">]]></content>
    
    
    <categories>
      
      <category>知识总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识总结</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言总结项目和入门特别篇——调试和多文件工程</title>
    <link href="/2021/08/11/C03/"/>
    <url>/2021/08/11/C03/</url>
    
    <content type="html"><![CDATA[<h1 id="调试和多文件编程"><a href="#调试和多文件编程" class="headerlink" title="调试和多文件编程"></a>调试和多文件编程</h1><p>&amp;ensp;&amp;ensp;随着我们学习的东西越来越多，编写的程序也会越来越复杂，尤其是函数使用之后，很多时候光靠我们自己去发现bug闲的很是吃力，或者自己的想法有出入，导致代码本身就有缺陷，这种时候我们就需要调试这个工具来帮助我们测试这个代码的运行状态，帮助我们判断代码的运行情况。<br>&amp;ensp;&amp;ensp;调试就是一点一点的执行程序，而不是像以前一样一下跑完，它中间会停住，我们可以查看一些变量的信息，看一下程序的状态是否正确，或者是否有逻辑的漏洞。<br>&amp;ensp;&amp;ensp;下面介绍一下Dev c++和VS2019的调试方法。</p><ul><li>Dev c++：</li></ul><p>&amp;ensp;&amp;ensp;首先，我们要打开调试的选项：<br>&amp;ensp;&amp;ensp;在上面的工具里，打开编译选项<br><img src="https://img-blog.csdnimg.cn/70ea43fb76004aa7807246a4d03ee3f5.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;点击代码生成，再点连接器，更改设置如下<br><img src="https://img-blog.csdnimg.cn/407f5517ac224caabd37605e1cda1d67.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;OK了，我们可以开始调试了。</p><p>&amp;ensp;&amp;ensp;首先，为了阻止程序一溜烟跑完了，我们还啥也没看呢，我们要先设置断点，断点就是程序执行到这里就会中断，会停止的意思。我这里使用前面函数的例子的第一版代码，这个是有bug的，正好来学习调试。<br>&amp;ensp;&amp;ensp;当然，调试前提是程序语法没有问题，是逻辑或者程序的漏洞，如果编译器都报错了，还是要赶紧改。<br>&amp;ensp;&amp;ensp;代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;math.h&gt;</span></span><br><br><span class="hljs-type">double</span> <span class="hljs-title function_">Str2Num</span><span class="hljs-params">(<span class="hljs-type">char</span> str[], <span class="hljs-type">int</span> len)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> a[] = <span class="hljs-string">&quot;123456&quot;</span>;<br><span class="hljs-type">int</span> num = <span class="hljs-keyword">sizeof</span>(a) / <span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span>;<br><span class="hljs-type">double</span> res = Str2Num(a, num);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf&quot;</span>, res);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-type">double</span> <span class="hljs-title function_">Str2Num</span><span class="hljs-params">(<span class="hljs-type">char</span> str[], <span class="hljs-type">int</span> len)</span><br>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-type">double</span> result = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br>result += str[i] * <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, len - i);<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;编译是过了的：<br><img src="https://img-blog.csdnimg.cn/b818e6994fe741258c8dbaf7ef4e9f9a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;断点怎么设置：<br>&amp;ensp;&amp;ensp;把鼠标移到这里：<br><img src="https://img-blog.csdnimg.cn/604ce5a05b674e27aedbfb09b882a97a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;就是行号和代码中间的灰长条区域，移动到你想暂停的地方的所在行上，点一下，这一行就变绿了（当然颜色可能不一样，设置里可以改），同时前面出现一个红点，就是断点，再点一下，恢复正常，断点没了。<br><img src="https://img-blog.csdnimg.cn/dc6ec6f0e4e542179d140831d42e476a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;断点一般设置在可能出问题的代码前面一点，这样程序停下来的时候就能清楚执行这行代码前是什么状态，是怎么执行的。<br>&amp;ensp;&amp;ensp;比如我想看函数是怎么执行的，我就把断点加在函数的使用的前面，比如加在int num &#x3D; sizeof(a) &#x2F; sizeof(a[0]) - 1;这行上。<br>&amp;ensp;&amp;ensp;设置好断点后，我们点击调试按钮（第一章讲的啦。）<br><img src="https://img-blog.csdnimg.cn/cc8edb3147674ffdabbf29989b44fe44.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;OK，我们已经进入调试状态了<br><img src="https://img-blog.csdnimg.cn/2b93994920314ea1b51af1608f41d626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;蓝色代表程序正要执行的行（还没执行呢）可以看到它现在正好停在了断点处。<br>&amp;ensp;&amp;ensp;下面原本显示编译信息的地方编程了显示调试信息的地方了<br>&amp;ensp;&amp;ensp;调试就是我们想让程序怎么跑，程序就得怎么跑<br>&amp;ensp;&amp;ensp;具体怎么做呢，我们来介绍一下这些按键的操作：<br>&amp;ensp;&amp;ensp;从第一行开始说起，首先是调试，这个不用了，我们已经在调试了。<br>&amp;ensp;&amp;ensp;<strong>添加查看</strong>：我们可以查看想看的变量，比如我们想看num这个变量的值，我们点击，输入num<br><img src="https://img-blog.csdnimg.cn/3778bcb5c4cc45b1a685366f9b8e372e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;OK，现在我们能在代码左侧那一大块空白区域看到num的当前值了<br><img src="https://img-blog.csdnimg.cn/cfbc9d03f11e456b98a1698c6115b885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;当然，更方便的方法：鼠标放在哪个地方，就能显示哪个地方的值（这里不好截图）<br>&amp;ensp;&amp;ensp;OK了，鼠标晃一晃，左边几乎就都有了。<br>&amp;ensp;&amp;ensp;大家会看到，这里i说没有找到，为什么，<strong>其实这就是生存周期的体现，i只在函数中有效，我们程序现在在main函数中，自然没有i。</strong><br>&amp;ensp;&amp;ensp;<strong>下一步</strong>：我们点击一下，程序就向下执行一行。<br>&amp;ensp;&amp;ensp;我们点一下，会发现num的值变为6了，说明刚刚停留的行被执行了，程序停在了下一行。<br>&amp;ensp;&amp;ensp;下一行我们调用了函数，但我们点击下一步就走到printf那一行了，没有进入函数。<br>&amp;ensp;&amp;ensp;如果我们想看程序是怎么跳转的，我们需要点<strong>单步进入</strong>，单步进入就是程序怎么执行的，它就怎么走，不会说明明执行了函数不给你看的情况。<br>&amp;ensp;&amp;ensp;<strong>跳过函数</strong>：当我们单步进入函数中后，我们不想看这个函数的具体执行过程，就可以点击跳过函数，程序会自动执行函数内容后返回主程序。<br>&amp;ensp;&amp;ensp;<strong>跳过</strong>：程序一直执行直到碰到断点，比如我们设置两个断点：<br><img src="https://img-blog.csdnimg.cn/d805d31bb9a9483b85c001aad6417c62.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;调试，程序会在前面的断点停下来，这时我们如果点击跳过，程序会像往常那样自己就跑了，知道它在函数中碰到了第二个断点才停下来：<br><img src="https://img-blog.csdnimg.cn/0ad69e8307f549ce95d7027e346e73fa.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;这个东西还挺有用的，对于<strong>快速跳出多次循环</strong>，我们可以在循环结束后放一个断点，直接跳，程序就把循环跑完了，也能停下来。<br>&amp;ensp;&amp;ensp;<strong>停止执行</strong>：中止调试。<br>&amp;ensp;&amp;ensp;OK，常用的说完了，剩下的几个除非很奇怪的bug或者程序优化什么的时候会看，其他的时候根本不会用的，但我还是要说φ(゜▽゜*)♪<br>&amp;ensp;&amp;ensp;<strong>查看cpu窗口</strong>：我们点一下，会出来这个窗口：<br><img src="https://img-blog.csdnimg.cn/7e35c4f2382b478a9cd5be2976ca91fc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;我们前面说过，编译器就是翻译官，<strong>这些就是它翻译出来的代码，是更为底层的汇编代码，是用汇编语言写的</strong>，&#x3D;&gt;表示当前所在的汇编代码中的行，这个翻译不是一句变一句，有时候是一句变多句，看代码功能而区分。我也知识粗略的学过一点汇编，看这种代码也是看的半生不熟的，不过还是认得一些，知道它们是干什么的。大家看这个：<br><img src="https://img-blog.csdnimg.cn/aebba70caa904df3b2ecc8ecbfdca225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;是不是很眼熟，这不是我们的函数吗，这里的callq是一个过程调用，汇编里的过程和我们的函数其实差不多，前面一堆0x什么的，是一个地址，这个地址是函数的入口地址，大家看这里：<br><img src="https://img-blog.csdnimg.cn/6c88b00932364f9785b4c01e356336bd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;你会发现这个函数名后面跟着的和汇编调用的是一个地方，其实就是函数的指针（<strong>指针又出来了，我已经不知道第几次提它了，只能说指针真是C语言的灵魂，别的语言都没有如此强调指针这个概念，但当你理解了指针是什么，你对整个程序是怎么跑的，汇编语言是怎么调用的，IP是怎么跳的，清楚的一批。（ps：IP里放的就是和指针差不多的）</strong>）<br>&amp;ensp;&amp;ensp;大家还会发现，前面还有一个main函数的call指令，说明main函数也是函数，那么是谁调用的呢，答案是操作系统，如果在命令行窗口中调用我们这个程序，你就会清楚的知道这个程序是怎么被调用的了（可是我不会命令行……）。<br>&amp;ensp;&amp;ensp;说多了，下一个。<br>&amp;ensp;&amp;ensp;<strong>下一条语句</strong>：就是汇编语句的下一条，同样的，call指令也不会跳走，而是直接执行完了，永远执行相邻地址的下一条。<br>&amp;ensp;&amp;ensp;<strong>进入语句</strong>：汇编语句会跳的那种。<br>&amp;ensp;&amp;ensp;行了，调试的基本的东西都已经讲完了。</p><ul><li>VS2019调试：</li></ul><p>&amp;ensp;&amp;ensp;从接触VS，大家就已经是专业的工具人了，可以写自己的项目了。<br>&amp;ensp;&amp;ensp;现在很多程序都是用VS这个IDE，我们最后也还是要用这个的，但是Dev c++比较友好，适合新手，所以开始的时候都是用那个（现在开始讲VS说明大家已经不是新手啦！）。<br>&amp;ensp;&amp;ensp;打开VS（怎么下的就靠各位大神了）<br><img src="https://img-blog.csdnimg.cn/1c29d50e6b9a41d89c8b51f941248ab8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="（请无视我最近在学的py……）"></p><p>&amp;ensp;&amp;ensp;我们创建新项目：<br><img src="https://img-blog.csdnimg.cn/cf6a7b07df7144d39327a58825af0ad4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;选择C++空项目（C++和C差不多），创建，选择名称和存放路径就OK了。<br>&amp;ensp;&amp;ensp;现在直接写C的代码还是会有点问题，毕竟是专门写C++的代码的<br><img src="https://img-blog.csdnimg.cn/0ece3763d0994b45a14878471ff7dc4e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;点击项目-最下面的那个属性（快捷键p）<br>&amp;ensp;&amp;ensp;找到这里：<br><img src="https://img-blog.csdnimg.cn/a1aaa73c80b54cfeb7888f26cd9c11c9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;把SDL改为否，应用确定，ok了。<br>&amp;ensp;&amp;ensp;当然现在你还是什么都写不了，因为你只是新建了一个工程，这个工程是空的，要添加东西进去（这就是VS的复杂了，操作多）<br><img src="https://img-blog.csdnimg.cn/073cdf6ca6364f99912d1622933c0af1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;点击解决方案资源管理器，在源文件的文件夹右键添加新建项（原本应该是空的，我这里有之前添加好的文件一个）<br><img src="https://img-blog.csdnimg.cn/39fbcdbb1b7149a684e2ddb283494268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;<strong>把名字改为.c的后缀，.cpp是c++的后缀</strong><br>&amp;ensp;&amp;ensp;添加好了之后，就能敲代码了。<br><img src="https://img-blog.csdnimg.cn/d501893b8f624aa6b2d57b07669b97fc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;看起来也更好看了，不是吗？<br>&amp;ensp;&amp;ensp;断点还是一样的，点一下有，点两下无<br><img src="https://img-blog.csdnimg.cn/ce3a45e23339420e9a82fd0bee56293a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;加好之后直接运行（原本正常执行程序也是点这个）<br><img src="https://img-blog.csdnimg.cn/70dc394777cc4196b49e70eb283021d4.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;程序会在断点处停下来<br><img src="https://img-blog.csdnimg.cn/9564ea75f06b4bb699c10ff5aefab1c9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;大家不要看这么多窗口，什么进程内存都出来，不要慌，很多都用不上。<br>&amp;ensp;&amp;ensp;首先，鼠标移到变量上看当前值的操作还是有的。<br>&amp;ensp;&amp;ensp;我们想看值的话，可以在监视1的窗口里显示。<br>&amp;ensp;&amp;ensp;添加一个num，回车就OK了<br><img src="https://img-blog.csdnimg.cn/5b1ca645a223470c871ffdaaf4afae59.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;这里因为在函数里，所以num不在生存周期，就没了，这个i为什么是这么个奇怪的值，因为我们只是定义了i，没有给初值，所以i的初值不好确定，它现在就是这么个值了，当然，箭头指向的是还没执行要指向的行，这个for循环的执行过程是什么？（复习了复习了！）——先执行第一个部分【for（一；二；三）】，这里就给i赋值了。<br>然后看这里<br><img src="https://img-blog.csdnimg.cn/308d4bd02fe04de59a05761b960bab6a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;调试主要是这三个：从左到右介绍<br>&amp;ensp;&amp;ensp;<strong>逐语句</strong>：相当于单步进入，碰到函数会进函数。<br>&amp;ensp;&amp;ensp;<strong>逐过程</strong>：相当于下一步，不进函数。<br>&amp;ensp;&amp;ensp;<strong>跳出</strong>：跳出函数<br>&amp;ensp;&amp;ensp;那个红色的方框按钮就是中止调试。<br>&amp;ensp;&amp;ensp;没了，VS调试主要就这几个，剩下的咱也不会用。</p><h1 id="多文件编程"><a href="#多文件编程" class="headerlink" title="多文件编程"></a>多文件编程</h1><p>&amp;ensp;&amp;ensp;现在，我们向大工程文件又近了一步。<br>&amp;ensp;&amp;ensp;我们首先了解预处理。<br>&amp;ensp;&amp;ensp;预处理就是在编译器编译源程序之前做的准备工作，比如翻看头文件。<br>&amp;ensp;&amp;ensp;预处理的指令都是以#开头的，并且它们不是语句，<strong>结尾没有；</strong><br>&amp;ensp;&amp;ensp;预处理的指令主要有下面几种：</p><table><thead><tr><th align="center">#include</th><th>包含头文件</th></tr></thead><tbody><tr><td align="center">#define</td><td>宏定义（#define PI 3.14159）讲PI这个字符串与3.14159挂钩，编译器见到PI，就用3.14159替换，注意是<strong>直接替换，有时可能会产生运算顺序的错误</strong></td></tr><tr><td align="center">#undef</td><td>取消宏定义</td></tr><tr><td align="center">#if</td><td>如果给定条件为真，则编译下面代码</td></tr><tr><td align="center">#ifdef</td><td>如果已经有宏定义，则编译下面代码</td></tr><tr><td align="center">#ifndef</td><td>如果没有宏定义，则编译下面代码</td></tr><tr><td align="center">#elif</td><td>相当于elseif，如果#if条件为假，就看这个判断</td></tr><tr><td align="center">#endif</td><td>#if……#else条件编译块的结束</td></tr><tr><td align="center">#error</td><td>停止编译，显示错误信息</td></tr></tbody></table><p>&amp;ensp;&amp;ensp;对于头文件的包含，我们可以有这两种形式：<br>#include&lt;stdio.h&gt;<br>#include”stdio.h”<br>&amp;ensp;&amp;ensp;两种都是可以的，差别在编译器找头文件所在地的时候的顺序不同，一般的，我们包含原本提供的头文件的时候使用&lt;&gt;，包含自己的头文件的时候使用“”。<br>&amp;ensp;&amp;ensp;我们使用VS来做例子，因为以后的大工程文件大多都用VS来写的。<br>&amp;ensp;&amp;ensp;打开上次的项目，多文件编程肯定是要多个文件的，所以我们再创建一个.c的文件在源文件下面。<br>&amp;ensp;&amp;ensp;我们将在这个新建的文件夹下面编写我们自己的函数库。<br>&amp;ensp;&amp;ensp;首先，我们把上次写好的字符串转数字的函数搬过来。<br>&amp;ensp;&amp;ensp;再把我们之前写的任意整数次幂封装成函数整过来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-type">double</span> <span class="hljs-title function_">Str2Num</span><span class="hljs-params">(<span class="hljs-type">char</span> str[], <span class="hljs-type">int</span> len)</span><br>&#123;<br><span class="hljs-type">int</span> i, j = len;<br><span class="hljs-type">char</span> isNegative;<br><span class="hljs-type">double</span> result = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;.&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (j != len)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR\a\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>j = i;<br>&#125;<br><br><span class="hljs-keyword">if</span> ((str[i] &lt; <span class="hljs-number">48</span> || str[i]&gt;<span class="hljs-number">57</span>) &amp;&amp; str[i] != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp;str[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp;str[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;+&#x27;</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\a\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (str[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>)<br>&#123;<br>i = <span class="hljs-number">1</span>;<br>isNegative = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;+&#x27;</span>)<br>&#123;<br>i = <span class="hljs-number">1</span>;<br>isNegative = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>i = <span class="hljs-number">0</span>;<br>isNegative = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (; i &lt; len; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (i &lt; j)<br>&#123;<br>result += (str[i] - <span class="hljs-number">0x30</span>) * <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, j - i - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (i &gt; j)<br>&#123;<br>result += (str[i] - <span class="hljs-number">0x30</span>) * <span class="hljs-built_in">pow</span>(<span class="hljs-number">0.1</span>, i - j);<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">if</span> (isNegative)<br>&#123;<br>result = -result;<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">JieCheng</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (a = n; a &gt; <span class="hljs-number">0</span>; a--)<br>&#123;<br>result *= a;<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-type">double</span> <span class="hljs-title function_">Power</span><span class="hljs-params">(<span class="hljs-type">double</span> di,<span class="hljs-type">int</span> zhi)</span><br>&#123;<br><span class="hljs-type">double</span> ans = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> i;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; zhi; i++)<br>&#123;<br>ans *= di;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf&quot;</span>, ans);<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;好了，我们现在有3个自己的函数了。<br>    &amp;ensp;&amp;ensp;对于自己的函数，光有定义不行，我们还需要一个头文件把我们写的函数的声明整合起来，这样到时候只要包含头文件就能使用我们的函数了。<br>    &amp;ensp;&amp;ensp;在头文件夹下面新建一个和你放函数的.c文件一样文件名的.h文件（头文件）<br><img src="https://img-blog.csdnimg.cn/3122ff3620e84d8dafee50fdd780b6ea.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;建好之后是这样的<br><img src="https://img-blog.csdnimg.cn/133b36d3e7a94090a0209a183667790f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;#pragma once是防止头文件被重复包含的，我们保留就行了。<br>&amp;ensp;&amp;ensp;我们把刚写的函数的声明写进去</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-type">double</span> <span class="hljs-title function_">Str2Num</span><span class="hljs-params">(<span class="hljs-type">char</span> str[], <span class="hljs-type">int</span> len)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">JieCheng</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">Power</span><span class="hljs-params">(<span class="hljs-type">double</span> di, <span class="hljs-type">int</span> zhi)</span>;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;保存，好了，我们自己的头文件创建OK<br>&amp;ensp;&amp;ensp;接下来我们在第一个.c文件中包含我们的.h头文件，并调用里面的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;second.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> a[] = <span class="hljs-string">&quot;+123456.06659&quot;</span>;<br><span class="hljs-type">int</span> num = <span class="hljs-keyword">sizeof</span>(a) / <span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span>;<br><span class="hljs-type">double</span> res = Str2Num(a, num);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s to %lf\n&quot;</span>,a, res);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d!=%d\n&quot;</span>, <span class="hljs-number">5</span>, JieCheng(<span class="hljs-number">5</span>));<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf^%d = %lf&quot;</span> ,<span class="hljs-number">2.5</span>, <span class="hljs-number">3</span>, Power(<span class="hljs-number">2.5</span>, <span class="hljs-number">3</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;可以成功执行：<br><img src="https://img-blog.csdnimg.cn/23d003cf6d6c4cf1a75d56f89d13cff1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;好了，最简单的分文件编程就OK了，后面会有更复杂的，更多种类的自定义的函数的头文件的使用，更多类型的变量的跨文件使用。<br>&amp;ensp;&amp;ensp;<strong>我们下一章再见！</strong></p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">]]></content>
    
    
    <categories>
      
      <category>知识总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识总结</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言总结项目和入门——函数</title>
    <link href="/2021/08/09/C02/"/>
    <url>/2021/08/09/C02/</url>
    
    <content type="html"><![CDATA[<p>&amp;ensp;&amp;ensp;老样子，废话不说。</p><h1 id="四、C语言入门——函数"><a href="#四、C语言入门——函数" class="headerlink" title="四、C语言入门——函数"></a>四、C语言入门——函数</h1><p>&amp;ensp;&amp;ensp;首先，我们为什么需要函数。<br>&amp;ensp;&amp;ensp;在数学上，函数是一种映射关系，表示一个数集向另一个数集映射的对应法则。简单来说，就是<strong>给一个数，得到另一个数</strong>。Sin（x）是一个函数，因为给一个x，可以得到一个值y。编程中的函数和上面讲的有异曲同工。<br>&amp;ensp;&amp;ensp;<strong>函数实现的是封装和模块化设计。</strong><br>&amp;ensp;&amp;ensp;这是什么意思？<br><img src="https://img-blog.csdnimg.cn/e34047a93e994f44a910d1dae2cdcf04.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;这是sin（x）的泰勒展开式，理论上来说，对于无穷多项上面等式是恒等的。我们反过来理解，即求这些幂级数的和，当我们要求比如x&#x3D;1.5时上面幂级数的和的时候，我们需要算无穷多项。而且每次改变x的值，我们都要算这么多。这样的运算必然是繁琐而复杂的，所以我们使用了sin这个函数，来代替这些幂级数的和，用简短的东西代替复杂的东西，这就是封装的一种体现。当我们希望得到x&#x3D;1.5时候上面的和，我们就用sin（1.5）来表示，这个函数会给我们一个值，我们叫<strong>返回值</strong>，这个值就是右端幂级数在x&#x3D;1.5处的和。<strong>我们就把一个复杂的计算变成一个简单的函数调用</strong>。当然，我们很多时候或许根本不知道计算机是怎么算sin（1.5）的，这也是由于<strong>函数的封装性导致它内部的实现是隐藏的</strong>（封装嘛，都封起来了）。<br>&amp;ensp;&amp;ensp;什么是模块化设计。<br>&amp;ensp;&amp;ensp;大家拼乐高，零件的种类是不是很多，而最终千奇百态的作品，它们用到的零件可能是相同的，因为这些零件很多是通用的。对编程来说，<strong>函数就是零件</strong>，我们通常将函数封装成能实现一种特定的功能的形态，如实现大小写转换strlwr（a），strupr（a），实现数组的排序，实现文字打印（printf），我们自己的程序就是构建在这样的函数上的，自底向上的设计。<br>&amp;ensp;&amp;ensp;知道函数是干什么的，我们来开始吧。</p><ul><li><p>函数的定义：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> A（参数列表）<br>&#123;<br>函数体；<br><span class="hljs-keyword">return</span>返回语句；<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;Int 表示这个函数返回值的类型，前面我们说了，函数就是给一个值，得到另一个值（当然并不是所有函数都是这样。）得到的这个值就是函数的返回值，这个值也是变量，是有类型的，这个类型由函数定义时说明。当然这里是举例，表示返回整型，返回double当然也是可以的。<br>&amp;ensp;&amp;ensp;A - 函数名，这个函数叫什么，我们在调用函数的时候会用到。<br>&amp;ensp;&amp;ensp;参数列表:这个函数需要的参数，就像sin需要x才能计算一样，当然有的函数需要两个以上的参数，所以这里是一个列表，有的函数不用参数就能自己跑，就不写。<br>&amp;ensp;&amp;ensp;注：参数需要是完整的，包括参数的类型和名称，和我们声明一个变量时候要求的一样。<br>&amp;ensp;&amp;ensp;如（int a，double b）这个参数列表，表明这个函数需要一个整型的参数，和一个双精度浮点型的参数，这里的a，b是函数里用的，不是说要传变量a和b进来才行，传进来的参数对于函数来说就是已知的了，和变量类似，对函数来说可以直接使用。<br>&amp;ensp;&amp;ensp;return返回语句：return K；其中K是一个数据类型，这句话是这个函数运行的结果。函数总是从return语句退出，void类型可以没有return，则执行完函数最后一行语句后退出。<br>  &amp;ensp;&amp;ensp;对于一些特殊类型的函数，没有运行结果，我们用void的类型来定义，如void A（）；<br>是一个没有返回值，没有参数的函数A的声明。注意，如果函数不是void的，即是有返回值的，那么return语句是一定要有的。反之如果A是void，也可以有return语句，只不过这里return没有参数，只是起到退出函数的作用，如return；<br>  举个例子：</p><p>  int max(int a,int b)<br>  {<br>  return a&gt;b?a:b;<br>  }</p></li></ul><p>&amp;ensp;&amp;ensp;这是一个找最大的函数，采用三目运算符的结果做返回值。这里a，b我们都是当已知的变量来使用的，并没有再定义什么的，就是因为它们是函数的参数，在函数调用的时候会有确定的值传进来。</p><ul><li>函数的调用</li></ul><p>&amp;ensp;&amp;ensp;很简单：函数名（参数）；<br>&amp;ensp;&amp;ensp;如上面的max（5，10）；就实现了对max函数的调用，并传入了参数5和10，注意：<strong>传入的应该和函数定义时候的类型一致</strong>，函数要int类型，传参的时候就只能传int类型的数，否则会报错。<br>&amp;ensp;&amp;ensp;不过max（5，10）这样并没有什么效果，因为函数的返回值如果没有存下来的话，就消失了，相当于白干，所以我们需要一个变量来接受函数的返回值，如c &#x3D; max（5，10），其中c是变量。这样我们就把5，10中的大着赋给了c，c现在等于10。</p><ul><li>形参与实参</li></ul><p>&amp;ensp;&amp;ensp;函数里的接受的参数的值，和我们传过去的值有什么关系。<br>&amp;ensp;&amp;ensp;如max（x1，x2），这里x1，x2是之前定义和使用过的变量，现在我们需要知道它们的大者，于是我们调用max函数，max接收到我们传给它的两个参数x1，x2，通过比较返回他们的大者，不过我们现在还没有接受这个值。<br>&amp;ensp;&amp;ensp;我们知道在max函数中，我们是对a，b这两个参数进行操作的，当我们传入x1，x2的时候，max就按位置对应将<strong>值赋给</strong>了a，b，即a&#x3D;x1，b&#x3D;x2。注意，这里是赋值给，这说明a，b和x1，x2没有直接的关系，它们只是x1，x2的副本，同样的，在函数中对a，b的值的变化也不会反映到x1，x2上（实际上，此时x1，x2不存在（作用域不同））。<strong>这里我们把a，b叫做形式参数（形参），把传入的值x1，x2叫做实际参数（实参），实参和形参是没有直接挂钩的关系的，它们只是值一样，除此之外毫不相干。</strong></p><p>&amp;ensp;&amp;ensp;我们总结一下函数的要点：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">函数的定义：</span><br><span class="language-xml">函数类型 函数名（参数）</span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">函数体；</span><br><span class="hljs-template-variable">返回值；</span><br><span class="hljs-template-variable">&#125;</span><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;函数类型是指这个函数的返回值的类型，即这个函数的运算结果，如果函数没有返回值，用void类型定义，可以没有返回语句。<br>&amp;ensp;&amp;ensp;函数名是这个函数的名称，我们调用函数时就是通过这个函数名调用的。<br>&amp;ensp;&amp;ensp;参数列表：即形參列表，函数实现功能需要提供的参数。这里的形參需要是完整的，即变量类型和变量名都要有，和变量定义时需要的是一样的，在调用函数时将实參传给形參，函数是对形參的直接运算，<strong>与实參无关。</strong><br>&amp;ensp;&amp;ensp;返回值是这个函数的运算结果，通过return语句返回，return A，其中A为函数中的变量（在函数中定义的或者函数的形參）。对于不需要返回值的函数，即void类型的函数可以没有return语句。注意：return语句和break的作用有类似之处，函数一旦执行到return语句就直接跳出函数，同时返回return的值，而不管后面还有没有。<br>&amp;ensp;&amp;ensp;函数的调用：函数名（参数）；对于有返回值的函数，需要一个相对应的变量来接受，即函数的调用可以当右值（具体是函数的返回值当了右值）。</p><p>&amp;ensp;&amp;ensp;好了，我们已经把函数的定义和调用都介绍了，接下来如何正确的在程序中使用呢？<br>&amp;ensp;&amp;ensp;首先函数的定义要写在哪里？<br>&amp;ensp;&amp;ensp;我们观察前面的提及的框架<br>int main（）<br>{<br>&amp;ensp;&amp;ensp;……<br>&amp;ensp;&amp;ensp;return 0；<br>}<br>&amp;ensp;&amp;ensp;我们不难发现这是一个函数，我们叫main函数，int类型，返回0，main函数其实是有参数的，这里我们先不提及。C语言关于函数有个要求：<strong>函数不能嵌套定义</strong>，即函数里不能再定义函数，所以我们的函数定义当然不能写在main函数里，要写在main外面。<br>&amp;ensp;&amp;ensp;按道理来说，只要写外面，写在main上面还是写下面都是可以的，但这里涉及一个程序执行的问题。<br>&amp;ensp;&amp;ensp;我们之前说程序是从main函数里的第一条开始执行的，实际上编译器会从头开始看一下我们提供了什么，或者要求了什么，比如我们提供了头文件（说明书），编译器从上往下看的时候，就知道我们提供了这个说明书，他碰到函数的时候就可以来这个说明书里找。这些东西我称之为预备操作，真正有执行力还是要看main函数。这里问题来了，我们把函数的定义写在后面，然后在主函数（main函数）里调用，由于编译器是顺序看的，他必然是先看到main函数并进去执行，然后才能看到函数的定义，然而他看到main函数里的函数调用的时候就懵了，因为他前面没见过，找也找不到，其实在后面都有，但编译器此时就认为这个函数没有定义，他不认得，直接报错，根本就不看后面（这就是不好好读上下文的结果。）当然对于这个问题，我们把函数定义写在main函数之前就OK，但我就是想写后面，怎么办？更多时候我们希望把函数的定义写在后面，这样每次进来都能直接看到主函数。<br>&amp;ensp;&amp;ensp;解决方法就是在main函数前面对这个函数进行声明，告诉编译器有这个函数，以及这个函数的一些信息供编译器查看。具体怎么个声明法？很简单，函数的定义第一行不是这样的吗：函数类型 函数名（参数），把这行复制，粘到main函数前面去，由于C语言语句的要求，要以分号结束，所以我们再加个分号，即<br>&amp;ensp;&amp;ensp;函数类型 函数名（参数）；<br>&amp;ensp;&amp;ensp;这就是函数的声明，它包括了函数的名字，参数，返回值类型，供编译器查看。<br>&amp;ensp;&amp;ensp;更简单的，<strong>声明的时候可参数列表可以不用写参数名称，只写参数类型</strong>，如（int，int，float）这个参数列表告诉编译器这个函数需要整形、整形、浮点型的参数，而对参数名叫什么，编译器不关心，是靠函数实现来规定的。<br>&amp;ensp;&amp;ensp;现在我们终于可以来说说<strong>头文件</strong>（说明书）的事了，头文件就是一堆函数的声明，通常以.h文件的形式出现，头文件一般是一些常用的函数的声明集合，我们可以通过包含头文件的操作，来使用里面声明的函数，当然我们也可以编写自己的头文件，包含我们自己的函数，这个点我们以后再说。<br>&amp;ensp;&amp;ensp;函数虽然不能嵌套定义，但可以嵌套调用，即在A函数中调用B函数，实际上，我们不就是在main函数中调用自己的函数的吗。需要注意的是，要保证编译器在检查翻译A函数的时候看见B函数，要认得——即要有B的声明或定义在前面。</p><ul><li>函数的递归调用</li></ul><p>&amp;ensp;&amp;ensp;小甲鱼有话说：普通人理解迭代，神理解递归。递归编起来很让人头疼，我自己也不怎么会，不过递归可以以简单的程序实现复杂的操作，当然，它的花销也是很大的，对内存的占用也很严重。<br>&amp;ensp;&amp;ensp;递归调用，就是自己调用自己，知道达到某个想要的目的（找到某个东西，或者算出某个值），然后一层一层的返回，最后返回main函数中。</p><p>&amp;ensp;&amp;ensp;如我们求n的阶乘<br>&amp;ensp;&amp;ensp;-普通函数：迭代</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int JieCheng(int n)<br>&#123;<br>int a<span class="hljs-comment">;</span><br>int result <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>for(a <span class="hljs-operator">=</span> n<span class="hljs-comment">;a&gt;0;a--)</span><br>&#123;<br>result *<span class="hljs-operator">=</span> a<span class="hljs-comment">;</span><br>&#125;<br>return result<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;我们知道n的阶乘就是从n乘到1，我们用for循环来实现。<br>&amp;ensp;&amp;ensp;-递归函数：<br>&amp;ensp;&amp;ensp;首先我们要知道阶乘的递归定义：<br><img src="https://img-blog.csdnimg.cn/d34f83d346744b4db7b47a67b54d2389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> <span class="hljs-constructor">JieCheng(<span class="hljs-params">int</span> <span class="hljs-params">n</span>)</span><br>&#123;<br><span class="hljs-built_in">int</span> f;<br><span class="hljs-keyword">if</span>(f<span class="hljs-operator"> == </span><span class="hljs-number">0</span><span class="hljs-operator"> || </span>f<span class="hljs-operator"> == </span><span class="hljs-number">1</span>)<br>&#123;<br>return <span class="hljs-number">1</span>; <span class="hljs-comment">//0和1的阶乘是1;</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>f = n*<span class="hljs-constructor">JieCheng(<span class="hljs-params">n</span>-1)</span>;<br>&#125;<br>return f;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;当f&gt;1时，会将f-1再带入阶乘函数，一直到f &#x3D; 1；然后依次返回相乘。</p><p>&amp;ensp;&amp;ensp;这还是递归的简单的用法，更为具体的可以参考汉诺塔的递归实现。</p><p>&amp;ensp;&amp;ensp;<br>&amp;ensp;&amp;ensp;–下面我们对函数参数为数组时特殊讲述。<br>&amp;ensp;&amp;ensp;数组元素作为普通变量当函数参数很正常，如fun（k[2]）；表示k数组的第3个元素传给fun函数当实参，这个很普通，和平常传参没有本质区别。<br>&amp;ensp;&amp;ensp;但数组名也可以做参数，如fun（k）；把k传给fun，这是什么意思？<br>&amp;ensp;&amp;ensp;我们首先来看一下参数为数组的函数的定义（以int类型为例）：<br>int fun（int a[10]）<br>{</p><p>}<br>&amp;ensp;&amp;ensp;这样写很好理解，就是把a这个数组整体当参数给了fun，fun可以调用a中的任何元素。但实际上，定义中的a[10]规定这是10个元素的数组没有用，因为编译器不看，int fun（int a[10]）和int fun（int a[ ]）是一样的，因为大小不是编译器所关心的，因为这个特性，<strong>我们通常还需要传入数组的大小参数，防止访问越界</strong>。<br>&amp;ensp;&amp;ensp;上面的函数定义可以写成：<br>int fun（int a[ ]，int n）&#x2F;&#x2F;n为a的长度<br>{</p><p>}<br>&amp;ensp;&amp;ensp;在函数中使用a的元素就很简单了，和普通数组一样，数组名a加下标访问，如a[2]；<br>&amp;ensp;&amp;ensp;注意不要超出n的范围。<br>&amp;ensp;&amp;ensp;调用函数的时候，需要数组参数的地方我们传入数组名就OK，如上面定义的函数，调用fun（M，6）；表示传入一个长度为6的整型数组M。<br>&amp;ensp;&amp;ensp;实际上，传入数组名就是传入数组的首地址，函数定义的时候也是需要一个数组的首地址，但我们只知道首地址是不行的，还要知道这个数组在哪里结束，所以元素个数（数组长度）就必不可少了。（这里设计指针的知识，会在下章再提及的。）<br>&amp;ensp;&amp;ensp;二维数组当参数：前面我们已经知道，二位数组定义的时候可以省略第一维的参数，但不能省略第二维，同样的函数定义时也是如此：int fun（int a[ ][ 4 ]）表示这个函数需要一个二维数组，第二维是4</p><h1 id="代码训练与详解：字符-gt-数字"><a href="#代码训练与详解：字符-gt-数字" class="headerlink" title="代码训练与详解：字符-&gt;数字"></a>代码训练与详解：字符-&gt;数字</h1><p><strong>例1.字符串转变数字的函数：</strong><br>&amp;ensp;&amp;ensp;当我们输入一串123456的字符时，我们希望得到123456这个数。<br>&amp;ensp;&amp;ensp;首先我们知道这个函数需要一个字符串的参数，在C中我们使用字符串数组来实现，同时它返回一个数字，我们这里用double的类型。<br>&amp;ensp;&amp;ensp;思路比较粗暴，对每一位的数字乘位权相加。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;math.h&gt;</span></span><br><br><span class="hljs-type">double</span> <span class="hljs-title function_">Str2Num</span><span class="hljs-params">(<span class="hljs-type">char</span> str[],<span class="hljs-type">int</span> len)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> a[] = <span class="hljs-string">&quot;129999&quot;</span>;<br><span class="hljs-type">int</span> num = <span class="hljs-keyword">sizeof</span>(a)/<span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>])<span class="hljs-number">-1</span>;<br><span class="hljs-type">double</span> res = Str2Num(a,num);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.0lf&quot;</span>,res);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-type">double</span> <span class="hljs-title function_">Str2Num</span><span class="hljs-params">(<span class="hljs-type">char</span> str[],<span class="hljs-type">int</span> len)</span><br>&#123;<br><span class="hljs-type">int</span> i; <br><span class="hljs-type">double</span> result=<span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;len;i++)<br>&#123;<br>result += (str[i]<span class="hljs-number">-0x30</span>)*<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,len-i<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;传入数组的时候我们最后也附带上它的长度，这样方便操作。这个长度怎么求呢？由前面的知识，sizeof可以求出来一个变量占的空间大小，数组也是变量，<strong>sizeof（数组名）可以求出这个数组所占的总体大小，再除以数组一个元素的大小（任意一个都行，因为它们的类型是一样的），就可以得到元素个数了，但由于这是字符串，末尾会有一个字符的结束标志‘\0’，所以我们再减去一个元素。就OK了。</strong><br>&amp;ensp;&amp;ensp;对于头文件math.h里面包含了很多数学函数，像sin，cos什么的，当然还有我们使用的pow乘幂函数，这些都只有包含math.h的头文件才能用的，<br>&amp;ensp;&amp;ensp;在函数中，我们按上面的操作就可以进行转换了，需要注意的是，由于str都是字符，是按ascii码存储的，如字符‘0’，在ascii中是以十进制48存储的，即对于char类型的0，其对应存储的整型十进制数字是48，对应的十六进制是30H，我们减去30H，即0x30，就能得到对应的数字了，再乘位权，再循环加，就大功告成了。<br>&amp;ensp;&amp;ensp;大家会发现这个函数不能转换负数，对于小数也不能转换，在此基础上，我们来完善，<strong>所有的东西写出来都不是一开始就是完美的，先把基础的东西写好，再补充，就会趋近完美了。</strong></p><p><strong>例2、完善的字符转换函数</strong><br>    &amp;ensp;&amp;ensp;将力求完美，编写这个函数。同时也希望能够说明现在的知识能够实现非常多的东西了，只有有想法，就去淦他！<br>    &amp;ensp;&amp;ensp;接上面的函数，我们先加入正负判断，因为这个比较简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">Str2Num</span><span class="hljs-params">(<span class="hljs-type">char</span> str[],<span class="hljs-type">int</span> len)</span><br>&#123;<br><span class="hljs-type">int</span> i; <br><span class="hljs-type">char</span> isNegative;<br><span class="hljs-type">double</span> result=<span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span>(str[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>)<br>&#123;<br>i = <span class="hljs-number">1</span>;<br>isNegative = <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;+&#x27;</span>)<br>&#123;<br>i = <span class="hljs-number">1</span>;<br>isNegative = <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>i = <span class="hljs-number">0</span>;<br>isNegative = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(;i&lt;len;i++)<br>&#123;<br>result += (str[i]<span class="hljs-number">-0x30</span>)*<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,len-i<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(isNegative)<br>&#123;<br>result = -result;<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;这里我们用isNegative这个变量来存储是否是负值，这种情况很常见，<strong>用一个状态变量来存放一个状态</strong>，其实用bool类型是最合适的，但C语言不怎么见这种类型，用char也行，只有能区分就行了。<br>&amp;ensp;&amp;ensp;判断什么的就好说了，因为符号只能出现在开头，取出来判断，if分支，给i和isNegative对不同的情况赋初值。<br>&amp;ensp;&amp;ensp;最后是负的话取相反数就行了，符号判断OK。<br>&amp;ensp;&amp;ensp;对于小数的转换，比较麻烦，我这里使用自己的思路，肯定不是最好的。<br>&amp;ensp;&amp;ensp;首先找到小数点，小数点前面的位权都是10的正幂，小数点后面的位权都是0.1的正幂，或者说是10的负幂，这样分成两种情况，就OK了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">Str2Num</span><span class="hljs-params">(<span class="hljs-type">char</span> str[],<span class="hljs-type">int</span> len)</span><br>&#123;<br><span class="hljs-type">int</span> i,j=len; <br><span class="hljs-type">char</span> isNegative;<br><span class="hljs-type">double</span> result=<span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(str[i] == <span class="hljs-string">&#x27;.&#x27;</span>)<br>&#123;<br>j = i;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span>(str[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>)<br>&#123;<br>i = <span class="hljs-number">1</span>;<br>isNegative = <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;+&#x27;</span>)<br>&#123;<br>i = <span class="hljs-number">1</span>;<br>isNegative = <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>i = <span class="hljs-number">0</span>;<br>isNegative = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(;i&lt;len;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(i&lt;j)<br>&#123;<br>result += (str[i]<span class="hljs-number">-0x30</span>)*<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,j-i<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(i&gt;j)<br>&#123;<br>result += (str[i]<span class="hljs-number">-0x30</span>)*<span class="hljs-built_in">pow</span>(<span class="hljs-number">0.1</span>,i-j);<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">if</span>(isNegative)<br>&#123;<br>result = -result;<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;注意，那个幂次要特别注意，多整几遍。<br>&amp;ensp;&amp;ensp;现在这个程序看起来很像样了，但还是不好，我们希望它的健壮性更好一些，能判别输入是否合规，对于123a45这种字符串要拒绝。<br>&amp;ensp;&amp;ensp;因为这个判断也要遍历，我们把它和找小数点的for循环放在一起：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(str[i] == <span class="hljs-string">&#x27;.&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(j != len)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR\a\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>j = i;<br>&#125;<br><span class="hljs-keyword">if</span>((str[i]&lt;<span class="hljs-number">48</span> || str[i]&gt;<span class="hljs-number">57</span> )&amp;&amp; str[i] != <span class="hljs-string">&#x27;.&#x27;</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\a\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;由于当存在小数点时，j的值会变为i的值，j不再等于原来的len，当发现有小数点时，而j又不等于len，说明前面就出现过小数点了，这个输入就有问题，如2.356.8，这个输入非法。<br>&amp;ensp;&amp;ensp;if((str[i]&lt;48 || str[i]&gt;57 )&amp;&amp; str[i] !&#x3D; ‘.’)是对字符是否是数字的判断，在ascii中字符都处在48和57之间，由于我们中间会出现小数点，小数点不在这个范围内，但出现小数点是合法的（不合法的情况我们有前面的判断），所以要把小数点刨去。<br>&amp;ensp;&amp;ensp;现在这个函数应该比较完善了。<br>&amp;ensp;&amp;ensp;完整代码：(补充对开始符号输入判断的)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;math.h&gt;</span></span><br><br><span class="hljs-type">double</span> <span class="hljs-title function_">Str2Num</span><span class="hljs-params">(<span class="hljs-type">char</span> str[],<span class="hljs-type">int</span> len)</span>;<span class="hljs-comment">//声明</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> a[] = <span class="hljs-string">&quot;1230.456789&quot;</span>;<br><span class="hljs-type">int</span> num = (<span class="hljs-keyword">sizeof</span>(a)/<span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>])<span class="hljs-number">-1</span>);<br><span class="hljs-type">double</span> res = Str2Num(a,num);<span class="hljs-comment">//调用和返回</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,res);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-type">double</span> <span class="hljs-title function_">Str2Num</span><span class="hljs-params">(<span class="hljs-type">char</span> str[],<span class="hljs-type">int</span> len)</span><span class="hljs-comment">//定义</span><br>&#123;<br><span class="hljs-type">int</span> i,j=len; <br><span class="hljs-type">char</span> isNegative;<br><span class="hljs-type">double</span> result=<span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(str[i] == <span class="hljs-string">&#x27;.&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(j != len)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR\a\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>j = i;<br>&#125;<br><span class="hljs-keyword">if</span> ((str[i] &lt; <span class="hljs-number">48</span> || str[i]&gt;<span class="hljs-number">57</span>) &amp;&amp; str[i] != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp;str[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp;str[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;+&#x27;</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\a\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span>(str[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>)<br>&#123;<br>i = <span class="hljs-number">1</span>;<br>isNegative = <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;+&#x27;</span>)<br>&#123;<br>i = <span class="hljs-number">1</span>;<br>isNegative = <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>i = <span class="hljs-number">0</span>;<br>isNegative = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(;i&lt;len;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(i&lt;j)<br>&#123;<br>result += (str[i]<span class="hljs-number">-0x30</span>)*<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,j-i<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(i&gt;j)<br>&#123;<br>result += (str[i]<span class="hljs-number">-0x30</span>)*<span class="hljs-built_in">pow</span>(<span class="hljs-number">0.1</span>,i-j);<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">if</span>(isNegative)<br>&#123;<br>result = -result;<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>&amp;ensp;&amp;ensp;顺便来介绍一下作用域和生存周期的事，就是变量在哪个范围内有效的事。<br>&amp;ensp;&amp;ensp;我们定义的变量是从定义时开始有效（存在），因为编译器现在才第一次见到这个变量，这很好理解，（变量的定义：int a）。<br>&amp;ensp;&amp;ensp;但变量什么时候消失，就要看变量定义在哪里了。<br>&amp;ensp;&amp;ensp;变量定义一般可以在3个地方</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> b;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-type">int</span> c;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;由于main函数也是函数，所以可以得到下面的情况：<br>&amp;ensp;&amp;ensp;a定义在函数外面，b定义在函数的开头，c定义在复合语句的开头（复合语句就是用一对大括号括起来的语句们）。<br>&amp;ensp;&amp;ensp;<strong>其中，在函数内部定义的变量只在函数内有效，b的生存周期就是从定义开始到main函数结束，a又叫做全局变量，因为是全局有效的，即从定义开始到程序结束a都存在，c定义在复合语句中，则它的生存周期只存在于符合语句中。</strong><br>&amp;ensp;&amp;ensp;<strong>所有变量的生存周期一过，这个变量就消失了，死掉了，无法再访问。</strong><br>&amp;ensp;&amp;ensp;对于同名的变量来说，只要不在同一个生存周期内，就没事，否则会发生重定义的问题，如<br>{<br>    &amp;ensp;&amp;ensp;Int a;<br>    &amp;ensp;&amp;ensp;Int a;<br>}<br>很明显这两个a都是这个复合语句内的，会产生重定义的错误。<br>{<br>    &amp;ensp;&amp;ensp;Int a;&#x2F;&#x2F;1<br>&amp;ensp;&amp;ensp;{<br>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;Int a; &#x2F;&#x2F;2<br>&amp;ensp;&amp;ensp;}<br>}<br>&amp;ensp;&amp;ensp;这个就ok，因为两个a的生存周期不同，当使用a这个变量名的时候，指的是哪个变量呢？很好说，出了第二层括号2号a就歇菜了，所以在第二层括号外第一层括号内的a都是1号a，在第二层括号内，1，2号a同时存在，则2号a顶替1号a，成为这个括号内的a，<strong>简单来说就是短周期的顶替长周期的</strong>，所有变量都遵守这种规则。<br>&amp;ensp;&amp;ensp;注意这个全局变量：由于普通函数的形参也只是在函数内存在，函数一退出就没了，函数能带出来的只有返回值，还必须赶紧接收，<strong>这使得我们想返回多个值成为问题</strong>。当然，我们可以用指针轻松解决这个问题，但更为简单的方法就是<strong>用全局变量带出来</strong>，因为全局变量全局存在，所以在函数中对全局变量的改变不会随函数的消失而消失。<br>&amp;ensp;&amp;ensp;对于变量的存储类型，这里只说一个比较常见的：extern<br>&amp;ensp;&amp;ensp;对于全局变量，也只能在本文件下生效，不能说我这个文件下写的全局变量，我想在另一个文件中用，或者是我在程序中间定义了一个全局变量，但我想在前面就用，对于这些情况，我们就要用extern前缀做外部变量声明，来扩大全局变量的生存周期：</p><p>extern int a;&#x2F;&#x2F;1<br>……<br>int a；&#x2F;&#x2F;2<br>&amp;ensp;&amp;ensp;a是全局变量，正常来说a只在2以后才生效，但通过1，我们使a的生存周期从1开始，扩大了它的生存周期。<br>&amp;ensp;&amp;ensp;对于扩展到其他文件中也是同样的，通过extern将变量扩展到别的文件中，如下面的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">文件<span class="hljs-number">1</span>：<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> A;<br><span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">(k)</span>;<span class="hljs-comment">//2中的函数声明</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>A = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, test(<span class="hljs-number">4</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>文件<span class="hljs-number">2</span>：<br><span class="hljs-keyword">extern</span>  <span class="hljs-type">int</span> A;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span><br>&#123;<br><span class="hljs-keyword">return</span> k * A;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;可以正常运行，且A的值能传到文件2中，且2的函数也能正常使用<br>&amp;ensp;&amp;ensp;下一章会就关于多文件编程补充总结一下（原本打算下一章上指针，但在写这篇文章的时候感觉函数的多文件编程还是很重要的，而老师上课讲的极少……）<br>&amp;ensp;&amp;ensp;<strong>我们下章再见！</strong></p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">]]></content>
    
    
    <categories>
      
      <category>知识总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识总结</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习入门（个人版）</title>
    <link href="/2021/08/05/py00/"/>
    <url>/2021/08/05/py00/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&amp;ensp;&amp;ensp;最近在学习py，趁着没忘把这两天（其实也就学了两次）学的总结一下，我是学C语言起手的，就顺便做个知识迁移，重点比较一下py和C语言或C++之间不同的地方，相同的就不提了。<br>&amp;ensp;&amp;ensp;学习书籍——《python编程，从入门到实践》<br>&amp;ensp;&amp;ensp;学了点py，说说感受，确实是“简单”了一些，并不是说它不复杂（函数方法多的要死），而是封装的是真的好，C语言几乎所有函数都是自己写，sort函数写了不知道多少个，py直接提供，挺不错的。这种简单对上手难度的减少有很大帮助，对新手很友好，你甚至不需要知道变量的类型就能写py的代码，这在C语言是不可想象的，你不会变量类型，你变量都定义不了。当然简单是要付出代价的，我这里并不说运行和解释编译上的事，而是对学习编程的人来说，py优秀的封装是优点，同时也是学习编程的人向更深的地方迈进的难关，因为你只需要用函数，用方法就ok，功能一样能实现，其他的什么py都帮你搞好了。知其然还要知其所以然，只有更深的学习，才能更理解代码和编程，我或许明白现在很多学校还是要教C语言的原因了。<br>&amp;ensp;&amp;ensp;好了言归正传，py的学习笔记。<br>&amp;ensp;&amp;ensp;内容：从开始到字典。</p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="一、零碎"><a href="#一、零碎" class="headerlink" title="一、零碎"></a>一、零碎</h1><ol><li><p> py不用定义变量就能直接用！！！！<br>a &#x3D; 10;<br>a &#x3D; 5;<br>a &#x3D; 2.6;<br>a &#x3D; ‘5656’;<br>a &#x3D; [1,2,3,5,6,6,6];<br>a &#x3D; {“dsfs”:55};<br>完全OK，当时着实惊到我了。</p></li><li><p>字符串的方法：</p></li></ol><table><thead><tr><th align="center"></th><th></th></tr></thead><tbody><tr><td align="center">title()</td><td>首字母大写</td></tr><tr><td align="center">upper()</td><td>全大写</td></tr><tr><td align="center">lower()</td><td>全小写</td></tr><tr><td align="center">rstrip()</td><td>保证字符串末尾无空格（暂时的）</td></tr><tr><td align="center">lstrip()</td><td>保证字符串开头无空格（暂时的）</td></tr><tr><td align="center">strip()</td><td>保证字符串前后无空格（暂时的）</td></tr><tr><td align="center">str（）</td><td>非字符串转字符串（数字-&gt;字符）</td></tr></tbody></table><ol start="3"><li><p>用**代表乘方<br>3**2 &#x3D; 3^2 &#x3D; 9；</p></li><li><p>3&#x2F;2 &#x3D; 1.5！！！<br>整数除整数可以得到小数。</p></li><li><p>注释：</p></li></ol><p>#单行注释</p><p>‘’‘<br>多行注释<br>‘‘’</p><p>“”“<br>多行注释<br>““”</p><ol start="6"><li>Py用回车区分语句段，不用写；了，不过为保持一致的习惯我还是加上了。</li></ol><h1 id="二、列表"><a href="#二、列表" class="headerlink" title="二、列表"></a>二、列表</h1><p>&amp;ensp;&amp;ensp;这算是学py的第一个新类型，其实和数组很像，不过比数组功能强很多，这里正好比较一下。<br>    &amp;ensp;&amp;ensp;列表——啥都能放<br>&amp;ensp;&amp;ensp;b &#x3D; [5,6,”5”,”5.55”,5.66,’d’];完全没有问题，C语言的数组是有类型限制的，定义的时候是啥类型就是啥，只能放同类型的变量。<br>&amp;ensp;&amp;ensp;列表是动态的，和C++的容器vector非常像。</p><ul><li>列表定义——列表名 &#x3D; [列表内容]；</li><li>访问列表——列表名[序号]，从0开始（可能只有matlab奇葩的会从1开始算吧……）<br>注：可以倒着访问，如a[-1]——访问a列表最后一个元素，而不用管a的长度。<br><strong>A[-2]——A的倒第二元素</strong>。</li><li>列表修改：<br>法1：访问后重新赋值。<br>法2：现有方法（我一般叫C++的成员函数为方法，这种函数都是点出来的；全局函数叫函数）</li></ul><table><thead><tr><th align="center"></th><th></th></tr></thead><tbody><tr><td align="center">尾加</td><td>append（待加内容）</td></tr><tr><td align="center">插入</td><td>insert（序号，待插内容）——写哪插那，后面的元素后移。）</td></tr><tr><td align="center">删除（这是函数）</td><td>del 列表[序号]</td></tr><tr><td align="center">弹出</td><td>pop（），弹出最后一项（当返回值）</td></tr><tr><td align="center"></td><td>pop（序号），弹出序号处项，后面前移</td></tr><tr><td align="center">移除</td><td>remove（待移内容），查找，找到并移走，只移找到的第一个。</td></tr></tbody></table><ul><li><p>列表排序：<br>  方法：<br>  sort（）——增序<br>  sort（reverse &#x3D; True）——降序<br>  sort都是永久改变列表排序的<br>  注：py的bool值必须要大写，False，True，小写的还不认……<br>  函数：sorted（例表名）——增序，临时（返回值）</p></li><li><p>列表倒叙：reverse（）——方法，永久的</p></li><li><p>列表长度：len（列表名）——函数，返回列表长度</p></li><li><p>数字列表：range（A，B），产生从A到B-1的数字<br>list（range（A，B）），将range产生的数字变列表。<br>min（A），max（A），sum（A）——求A列表的最小值，最大值，和。</p></li><li><p>列表解析：a &#x3D; [关于A的表达式  for循环（A当操作数，for A in B）]<br>列表中的值为表达式的结果。</p></li><li><p>列表切片，访问列表部分的元素（这一部分和matlab一样）<br>切片：列表名 [开始序号：结束序号+1]，省啥默认到头。<br>a[0：4]——a[0], a[1], a[2]，a[3];<br>取倒三人：a[-3:]等价于a[-3:0] 取a[-1], a[-2]，a[-3]——不用管长度</p></li><li><p>遍历切片：for A in B[1:7]——看B列表1到6的元素</p></li><li><p>复制切片：A &#x3D; B[:]——把B全部当一个切片给A，A相当于B的拷贝</p></li><li><p>列表关联：A &#x3D; B——A列表和B列表指向同一个列表空间（相当于C++的引用）</p></li><li><p>元组——不能改变的列表<br>定义：元组名 &#x3D; { 元素 }；<br>访问——用下标<br>不可修改，但可全部重新定义。</p></li></ul><h1 id="三、for循环"><a href="#三、for循环" class="headerlink" title="三、for循环"></a>三、for循环</h1><pre><code class="hljs">for A in B:    操作A</code></pre><p>&amp;ensp;&amp;ensp;对B列表中的元素遍历操作，出for循环时A保留最后一次的值。<br>&amp;ensp;&amp;ensp;注：py不用大括号，看缩进。注意冒号<br>&amp;ensp;&amp;ensp;for A in range（30）：<br>&amp;ensp;&amp;ensp;循环30次，A的值从0到29.</p><h1 id="四、if语句"><a href="#四、if语句" class="headerlink" title="四、if语句"></a>四、if语句</h1><p>If-else</p><pre><code class="hljs">if 条件判断：    操作else：    操作</code></pre><p>If-elseif</p><pre><code class="hljs">if 条件判断：    操作elif 条件：    操作else：    操作</code></pre><p>逻辑与：and，C中的（&amp;&amp;）；<br>逻辑或：or，C中的（||）；</p><p>判断某东西是否在列表中，用关键字in<br>A in B——A在B（列表）中吗——返回bool值<br>判断某东西不在列表中，用关键字not in<br>A not in B——A不在B（列表）中吗——返回bool值</p><p><strong>注：If语句中条件表达式为列表名时，列表为空时非false，不空时为true。</strong></p><h1 id="五、字典（和C中的结构体比较像）"><a href="#五、字典（和C中的结构体比较像）" class="headerlink" title="五、字典（和C中的结构体比较像）"></a>五、字典（和C中的结构体比较像）</h1><p>&amp;ensp;&amp;ensp;py-字典：是动态的。<br>&amp;ensp;&amp;ensp;键值对：一一对应的一对，（键：值）——就是变量的名字和值。</p><ul><li>定义：字典名 &#x3D; {键值对}；</li><li>访问：字典名[键]——访问这个键对应的值。</li><li>添加：字典名[新键] &#x3D; 新值；<br>注：print（字典名）——连{ }在内的都显示。</li><li>修改：字典名[键] &#x3D; 新值；</li><li>删除：del 字典名[键]；</li></ul><p>C语言结构体：</p><pre><code class="hljs">struct  A（名字） //结构体类型的声明&#123;变量类型 变量名1；变量类型 变量名2；……&#125;b = &#123;值1，值2……&#125;；    //结构体变量的定义和初始化</code></pre><p>&amp;ensp;&amp;ensp;访问：结构体变量.变量名——访问这个结构体变量的这个变量名的值<br>&amp;ensp;&amp;ensp;结构体是静态的，因为定义好之后编译器就分配这么大的内存，变化不了了，想实现动态的改变，可以包含指针类型的变量，通过指针的指向的变化来实现。<br>&amp;ensp;&amp;ensp;printf（结构体名）——没这个操作……</p><ul><li>对字典的遍历：<ol><li><pre><code class="hljs">for A，B in M.items()： A-键；B-值；M-字典名；M.items()-返回一个键值对</code></pre><ol start="2"><li><pre><code class="hljs">只遍历键：方法keys（）——for A in M.keys()：</code></pre><ol start="3"><li><pre><code class="hljs">只遍历值：方法values（）——for A in M. values()：</code></pre></li></ol></li></ol></li></ol></li></ul><p>注：集合——set（列表）——&gt;剔除重复项</p><ul><li>嵌套：字典列表-（结构体数组）<br>列表名 &#x3D; [字典名1，字典名2，字典名3……]；</li></ul><p>字典中有列表（数组当结构体中的元素）<br>键：值（是一个列表）</p><p>字典套字典（结构体的相互嵌套）<br>访问：一级一级的（点）出来。</p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">]]></content>
    
    
    <categories>
      
      <category>知识分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识总结</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言总结项目和入门——基础下</title>
    <link href="/2021/08/01/C01/"/>
    <url>/2021/08/01/C01/</url>
    
    <content type="html"><![CDATA[<p>废话不多说，咱们马上开始。</p><h1 id="三、C语言基础下（从交互到数组）"><a href="#三、C语言基础下（从交互到数组）" class="headerlink" title="三、C语言基础下（从交互到数组）"></a>三、C语言基础下（从交互到数组）</h1><h2 id="一、输入输出"><a href="#一、输入输出" class="headerlink" title="一、输入输出"></a>一、输入输出</h2><p>&amp;ensp;&amp;ensp;从上一章的例子可以看出，很多时候我们需要向程序输入一些数据，或者希望程序将一些数据以可视化的方式呈现在我们眼前。人机的交互就显得十分重要。<br>&amp;ensp;&amp;ensp;C语言本身不提供输入输出的语句，但它提供了一个标准库，即说明书，里面定义了一些输入输出的方法，如printf和scanf。本章将介绍这些方法的用法。<br>&amp;ensp;&amp;ensp;使用这些方法之前，要包含这个说明书哦（#include&lt;stdio.h&gt;）。</p><ol><li>printf</li></ol><p>&amp;ensp;&amp;ensp;printf用来向小黑窗输出一些数据。<br>用法：<br>a．printf（”输出”）；——将“”里的东西打印出来。<br>注：转移字符也是可以打印的，如果在“”中出现&#x2F;a，打印的时候就会有提示音，如果是&#x2F;n，后面的内容就会换行打印。具体可以对照前面的转义字符表。<br>    b．printf（“包含格式控制”，输出列表）；<br>    &amp;ensp;&amp;ensp;还记得前面的例子我们如何打印周长的值的吗，就是用的这个方法，当我们想打印变量的值时，就可以采用这种格式。<br>&amp;ensp;&amp;ensp;格式控制是什么？简单来说，就是在“”中代替变量的东西，比如我们想打印一个整型变量a的值，如果直接在“”中出现a，printf会认为你本身就想输出a这个字符，而不是变量，这时就需要格式控制字符出马了。<br>    &amp;ensp;&amp;ensp;格式控制字符有下面几种，分别对应不同的数据类型和情况。</p><table><thead><tr><th>%d</th><th>输出带符号十进制整数</th></tr></thead><tbody><tr><td>%c</td><td>输出一个字符</td></tr><tr><td>%s</td><td>输出一个字符串</td></tr><tr><td>%f</td><td>输出实数（带小数）（注：只能输出6位小数）</td></tr><tr><td>%o</td><td>以八进制形式输出一个整数</td></tr><tr><td>%x</td><td>以十六进制形式输出一个整数</td></tr><tr><td>%u</td><td>输出无符号型数据</td></tr><tr><td>%e，%E</td><td>以指数形式输出实数</td></tr><tr><td>%g，%G</td><td>自动匹配实数输出方式（小数形式或者指数形式）</td></tr></tbody></table><p>&amp;ensp;&amp;ensp;在%d，%f，%x，%o可以加l前缀变成%ld，%lf，%lx，%lo，表示长型。<br>&amp;ensp;&amp;ensp;对于%c，可加数字指定宽度，如%5c，表示输出5个长度的字符，前面用空格补齐。<br>&amp;ensp;&amp;ensp;对%f，可以有形如%m.nf的形式，其中m表示输出占的宽度，n表示输出的小数，采用四舍五入的形式。如%8.3f表示输出一共长为8，其中有3位小数。位数不够时，在前面补空格（后对齐），如果是%-m.nf，则是在后面补空格（前对齐）。<br>    &amp;ensp;&amp;ensp;当然，格式控制字符可以夹杂在普通字符之中，也可以在一个printf中输出多个变量，要注意和输出列表相对应就行，第一个控制字符对于输出列表中的第一个变量。<br>    &amp;ensp;&amp;ensp;如果想输出%这个字符，和输出&#x2F;类似的，要连续写2个%%，这时才会输出一个%字符。</p><ol start="2"><li><pre><code class="hljs">scanf</code></pre></li></ol><p>&amp;ensp;&amp;ensp;scanf用来从键盘上输入东西给程序。其一般格式为：<br>scanf（“格式控制“，地址列表）；<br>&amp;ensp;&amp;ensp;格式与printf一样，以%开头，可以与其他字符混合使用，但注意此时输入必须完全一致。如“ “中是“ok56%d”，由前面可知我们想输入一个整型，但此时直接输入是不能起作用的，必须按照写的内容先输入ok56之后再输入的数字才算整型变量的内容。<br>&amp;ensp;&amp;ensp;注意，这里是地址列表，和上面的变量列表有所不同。<br>&amp;ensp;&amp;ensp;具体不同在哪里？就是要把输入的值给哪个变量，哪个变量前面要加上&amp;一个符号，从而构成地址列表。<br>&amp;ensp;&amp;ensp;如scanf（“%d”，&amp;a）；表示输入一个整型变量，并给a。<br>&amp;ensp;&amp;ensp;<strong>注意，不管scanf还是printf，变量与格式类型都要一直，否则无法正确输出或输入。<br>&amp;ensp;&amp;ensp;接下来引入地址的概念。</strong><br>&amp;ensp;&amp;ensp;我们前面已经说过，变量开辟在内存的某个区域，里面存放的值就是这个变量的值，我们通过变量名对这片区域操作。那么我们能否知道这个区域在哪里呢？实际上是可以的，虽然我们无法指定这个变量开辟在内存的什么地方，但我们可以知道它被开辟在哪里，变量开辟在内存的什么地方就是变量的地址，就好比房子与门牌号，内存空间就是房子，里面住着变量，门牌号就是地址。那么怎么取得这个门牌号？我们用一种新的运算符&amp;，&amp;a就表示a的地址。当然我们可以看看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a,b;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x\n%x&quot;</span>,&amp;a,&amp;b);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/f226197ecab44d0c9796fd5e3111830a.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;a和b的地址就显示出来了。<br>&amp;ensp;&amp;ensp;虽然现在看起来这个地址没啥用，在后面可是有非常重要的作用，和C语言的灵魂——指针相互配合，能产生极强的combo。当然这都是后话，循序渐进嘛。<br>&amp;ensp;&amp;ensp;我们也可以一次输入多个变量的值。注意匹配就行。对于数字类型的输入，两两之间要以空格、回车、tab键分割来区分，对于字符类型的输入，因为空格、回车、tab键也是字符，或者说从键盘上输入的全是字符，所以连续输入就行了。<br>&amp;ensp;&amp;ensp;介绍了用处最多的两种输入输出，下面介绍一些其他的输入输出。</p><ul><li>putchar：输出一个字符，putchar（c），c为字符型变量。</li><li>getchar：输入一个字符，没有参数，需要有变量接收，c &#x3D; getchar（），c为字符型变量，接受来着键盘输入的一个字符。</li></ul><p>注：这里讲解一下接收的概念，我们从键盘上向程序输入一个东西，程序就需要用一个东西来接收我们的输入，通常是用变量来接收。</p><ul><li>puts（）：输出一个字符串。</li><li>gets（）：输入一个字符串。</li></ul><p>注：大家会发现，数据类型虽然有字符串，但C语言并没有相应的变量类型，不像别的语言有string这中字符串的变量类型，那么C语言怎么实现字符串的操作？是通过数组来实现的，这里先埋个伏笔。</p><h2 id="二、程序结构"><a href="#二、程序结构" class="headerlink" title="二、程序结构"></a>二、程序结构</h2><p>在这一章，我们来从整体程序的角度，看看程序一般由什么部分构成。<br>程序结构分三大块，选择结构、循环结构、顺序结构<br>我们前面写的都是顺序结构，即从头写到尾，这个结构是线性的。</p><ol><li>选择结构</li></ol><p>&amp;ensp;&amp;ensp;还记得三目运算符吗，它通过判断逻辑表达式的真假，实现执行不同的代码的作用，这就是选择结构。选择结构通过判断，根据判断的结果执行不同的代码块。</p><ul><li>if选择结构的基本构成：<br>if（判断条件）<br>{<br> &amp;ensp;&amp;ensp;代码块a<br>}</li></ul><p>&amp;ensp;&amp;ensp;判断条件是逻辑表达式或其组合，当判断条件为真（非0值）时，程序进入大括号执行代码块a，否则跳过不执行代码块a。<br>if（判断条件）<br>{<br>    &amp;ensp;&amp;ensp;代码块a<br>}else{<br>    &amp;ensp;&amp;ensp;代码块b<br>}<br>&amp;ensp;&amp;ensp;判断条件是逻辑表达式或其组合，当判断条件为真（非0值）时，程序进入大括号执行代码块a，否则执行代码块b。<br>&amp;ensp;&amp;ensp;If里面可以套if，不断细分判断情况，if——else也可以逐级使用，实现分级过滤的效果。<br>如：<br>if（判断条件1）<br>{<br>    &amp;ensp;&amp;ensp;代码块a<br>}else if（判断条件2）<br>{<br>    &amp;ensp;&amp;ensp;代码块b<br>}else{<br>    &amp;ensp;&amp;ensp;代码块c<br>}<br>&amp;ensp;&amp;ensp;判断是否符合条件1，不符合的话，判断是否符合条件2，不符合的话，就执行最后的else，即代码块c。这种结构可以多级使用。<br>&amp;ensp;&amp;ensp;<strong>If与else的匹配：当然实际上我们在写代码的时候会有缩进，很容易看出if和哪个else是对应的，但架不住有人喜欢考啊，这里说一下，else总是和最近的if匹配。</strong><br>&amp;ensp;&amp;ensp;<strong>关系运算符的优先级：</strong><br><img src="https://img-blog.csdnimg.cn/91441c0639be451988189fea80fd3740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;关系运算符优先级低于算术运算符，高于赋值运算符。</p><ul><li>switch语句实现多分支</li></ul><p> &amp;ensp;&amp;ensp;对于多种彼此互斥的情况，如一等二等三等，我们当然可以使用上面的if——else进行分级判断<br>if（是一等）<br>{<br>        &amp;ensp;&amp;ensp;代码块a<br>}else if（二等）&amp;ensp;&amp;ensp;&#x2F;&#x2F;不是一等，还可能是二等三等，对二等进行判断。<br>{<br>        &amp;ensp;&amp;ensp;代码块b<br>}else{&amp;ensp;&amp;ensp;&#x2F;&#x2F;不是一二等，是三等<br>        &amp;ensp;&amp;ensp;代码块c<br>}</p><p>&amp;ensp;&amp;ensp;C语言还提供了一种新的判断的结构，即switch结构<br>&amp;ensp;&amp;ensp;基本构成：<br>switch（判断变量）<br>{<br>        &amp;ensp;&amp;ensp;case 情况1：<br>    &amp;ensp;&amp;ensp;case 情况2：<br>        &amp;ensp;&amp;ensp;default：<br>}<br>&amp;ensp;&amp;ensp;这里的case可以有很多，取决于要判断的情况，这里只举例写了两个。<br>&amp;ensp;&amp;ensp;switch判断要判断的变量的值，对应下面的哪个情况，比如待判断的变量值为5，就走case 5：这一条分支（如果写了case 5：这一条分支的话）。如果都没有，在有default的情况下执行default的程序，没有的话就跳出switch。<br>&amp;ensp;&amp;ensp;首先需要指出，这里判断的变量只能是整数，所以a只能为整型或字符型，这一点极大的限制了switch的使用。<br>&amp;ensp;&amp;ensp;其次，这里的情况是要和待判断的变量的值相匹配。由于我们必须指明一种情况来对应一个case，（a&lt;1是不能当case的情况的，即case的情况也必须是整数）所以我们只有知道确切的条件判断情况才能使用switch语句，对于a&lt;1这种判断switch是无法使用的。<br>&amp;ensp;&amp;ensp;<strong>下面对switch语句进行进一步理解。</strong><br>switch（判断变量）<br>{<br>    &amp;ensp;&amp;ensp;case 情况1：<br>    &amp;ensp;&amp;ensp;case 情况2：<br>    &amp;ensp;&amp;ensp;default：<br>}<br>&amp;ensp;&amp;ensp;这里的case M：的作用只是起到一个标号的作用，<strong>就是告诉switch这里有一个入口，进入这个入口的条件是待判断的变量的值等于M</strong>，我们可以罗列所有待判断变量的取值，这样可以保证每次都进入一个case，当然很多时候罗列是不可行的，我们采用default分支，当switch发现没有入口对应这个变量的值时，他就会进入default的入口。<br>&amp;ensp;&amp;ensp;注意：case只是起到标号的作用，告诉入口，<strong>但并不告诉出口</strong>。这什么意思呢，就是当switch进入一个case入口后，它不知道什么时候出去，我们当然是希望它只执行这个case里的语句，当它执行完就不再执行其他case和default的语句而是直接跳出switch，而实际上如果不加控制，switch会从进入的case语句一直向下执行，把写在这个入口case语句下面的case和default都执行了，那这样根本没起到分支的效果啊（当然这种特性有也奇用）。所以我们需要添加出口，来告诉switch进入后从哪里出，既然是先进入才出，那出口肯定是要写在case语句里，而且由于上面的原因，每个case都要一个出口（default一般可以不要，因为它一般写在switch最后，执行完switch也就执行完了，不需要额外的出口）。<strong>C语言实现出口的语句是break</strong>，所以我们在每个case里都加上break，程序就能顺利执行了，所以程序一般实际上是这样的：<br>switch（判断变量）<br>{<br>        &amp;ensp;&amp;ensp;case 情况1：代码；break;<br>    &amp;ensp;&amp;ensp;case 情况2：代码；break;<br>    &amp;ensp;&amp;ensp;default：代码；<br>}</p><h1 id="代码训练与详解"><a href="#代码训练与详解" class="headerlink" title="代码训练与详解"></a>代码训练与详解</h1><p>首先来一个分段函数；<br>    例：实现sgn函数（x&lt;0是为-1，x&#x3D;0时为0，x&gt;0时为1）<br>    &amp;ensp;&amp;ensp;我们用if来实现（switch不行，因为x&lt;0是无穷多的情况，不能用case表示）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">double</span> x=<span class="hljs-number">0</span>;<br><span class="hljs-type">double</span> y=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input the x:&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;x);<br><span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>)<br>&#123;<br>y = <span class="hljs-number">-1</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>)<br>&#123;<br>y = <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>y = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;y = %-1.0lf&quot;</span>,y);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;有了上面分段函数的定义就很好写了。先判断x是否小于0，不小于的话再判断x是否等于0，要是也不等于，说明x是大于0的，再把各个部分的代码块补充完成，就OK了。最后printf采用m.n的形式输出，因为一定是没有小数的，所以后面的一堆0就不必显示了。</p><p><strong>例：实现大小月的判断</strong><br>这里我们采用switch分支，因为只有12个月是有限的。<br>&amp;ensp;&amp;ensp;老样子，先上码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> month=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input the month:&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;month);<br><span class="hljs-keyword">switch</span>(month)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;It has 31 days.&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;It usually has 28days.&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-number">11</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;It has 30 days.&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error input\a&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;这里我采用了前面case的奇妙用法，<strong>因为虽然入口需要彼此不同（一条路（入口）怎么走向2个方向呢，能走向2个方向必然要有分支），但可以指向同一个地方（条条大路通罗马）。</strong><br>&amp;ensp;&amp;ensp;我们当然可以这样写<br><img src="https://img-blog.csdnimg.cn/7972b30afb884b419bf55fd8dedf42a6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;等等，但这里我们不让程序结束，而是<strong>引导所有的入口指向统一地方（代码块）</strong>，就可以实现多输入，单输出的效果。<br>&amp;ensp;&amp;ensp;注意，每一块代码块完成后，要给出出口防止程序继续执行别的代码块。<br>&amp;ensp;&amp;ensp;大家还可以发现，case的情况的顺序可以随便写的，因为它只是个入口，而与它本身处在的位置无关，甚至default放开头当然也没有问题。<br>&amp;ensp;&amp;ensp;大家都知道一年有12个月，那12个case足以包含所有情况了，为什么还要一个default？这里是为了程序的健壮性。当用户输入一个不在1到12之间的数时，我们希望给与输入错误的反馈，而不是啥也不管继续执行，防止后续程序因这个判断的失效而崩溃。（我喜欢在error的地方加上提示音起到警示的作用，当然这个就看个人啦。）<br>&amp;ensp;&amp;ensp;当然，这个程序还可以完善，比如闰年2月29天，平年2月28天，从而升级成对任何年份都成立的月份天数判断程序。<br>&amp;ensp;&amp;ensp;我们要先判断平闰年，这个判断比较复杂，但写起来缺很短。<br>&amp;ensp;&amp;ensp;当然if也可以实现，但这里我们采用逻辑表达式，因为用逻辑表达式更为精炼。<br><strong>例：实现平闰年的判断</strong><br>&amp;ensp;&amp;ensp;首先，我们知道闰年大特性：能被4整除，百年能被400整除，由此我们可以写出这样的判断：<br>if(year%4 &#x3D;&#x3D; 0 || year%400 &#x3D;&#x3D; 0）<br>{<br>&amp;ensp;&amp;ensp;printf(“闰年”)；<br>}<br>&amp;ensp;&amp;ensp;整除代表着余数为0。这样的代码看起来没啥，但细看就会发现问题。能被400整除就一定能被4整除，所以由前面的知识，后面的判断根本不会执行。让我们来看看我们的初心：我们希望百年能被400整除，这里遗漏了一个点：百年，所以我们要先判断百年，再判断能被400整除吗？<br>if(（year%4 &#x3D;&#x3D; 0 &amp;&amp; year%100！&#x3D;0） || year%400 &#x3D;&#x3D; 0）<br>{<br>&amp;ensp;&amp;ensp;printf(“闰年”)；<br>}<br>&amp;ensp;&amp;ensp;前面用来判断是否是百年。</p><ol start="2"><li>循环结构</li></ol><p> &amp;ensp;&amp;ensp;当我们希望程序循环执行某一块程序，如循环输出，循环相加。我们要是使用顺序执行，就必须写很多行形式相同的代码，当然我们也可以使用循环结构来简化编程。<br>循环结构就是让程序循环执行一块程序。<br>&amp;ensp;&amp;ensp;C语言循环结构的基本框架：</p><ul><li>while循环<br> while（循环条件）<br>{<br> &amp;ensp;&amp;ensp;循环体；<br>}<br>&amp;ensp;&amp;ensp;在while语句中，while首先判断循环条件是否满足，如果满足，就执行一边循环体，再判断循环条件是否满足，再进行与上面同样的操作。<br>&amp;ensp;&amp;ensp;如果循环无法结束，即循环条件不可能为假，那么这个循环会一直执行下去，称为死循环。<br>&amp;ensp;&amp;ensp;这是应该避免的。所以说，循环条件一般要包含变量，这个变量是要在循环体中发生改变的，这样才有可能跳出循环。</li><li>do——while循环：<br>do<br>{<br>  &amp;ensp;&amp;ensp;循环体；<br>}while（循环条件）；<br>&amp;ensp;&amp;ensp;这种结构与上面是相同的，只是不同的是先执行一边循环体，再判断循环条件是否成立。</li><li>for循环（很重要）<br> 基本结构：<br>for（初始化；循环条件；循环调整）&#x2F;&#x2F;三部分<br>{<br>  &amp;ensp;&amp;ensp;循环体；<br>}<br>循环变量：参与循环条件判断或者循环体的变量。<br>初始化：一般是对循环变量进行初始化，保证正确的循环次数，可以同时对多个变量初始化，彼此用逗号隔开。<br>循环条件：判断继续循环的条件。<br>循环调整：每轮循环都会执行的部分，通常用来使循环变量发生改变。<br>&amp;ensp;&amp;ensp;for语句的执行过程：先进行初始化，再判断循环条件是否满足，如果满足，再执行循环体，再执行循环调整，然后再判断，一直反复直到跳出。<br>&amp;ensp;&amp;ensp;for循环的三部分都可以省略，但分号一个不能省。<br>&amp;ensp;&amp;ensp;eg：for(i&#x3D;0;i&lt;10;i++)<br>&amp;ensp;&amp;ensp;表示i的初始值为0，每轮循环结束后i++，当i&#x3D;10是中止循环，实际循环10次。</li></ul><p>&amp;ensp;&amp;ensp;上述的所有循环种类之间可以相互嵌套。<br>&amp;ensp;&amp;ensp;大家可以把循环想成一个环形公路+一个分支路口，当循环条件满足时一直在环形公路里跑，当循环条件不满足时，就跑出环形公路。<br>&amp;ensp;&amp;ensp;C语言还支持对这个循环公路进行修改。如果我们希望提前结束循环，就相当于在环形公路上添加出口，即break语句。当然我们也应当添加一个分支路口，这样就实现可控的出口，当条件满足就从break出口跳出循环，不满足还是要走原来的环形公路，这是什么——if条件分支。break语句通常放在if条件中，要是直接加在循环中的话，程序跑到break一定会跳出，就起不到循环的作用了。<br>&amp;ensp;&amp;ensp;我们还可以对环形公路<strong>添加捷径</strong>，让它从某一块直接返回开头，<strong>这个添加捷径的语句是continue</strong>。它的执行将使程序跳过它后面的所有循环代码直接回到循环开头，进行新一轮的循环。同样的，<strong>应当对这个捷径加以控制，即放在if条件分支中，来保持循环主体的整体性（直接写在循环中，它后面的循环程序永远不会执行，那不就白写了吗。）</strong></p><p>&amp;ensp;&amp;ensp;对于循环嵌套，break和continue只能对自己所处的循环起作用。相当于大公路套小公路，你的分支出口和捷径都是加在其本身所处的循环公路上的，所以只对本身起作用。<br>&amp;ensp;&amp;ensp;对于循环嵌套是很重要的一块内容，设计难度也比较大，本教程还是以入门为主，编程不想将太难的，各位读者应注意这个部分。</p><h1 id="代码训练与详解-1"><a href="#代码训练与详解-1" class="headerlink" title="代码训练与详解"></a>代码训练与详解</h1><p>&amp;ensp;&amp;ensp;学完了所有的程序结构，我们终于可以写出一些像样的代码，实现一些比较复杂的功能了。<br><strong>例：显示不超过任意整数的水仙花数</strong><br>&amp;ensp;&amp;ensp;所谓的“水仙花数”是指一个三位数其各位数字的立方和等于该数本身，例如153是“水仙花数”。<br>&amp;ensp;&amp;ensp;这里我们采用强硬的枚举方法，即一个一个试，计算机最擅长这种操作了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">//输入上限数字 </span><br><span class="hljs-type">int</span> i=<span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input the num:&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num);<br><span class="hljs-comment">//枚举 </span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-type">int</span> bai = i/<span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> shi = (i%<span class="hljs-number">100</span>)/<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> ge = (i%<span class="hljs-number">10</span>);<br><span class="hljs-keyword">if</span>(i == bai*bai*bai+shi*shi*shi+ge*ge*ge)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d&quot;</span>,i);<br>&#125;<br><span class="hljs-keyword">if</span>(i&gt;num)<br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>i++;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;这里bai，shi，ge分别用来提取i的百位十位个位，运用整型除整型，结果没小数的特点，除几十就是取纳位，如除100就是取百位，除1000就是取千位，当然前提是这一位必须是最高位，如果是个千位的数，你除100得到的就是千位和百位构成的一个大于10的数，这显然不是我们想要的。所以我们用取余的方法得到除去哪位剩下的数，对100取余就是去掉百位，以此类推。<br>&amp;ensp;&amp;ensp;上面我们采用了在死循环中（while（1）恒成立）添加出口的形式。当然也可以将判断写在while中。</p><p><strong>例：编写计算整数次幂的程序</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">double</span> ans=<span class="hljs-number">1</span>;<br><span class="hljs-type">double</span> di;<br><span class="hljs-type">int</span> zhi;<br><span class="hljs-type">int</span> i;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入底数：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;di);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入指数：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;zhi);<br><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;zhi;i++)<br>&#123;<br>ans*=di;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;只要抓住乘幂就是连乘，就OK。</p><p>&amp;ensp;&amp;ensp;现在它还是个程序，大家知道我们很多时候需要这种乘幂的运算，每用一次乘幂，就意味着我们需要这些代码一次，一个程序可能需要很多次乘幂运算，每次这么多代码，程序肯定又臭又长，<strong>这是编程应当避免的，编程应当最求美感，让人看得赏心悦目</strong>。那么有没有解决办法，当然有，就是<strong>封装成函数</strong>，具体内容将在函数中讲解，这里先引入一下。</p><h2 id="三、-数组"><a href="#三、-数组" class="headerlink" title="三、 数组"></a>三、 数组</h2><p>&amp;ensp;&amp;ensp;恭喜大家，来的了C语言基础的最后一部分，学完数组大家差不多就算跨在门槛上了。当然数组也是所有目前学过的最难的一部分。让我们开始吧。<br>&amp;ensp;&amp;ensp;<strong>数组就是容器，里面放着很多同样的东西。</strong><br>&amp;ensp;&amp;ensp;我们前面说过，<strong>变量是一个房间，那数组就是一栋楼，里面放着元素。</strong><br>&amp;ensp;&amp;ensp;我们先从一维数组说起。</p><ul><li>一维数组</li></ul><p>&amp;ensp;&amp;ensp;定义：int a[num]；<br>&amp;ensp;&amp;ensp;int代表这个数组的元素的类型，因为数组的元素要求是一样的，所以不能把一个double的放在int数组里。这里只是举例，各种类型的数组都是可以的。<br>&amp;ensp;&amp;ensp;a是数组名，num是数组的大小，即这个数组里能放几个元素。<br>初始化：<br>&amp;ensp;&amp;ensp;int a[num] &#x3D; {初始化列表};<br>&amp;ensp;&amp;ensp;注：只有在定义的同时进行初始化才能这样写，如果已经定义完了，在用a[num] &#x3D; {初始化列表}这样的形式是非法的。<br>&amp;ensp;&amp;ensp;初始化列表可以少于num，剩下的会自动补0；<br>&amp;ensp;&amp;ensp;这样的初始化可以省去num，即int a[ ] &#x3D; {初始化列表};编译器会自动默认num位初始化列表的元素个数。<br>&amp;ensp;&amp;ensp;注意：num必须是能够确定的值，不能是未知的。如<br>&amp;ensp;&amp;ensp;scanf(“%d”,&amp;num);<br>&amp;ensp;&amp;ensp;int a[num];是非法的，因为num的值无法确定，取决于输入。即C语言不能开辟动态大小的数组。<strong>（就是这个特点，对编程带来了多少的问题和困难啊！！我必须吐槽一下）</strong><br>数组的访问：<br>&amp;ensp;&amp;ensp;采用数组名+下标的方式，如a[2]，a[0]，注意：数组内的元素是从0开始的，即a[0]代表第一个元素，所以在定义时的a[10]确实是说明它有10个元素，但，在使用是只能最大用到a[9],a[10]是非法的，因为它超出数组定义时的范围了。<br>&amp;ensp;&amp;ensp;我们现在已经知道如何使用数组中的元素了，a[n]就是数组中第n+1个元素，可以执行所有变量允许的操作，加减乘除都不在话下。<br>数组初始化<br>&amp;ensp;&amp;ensp;我们除了可以在定义的时候就赋初值，我们还可以在定义后赋值，不过这样无法使用大括号的方式，我们需要对每个数组元素进行操作，挨个给他们赋值，这是一个循环重复的操作，我们用循环结构完成<br>for(i&#x3D;0;i&lt;len;i++)<br>{<br>&amp;ensp;&amp;ensp;a[i] &#x3D; num;<br>}<br>&amp;ensp;&amp;ensp;其中len是数组长度，<strong>注意：这里和数组定义时的数字是一样的，都表示数组内元素个数，例如int a[10]，那么这个len就为10，因为当i&#x3D;10的时候，不满足i&lt;10，所以i取值为0到9，正好覆盖所有数组元素。</strong><br>&amp;ensp;&amp;ensp;num是给数组赋值的元素，当然每次都可以是不一样的。</p><ul><li>二维数组</li></ul><p>&amp;ensp;&amp;ensp;<strong>对一维数组内的细分，假设数组名是房子，一维数组是各个房间，那么对一维数组再细分就能得到二维数组，如每个房间里的人就能构成一个二维数组，当我们希望查看某个人的信息时，我们先要找对房子，然后找见房间，再从这个房间中查看这个人而不是其他人的信息，着就时一个二维数组的访问过程。</strong><br>&amp;ensp;&amp;ensp;先说定义<br>double b[num1][num2]；<br>&amp;ensp;&amp;ensp;与一维同样的，double是这个二维数组里元素的类型，b是数组名，num1，num2是维度，如果把二维数组想成矩阵，分别是矩阵的行和列，想成矩形平面，分别是宽和长。<br>&amp;ensp;&amp;ensp;如：double b[5][2]；表示这是一个5行2列的二维数组。按上面的理解，这是对一个元素个数为5的一维数组的再细分，每个元素再细分为2个元素，即可以看成是double b[5]的一个一维数组，每个元素包含2个值（或者说又包含一个长度为2的一维数组，两个一维一和，就是二维了。）（这种理解对维数扩展很重要，对指针的使用也有帮助。）<br>&amp;ensp;&amp;ensp;如何访问二维数组的元素呢？<br>&amp;ensp;&amp;ensp;一维一维的访问，如double b[2][2]，先看第一维，表示咱们要访问第3个元素，由于第三个元素又是个一维数组，我们还要用下标的方式访问，即后面的数，表明我们要访问第三个元素（一个一维数组）中的第三个元素（是个double类型的变量）。注意，这里和一维是一样的，从0开始，最后一个数是长度减一。<br>初始化<br>&amp;ensp;&amp;ensp;同样的，可以在定义时就初始化，<br>&amp;ensp;&amp;ensp;Int a[ 3 ][ 4]&#x3D;{ { },{ },{ } };<br>&amp;ensp;&amp;ensp;这种形式再配合前面的讲解就很好理解了，二维是一维套一维，初始化就是两层大括号嵌套。<br>&amp;ensp;&amp;ensp;当然，也可以对每个第二维的元素的部分赋初值，其余的此维会自动补0</p><ul><li>字符数组</li></ul><p>&amp;ensp;&amp;ensp;当然字符数组只是类型发生了变化，结构和上面一二维是一样的。<br>&amp;ensp;&amp;ensp;Char a[10]；<br>&amp;ensp;&amp;ensp;字符数组每个元素都是一个字符。其初始化的方式和上面讲的没有区别。访问也是一样的。<br>&amp;ensp;&amp;ensp;应当说明的是，C语言中对字符串的操作时通过字符数组来实现的。由于字符串会有结束标志‘\0’，所以字符数组中就认为出现‘\0’就是这个字符串的结束标志。<br>&amp;ensp;&amp;ensp;如字符串：char a[]&#x3D;{“HAPPY”}；<br>&amp;ensp;&amp;ensp;那么a的长度是多少，答案是6，因为除了前面5个字母，还有一个结束标志\0，通常我们也可以将大括号省略。char a[]&#x3D;“HAPPY”；系统会自动认出这是一个字符串，在结尾加结束标志‘\0’。<br>&amp;ensp;&amp;ensp;字符串的输出，可是使用%s的形式，如printf(“%s”,a)其中a为放这个字符串的数组名。输出时遇到第一个结束标志就结束输出。<br>&amp;ensp;&amp;ensp;字符串输入，同样的,scanf(“%s”,a)其中a要是已定义的字符数组，长度要大于输入的字符串的长度。<br>&amp;ensp;&amp;ensp;输入多个字符串，如scanf(“%s%s%s”,a，b，c)，每个字符串之间用空格隔开。<br>&amp;ensp;&amp;ensp;对于字符串操作，我们有一些现成的方法，这些东西也不是C语言本身提供的，要包含说明书string.h。</p><table><thead><tr><th>puts（a）</th><th>将a中的内容输出，a要为字符数组名</th></tr></thead><tbody><tr><td>gets（a）</td><td>输入一个字符串放a中</td></tr><tr><td>strcat（a，b）</td><td>把b字符串的内容拼接到a的后面，结果放在a字符串中，同时返回a的地址（这里的返回，地址的概念现在不用管，因为马上就会有了）<strong>注意，a要足够大，能放下两个拼接后的新字符</strong>串。</td></tr><tr><td>strcpy（a，b）</td><td>把b中的内容复制到a去。同样的a要足够大。</td></tr><tr><td>strncp（a，b，n）</td><td>把b中的前n个字符复制到a去</td></tr><tr><td>strcmp（a，b）</td><td>将a与b的字符串比较，相同的话，返回0.</td></tr><tr><td>strlen（a）</td><td>测a的长度（不算结束符’\0’）</td></tr><tr><td>strlwr（a）</td><td>a中大写变小写</td></tr><tr><td>strupr（a）</td><td>a中小写变大写</td></tr></tbody></table><h1 id="代码训练与详解-2"><a href="#代码训练与详解-2" class="headerlink" title="代码训练与详解"></a>代码训练与详解</h1><p><strong>例：实现一个二维矩阵的转置。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">5</span>]=&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;,&#123;<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>&#125;&#125;;<br><span class="hljs-type">int</span> i,j;<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">5</span>;j++)<br>&#123;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i][j]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;转置就是行列互换，可以这样理解：原本是列满了，才进下一行，现在我们只有反过来，行满进下一列，就能实现转置的效果。<br>&amp;ensp;&amp;ensp;这里i，j表示原来的行列。<br>&amp;ensp;&amp;ensp;对于二维数组遍历时，通常都会用到2层循环，这有体现了循环的重要性。<br>结果：<br><img src="https://img-blog.csdnimg.cn/e39114798a2c4409929f47d98c000e2a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;这里每输出一行进行一个换行，可以使输出更为美观。</p><p><strong>例：简单密码登录系统</strong><br>&amp;ensp;&amp;ensp;分析：我们通过输入的密码与存储的密码相比较，等于的话输出成功登录，不等的话提示错误重新输入，错误超过5次结束程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> password[] = <span class="hljs-string">&quot;123456&quot;</span>;<br><span class="hljs-type">char</span> input[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">5</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input the password:&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,input);<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(password,input))<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Right!\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error!Try again!\n\a&quot;</span>);<br>i++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(i == <span class="hljs-number">5</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed\a&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;首先我们假设密码为123456，用i记录错误次数，用input记录输入。<br>&amp;ensp;&amp;ensp;这里：if(!strcmp(password,input))，我们已经知道当这两个一样的时候，strcmp的结果会是0，其他时候不为0，我们这里希望判断它是否相等，相等则进入if语句，即strcmp的结果是0的时候进入，那么我们对它取反，就能顺利进入if语句，而在其他情况不为0，取反之后就会变为0，无法进入if语句，这正是我们想要的。<br>&amp;ensp;&amp;ensp;如果成功，我们就跳出，失败，我们就记录一次，从头再来。<br>&amp;ensp;&amp;ensp;注意这里判断失败的方式，5次机会，则i从0到4，当i等于5 时，我们让循环结束（因为没必要了）然后输出失败就行了，那么这里为什么要一个判断呢？因为如果有成功，就会跳出循环，如果不加限制，跳出循环一定会显示失败，这个程序不就是自己打架吗。所以我们加一定的限制。我们知道当循环因为失误太多而跳出时，i的值一定是5，而成功跳出，i的值一定小于5，这就成为一个判断的条件。</p><p><img src="https://img-blog.csdnimg.cn/9a3e09719d944276a5bf89a68055ccd6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/0b8d0cb4fdf84f2b96204348eb431b2f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>   &amp;ensp;&amp;ensp;大家可以发现这里其实有个小bug，最后一次输入错误的话仍会提示再输入，这样的效果不是我们想要的，大家可以想想怎么改进一下。<br>&amp;ensp;&amp;ensp;C语言的一些基本概念都已经讲的差不多了，现在这些知识也足够编写一些像样的程序了。<br>&amp;ensp;&amp;ensp;后续内容就是真正C语言入门的知识，包括函数、指针、结构体、文件操作，每一章都极为重要。<br>&amp;ensp;&amp;ensp;我们下一讲再见！</p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">]]></content>
    
    
    <categories>
      
      <category>知识总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识总结</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蝉</title>
    <link href="/2021/07/26/zizhi00/"/>
    <url>/2021/07/26/zizhi00/</url>
    
    <content type="html"><![CDATA[<p><strong>有时候<br>时光犹如昙花<br>就像一些蝉</strong></p><p><strong>有时候<br>风沙掩埋钟塔<br>就像一些蝉</strong></p><span id="more"></span><style>  /* 设置整个页面的字体 */  html, body, .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 20px;  }  /* 只设置 markdown 字体 */  .markdown-body {    font-family: KaiTi,"Microsoft YaHei",Georgia, sans, serif;    font-size: 25px;  }</style>]]></content>
    
    
    <categories>
      
      <category>诗歌</category>
      
      <category>随手写写</category>
      
    </categories>
    
    
    <tags>
      
      <tag>诗歌</tag>
      
      <tag>随便瞎写</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言总结项目和入门——前言与基础上</title>
    <link href="/2021/07/14/C00/"/>
    <url>/2021/07/14/C00/</url>
    
    <content type="html"><![CDATA[<p>&amp;ensp;&amp;ensp;在下也是个自学了一点C语言的小菜鸡，写本栏目一方面是为了自己复习使用，另一方面也是希望能让大家快速了解C语言，写的相当随意，很多内容都是自己的理解，就算类似于轻科普的内容吧，如有错误请各位读者指正，谢谢大家。<br>&amp;ensp;&amp;ensp;本篇文章旨在用最简单的语言讲述C语言的基本语法和内容，力求大家都能看懂，能在最短的时间内入门。<br>&amp;ensp;&amp;ensp;本文章不含算法，小白也可以放心食用（因为我也不会(～￣▽￣)～）<br>&amp;ensp;&amp;ensp;推荐课程：视频——小甲鱼C语言教程；书籍：谭浩强《C程序设计》<br>&amp;ensp;&amp;ensp;话不多说，让我们开始吧！</p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="一、前言与运行环境"><a href="#一、前言与运行环境" class="headerlink" title="一、前言与运行环境"></a>一、前言与运行环境</h1><p>1.关于C语言的背景知识和应用领域读者可自行搜索查看，不在本栏目的讲述范围。<br>2.本栏目所有程序使用Dev-C++ 5.11版本，64位windows10环境下运行。</p><h1 id="二、计算机语言"><a href="#二、计算机语言" class="headerlink" title="二、计算机语言"></a>二、计算机语言</h1><h2 id="1-码制与数制"><a href="#1-码制与数制" class="headerlink" title="1.码制与数制"></a>1.码制与数制</h2><p>&amp;ensp;&amp;ensp;大家都知道，计算机只能识别0和1，要实现最简单的加减法，就必须将待加减的数字用0和1表示，也就是二进制（逢二进一）。待加减的数字用0和1表示这一过程成为编码，编码方式有很多，比如常见的恒权码8421BCD码，当然也有非恒权码如格雷码（所谓的恒权，就是指每一位的权重是恒定的）。如0111B在8421中代表（0x2^3^+1X2^2^+1x2^1^+1x2^0^&#x3D;7），在格雷码中则变成了5。其对应的编码规则如下：<br><img src="https://img-blog.csdnimg.cn/a6ffea5d89494f149bfd2c7997bd0ace.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;由此可以看出，编码只要能相互区分，都是可以的，其重点就是在于用不同的编码组合表示不同的现实情况，如表示现实中的十进制数、表示现实中的逻辑状态（时序逻辑电路）。<br>    &amp;ensp;&amp;ensp;当然还有很多编码方式，这里就不一一列举了，相关知识可以查看数电的相关知识。<br>    &amp;ensp;&amp;ensp;接下来说一说数制，我们已经将十进制数表示出来了，也就是说计算机能认得这些由0、1表示的数了，那么这些数的四则运算是怎样实现的呢？3+4&#x3D;7这个等式在计算机是如何实现的？<br>    &amp;ensp;&amp;ensp;首先，将3、4用二进制表示，即0011B（3）和0100B（4），然后用小学二年级的列竖式的方式，对位相加，再加低位的进位（注意，是逢二进一，而不再是逢十进一）当然本例中没有进一的情况，可以得到下面的数0111，也就是7。<br><img src="https://img-blog.csdnimg.cn/91beab7d11e341d3bdfcbe6f6bba0d2c.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>    &amp;ensp;&amp;ensp;注意，要选用相同的码制进行运算，得到的结果也是同码制下的结果，用8421码和5211码加出来的结果是没有意义的。<br>    &amp;ensp;&amp;ensp;如果存在最高位进位的情况，如9+7&#x3D;16，用二进制运算1001+0111&#x3D;？，由上面的方法，可以得到的1 0000的结果，你会发现，结果比原运算数多了一位，原运算数表示为4位，但结果需要5位才能表示，如果仍用4位表示，会得到0000B（0）的错误结果，其原因是在4位情况下是以16为模的，超出就会从头循环，如下图从9往后数7个，就会回到0。在微机中，如果运算超出了最大能够表示的范围，如在4位情况下无法表示16，计算机会发出一个溢出的中断，当然如果实际上计算机是8位的，5位的结果当然是可以表示的了。<br><img src="https://img-blog.csdnimg.cn/6c14a47349c34643b05a8e93a43ff6fe.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;在计算机中常说的64位操作系统是指可以同时运算64位的数据，即0到2^64-1的无符号数。可以看到现代计算机能计算的数的范围是相当大的。<br>&amp;ensp;&amp;ensp;问题来了，减法是如何实现的，大家可以发现，编码的时候都是对非负数编码的，我们秉着“减一个数就是加上它的相反数”的原则，就可以将加减法统一。所以减法的问题就变成了如何得到一个二进制数的相反数。<br>&amp;ensp;&amp;ensp;这里介绍目前计算机中使用的编码方式。<br>&amp;ensp;&amp;ensp;首先，我们可以在原来的基础上多弄一位出来表示符号，如用0 0010表示+2，用1 0010表示-2，这种编码称为原码，但这种编码看起来没啥问题，其实问题很大，读者将上面两个数相加，会发现+2+（-2）&#x3D; 1 0100B，即为-4，并不等于0，说明这种编码对运算是不相容的，同时，会出现1 0000B（-0）和0 0000B（+0）的区别，这种区别在现阶段是没有意义的，或者说是不必要的。产生这种问题的原因是原码是混合编码，即用符号+数制的方法表示，而运算只是针对数制，所以-2+（+2）只对数制部分相加即2+2&#x3D;4，前面符号不管怎么变化，结果都不会为0。<br>&amp;ensp;&amp;ensp;要想真正实现减法，需要将正负隐藏在数制中，即大家所知的补码。<br>&amp;ensp;&amp;ensp;<strong>补码是用最高位代表负权值，其余各位代表正权值</strong>，我认为这句才应该是补码的定义，大家可能学的都是什么“求反加1”的法则，当然是正确的，但那终究是规律，不好把握本质。这句话说起来比较抽象，举个栗子。<br>&amp;ensp;&amp;ensp;4位二进制数从0000到1111，拿1010出来，从上面的知识我们知道在无符号数8421BCD中表示10，在原码中，最高位表示符号，剩下的表示数值，则表示-2，在补码中，最高位表示负权值，什么是负权值，就是-1x2^?^，上面1010最高位的位权是3，即为2^3^&#x3D;8，但最高位表示负，则这一位表示的数就是-2^3^，即-8，后面都表示正权值，即为0x2^2^+1x2^1^+0x2^0^&#x3D;+2，所以这个补码表示的数是-8+2&#x3D;-6。整体运算过程如下：<br>&amp;ensp;&amp;ensp;-1x2^3^+0x2^2^+1x2^1^+0x2^0^&#x3D;-6。<br>&amp;ensp;&amp;ensp;同样的，可以说明1111表示-1：-1x2^3^+1x2^2^+1x2^1^+1x2^0^&#x3D;-8+7&#x3D;-1。<br>&amp;ensp;&amp;ensp;补码还有很多性质，这里选一些简单介绍一下。<br>&amp;ensp;&amp;ensp;首先，在补码状态下的减法运算，在舍弃最高位进位的情况下结果是正确的，如+6（0110）+（-6）1010&#x3D;1 0000，仍保留4位，即为0000B（0）。同时，+0和-0变一个0，因为1000表示为-8，不再表示-0。最后，4位二进制补码表示范围为-8到+7，n位二进制补码表示范围为-2^(n-1)^到2^(n-1)^-1。<br>&amp;ensp;&amp;ensp;当然求补码的最简单的方法还是“求反加1”（真香）。<br>&amp;ensp;&amp;ensp;乘法就是移位相加，除法就是移位相减，具体内容比较复杂，就不在这里介绍了。<br>&amp;ensp;&amp;ensp;本小节只是简单介绍一下计算机的运算方法，更为详细的内容各位可以查看数电和微机的相关知识。</p><h2 id="2-指令和语言"><a href="#2-指令和语言" class="headerlink" title="2.指令和语言"></a>2.指令和语言</h2><p>&amp;ensp;&amp;ensp;计算机只能认识0和1，从上面的知识我们知道了数据怎么参与运算的，现在我们要解决怎么让计算机计算。<br>&amp;ensp;&amp;ensp;听起来很奇怪，但确实如此，我们怎么让计算机把这两个数相加，怎么让它把结果放到哪个存储器中去，答案当然很粗暴，就是“告诉它”，当然直接说是不行的，它也听不懂。我们上面说了计算机只能认识0和1，所以我们的命令，即指令也要是用0和1表示，这种计算机能直接识别的二进制指令称为机器指令，机器指令的集合就是<strong>机器语言</strong>。例如我们想把某个数移到某个地方去，我们可以打一串01代码，这个代码是独特的，计算机取到这个代码就明白我们希望它做一个数据传输的操作，从而实现人机的交流。<br>&amp;ensp;&amp;ensp;当然，这样的指令又臭又长，不方便记忆，于是人们把这些指令符号化，用特定的符号代替那一串01代码，如用MOV表示数据传输，用ADD表示两个数相加，在配上固定的语法格式，就形成了汇编语言。当然机器不能认识MOV，ADD这种符号的东西，所以汇编语言（低级语言）和以后的高级语言都需要一个<strong>翻译器</strong>，将符号化的东西变回01代码，这一过程成为<strong>汇编</strong>。<br>&amp;ensp;&amp;ensp;汇编语言仍是比较低级的语言，人们又不断的更新，补充，最后就产生了各种高级语言，其中就有我们的主角——<strong>C语言</strong>（终于点题了……）。</p><h1 id="三、C语言基础上（从数据到程序）"><a href="#三、C语言基础上（从数据到程序）" class="headerlink" title="三、C语言基础上（从数据到程序）"></a>三、C语言基础上（从数据到程序）</h1><p>&amp;ensp;&amp;ensp;终于到了C语言的部分了，我会按块给大家讲解。</p><h2 id="1-数据"><a href="#1-数据" class="headerlink" title="1.数据"></a>1.数据</h2><p>&amp;ensp;&amp;ensp;这里说的数据已经不同于上面讲过的计算机中的数据存储方式和运算形式了，对高级语言来说，我们更关心它的整体性质。<br>&amp;ensp;&amp;ensp;C语言中的数据有两种表现形式，分为常量和变量。<br>&amp;ensp;&amp;ensp;<strong>常量</strong>就是不能改变的量，有一下几种：<br>&amp;ensp;&amp;ensp;<strong>整形常量</strong>：如具体的数字：123，0，-99等<br>&amp;ensp;&amp;ensp;<strong>实型常量</strong>，如12.3，55.6，0.35，-56.0（十进制小数形式），12.3e4，-5.3e2，-56.1e-3（指数形式，就是类似科学计数法，只不过对前面的数没啥要求）。<br>&amp;ensp;&amp;ensp;<strong>字符常量</strong>:’a’ ’n’ ’,’ ‘6’（普通字符，表示一个字符，要用单引号括起来，其存储的形式一般是ASCII，注意一次只能括一个,’kl’是不行的）<br><img src="https://img-blog.csdnimg.cn/9409e2ad54c045ebb33198a67eb6136a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="ASCII表"><br>&amp;ensp;&amp;ensp;字符常量还有一种叫<strong>转义字符</strong>，用来表示不能显示的字符（<strong>空格是可以显示的，你可以看到光标后移了！</strong>）常用\开头，如‘\t’表示将光标跳到下一个tab位置,’\n’表示换行,’\a’表示提示音,’\’表示要输出一个\（\被用作开头了，如果只写一个’\’，会被认为是转义字符的开头）<br><img src="https://img-blog.csdnimg.cn/733b1bcd817b47e698bf09e4745f80b5.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><font color=#999AAA >注：\ddd的例子：\101表示八进制数101的ASCII字符，查ASCII的表可知是A，所以’\101’和’A’是一样的，同理\x41表示十六进制41的ASCII字符，也是A。</p><p>&amp;ensp;&amp;ensp;<strong>字符串常量</strong>：如“aaa”，“156”，“*&#x2F;-+”等，用双引号括起来，注意：“a”也是一个字符串常量，因为字符串常量会在结尾有一个隐藏的\0作为字符串的结尾，所以“a”实际上是“a\0”，而   ‘a‘是只有一个a在里面的。<br>&amp;ensp;&amp;ensp;<strong>符号常量</strong>：用宏定义指令#define定义的常量，如 #define E 2.71828<br>我们将E这个符号名定义为一个数2.71828，这样后面用到E时，就会自动替代为2.71828。<br><strong>注：习惯上符号常量全大写。</strong></p><p>&amp;ensp;&amp;ensp;变量就是可以改变的量，它们的值通常是随着程序的进行不断变化的。变量要先声明才能使用，变量声明的语法如下：<br>&amp;ensp;&amp;ensp;int a；<br>&amp;ensp;&amp;ensp;double b；<br>&amp;ensp;&amp;ensp;int 代表这个变量的类型，a是这个变量的名称。<br>&amp;ensp;&amp;ensp;变量的类型是什么，其实就是对变量分配存储单元的安排。变量不同于常量，它是要一直变化的，所以计算机中会开辟一个内存的区域给这个变量，变量一变化，就改变这个内存区域的值，从而使内存区域保持当前的变量的值，那么这个区域有多大，就是要看变量类型了，我们可以用<strong>sizeof</strong>这个函数来查看某个变量的大小，如用int定义的变量，sizeof（int）显示为4，说明计算机在内存中为它开了4byte的空间（1byte &#x3D; 8bit，即8位），而double类型的大小位8byte，当然还有很多其他类型，他们的大小之间或许存在不同，当然有些还有更为重要的性质，将在下文介绍。<br>&amp;ensp;&amp;ensp;变量的大小有什么重要的吗？早在前面我们就提到过，如果一个数超过了能表示的范围，会发生什么？结果当然是错的，会变成对应的补码（参考前面9+7的例子），这对运算来说一般是不允许的，当结果可能溢出时，我们就要用更大的类型来放它。如果全用最大的类型来声明变量，发生溢出的可能性当然大幅下降，但内存是有限的，在内存中每开辟一个区域，内存就少一块，全用最大的类型来声明变量这种方法显然对内存的消耗是很大的，尤其是对于C51单片机这种内存本来就每多少的，这样的结果就可能会导致内存溢出。所以变量的声明是还是要合适。</p><p><img src="https://img-blog.csdnimg.cn/4cb887f7d8d54ee8aaad6480d3729a3e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;变量名的起法当然也是有规矩的，并不是说想叫什么叫什么，名字一般叫做标识符，C语言规定，标识符只能由字母、数字、下划线3种组成（想起中文名的小伙伴可以歇息了）,且第一个字符必须为字母或下划线，如_456,k456,KK,kk,_o_p_q_等都是可以的，但456，4h5就不行。注意：KK和kk是不同的变量，即标识符是区分大小写的！<br>&amp;ensp;&amp;ensp;变量名取的时候一定要有意义，好的变量名是成功的一半，我这里只是举例子随便写的，变量名的命名方法主流的有驼峰命名法，帕斯卡命名法，大家可以去学习一下。<br>&amp;ensp;&amp;ensp;下面对一些重点的变量类型进行介绍。<br>&amp;ensp;&amp;ensp;<strong>int——整型</strong>，大小占4byte，其特点是<strong>只能表示整数</strong>，如果在一个整型变量中存放了一个小数如2.6，实际上这个变量的值是这个数向0取整的值（即2），小数部分被忽略了，而不是四舍五入，如果在一个整型变量中存放了一个小数为-2.6，向0取整则为-2。<br>&amp;ensp;&amp;ensp;<strong>double——双精度浮点型</strong>，大小占8byte，整数小数都能表示。<br>&amp;ensp;&amp;ensp;<strong>float——单精度浮点型</strong>，大小占4byte，整数小数都能表示。<br>&amp;ensp;&amp;ensp;<strong>char——字符型</strong>，大小占1byte，以ASCII形式存储一个字符，如char a &#x3D; ‘A’，在内存中实际上存储的是A的ASCII，即65，所以char也可以看成是更小的int，因为它们都是只能存整数。需要注意的是，对char变量赋值为负数合法的，如char a &#x3D; -9，此时它就不表示一个字符，而是表示一个整数，其表示范围为-128到+127。<br>&amp;ensp;&amp;ensp;其余类型将会在后续介绍。<br>&amp;ensp;&amp;ensp;我们可以对变量类型加修饰词，从而适应更为丰富的情况。上面介绍的所有类型都可以加前缀unsigned，表示这个数不以负数形式存放，即使给它一个负数，如：<br>&amp;ensp;&amp;ensp;unsigned char a &#x3D; -1；<br>&amp;ensp;&amp;ensp;虽然在存储单元中放的是-1的补码，即1111 1111B，但计算机把它看做一个无符号数，当作8421码处理，则实际上a的值为255。<br>&amp;ensp;&amp;ensp;如果没有特殊声明，编译器都将默认为signed，即带符号数。<br>&amp;ensp;&amp;ensp;上面介绍的类型除了char外，其余都可以加long或short修饰，一般来说，long可以使原来的大小加倍，如原来double占8byte，long double 则占16byte；short使原来的大小减半，如原来的int占4byte，short int则占2byte。<br>&amp;ensp;&amp;ensp;可以在常量的末尾加专用字符，表明这个常量的类型，如1.26如果不加修饰，编译器将默认为double处理，但1.26f就是告诉编译器1.26是一个float类型的数，编译器就知道怎么处理了。同理，1.26L表示这是一个long double的数。<br>&amp;ensp;&amp;ensp;我们可以先声明一个变量，在去赋值，如：<br>&amp;ensp;&amp;ensp;int a;<br>&amp;ensp;&amp;ensp;a &#x3D; 10;<br>&amp;ensp;&amp;ensp;我们也可以在声明的时候就赋值，如int a &#x3D; 10;<br>&amp;ensp;&amp;ensp;我们只能操作具体的某个对象，如a，但不能对某个类型操作，所以int &#x3D; 10是非法的。<br>&amp;ensp;&amp;ensp;如果只声明而不赋值，结果就是编译器只是在内存中某个地方开辟了一块空间，但这个地方原来的值并没有被擦除，就成为了这个变量的默认初始值，由于我们不能确定一个变量被开在内存的哪一块区域，所以变量的初始值是随机且未知的，所以声明变量的同时一定要赋初值。<br>&amp;ensp;&amp;ensp;下面对变量进行进一步阐述。<br>&amp;ensp;&amp;ensp;<strong>当我们写下int a &#x3D; 10;发生了什么？</strong><br>&amp;ensp;&amp;ensp;我们声明了一个int类型，名字叫a的变量，并给了它初值10，由前面的知识，我们可以知道，编译器在内存中随机的开辟了一块大小是4byte的空间，并将这片空间原来的内容改为10，即0000 000AH（十六进制），同时给这块空间起了名字为a，a就代表了这片4byte的空间，我们对a操作，就是对这片空间进行操作，所以我们改变a的值，也就改变了这片区域的值，从而实现了“变量”的效果。</p><h2 id="2-运算"><a href="#2-运算" class="headerlink" title="2.运算"></a>2.运算</h2><p>&amp;ensp;&amp;ensp;简单的加（+）减（-）乘（*）除（&#x2F;），大家上过小学都知道是什么，就不多说了，介绍一下<strong>取余运算符%<strong>，A%B的结果就是用A除B的余数，需要注意的是，A和B都必须是整数。<br>&amp;ensp;&amp;ensp;需要注意的是不同的数据类型之间的运算，同类型之间没有问题，结果也是同类型的，</strong>其中int类型的计算需要注意</strong>，由于int没有小数，所以其结果不一定正确，如两个int类型的数3和6，做6&#x2F;3的除法，结果为2，用int表示没有问题，但如果是6&#x2F;4，结果是1.5，由于int向0取整数，所以结果为1，就会产生错误。<br>&amp;ensp;&amp;ensp;不同类型之间遵循隐式转换，默认向更大的类型转换，如一个int类型的数加一个double类型的数，int类型会自动转换为double，结果也为double，同理，long double类型的数和double类型的数预算，double也会先转换为long double，再运算。<br>&amp;ensp;&amp;ensp;我们也可以使用强制显示转换，如float a &#x3D; 1.56f，前面说过这是一个float类型的数，<br>&amp;ensp;&amp;ensp;如果我们希望在运算中a以int类型进行运算，就可以在运算式中将a用（int）a替代，这样就强制将float转换为int，一般来说这样必然会带来精度损失，不过有时我们希望只取整数运算。显示转换只在当前这一句中生效，a的值实际上并没由被改变，还是float型，值为1.56f，只是在运算中它临时变为int型，值为1。<br>&amp;ensp;&amp;ensp;我们都知道+5和-5是什么意思，一个正数一个负数嘛。同样的对一个变量a，+a和-a的意思大家也能猜出来了，+a就是a，-a表示a的相反数。如果a为负数，+a还是a，是负数，由+（-5）还是-5这个例子大家应该很好理解。<br>&amp;ensp;&amp;ensp;C语言对这些基本运算有简化的写法，如果有这样一行代码：a &#x3D; a+5；那它可以简化为a +&#x3D; 5；同样的减乘除取余都可以简化。如果&#x3D;右侧是也是表达式，先计算右侧的值，如a*&#x3D;b+c，那么先计算b+c，再将这个结果与a相乘赋给a。<br>&amp;ensp;&amp;ensp;<strong>1</strong>.加加减减运算符（请允许我这么叫它们）<br>&amp;ensp;&amp;ensp;首先我们引出单目运算符和双目运算符以及三目运算符。<br>    &amp;ensp;&amp;ensp;对于上面的+a，-a，大家发现这些运算只用一个操作数，即只要一个数就能运算，这种运算符成为单目运算符（+，-）。<br>&amp;ensp;&amp;ensp;而对于加减乘除取余，需要两个操作数，叫双目运算符。<br>&amp;ensp;&amp;ensp;对于三目运算符，那肯定是要三个数才能算的了，C语言种只有一个三目运算符，是？，将在后面介绍。<br>&amp;ensp;&amp;ensp;加加减减运算符也是单目运算符，即只要一个数就能算，其格式是：<br>&amp;ensp;&amp;ensp;a++，a–，++a，–a<br>&amp;ensp;&amp;ensp;其中a必须是变量，++的结果是使原来a的值自加1，再返回给a，即a++和a &#x3D; a+1等价，同理–的结果是使原来a的值自减1，再返回给a。说白了就使让变量a自己加1或者减1，通常在需要记录次数的时候用。<br>&amp;ensp;&amp;ensp;<strong>重点来了，++a和a++有什么区别。</strong><br>    &amp;ensp;&amp;ensp;<strong>先上结论：++a是先使a加1，再使用a的值；a++是先使用a的值，再使a加1。</strong><br>&amp;ensp;&amp;ensp;听起来很拗口，举例子就好啦。<br>    &amp;ensp;&amp;ensp;我们定义了一个变量j和i，并对他们幅了初值0。则：<br>    &amp;ensp;&amp;ensp;a.1j &#x3D; i++；<br>    &amp;ensp;&amp;ensp;b.2j &#x3D; ++i；<br>&amp;ensp;&amp;ensp;j的值将不同，虽然最后i的值都加1了，但由于执行的循序不一样，导致j的值不同。在○1中，由于++在后面，所以先使用i的值，那么这里用i的值干什么了呢？将i的值赋给了j的值，因为先使用，i还没加1，所以j等于i原来的值，即为0；而对于○2，由于++在前面，要先使i加1，则i变为1，再使用i的值，将i的值赋给了j的值，所以j的值为1.减减的道理是一样的，–a是先使a减1，再使用a的值；a–是先使用a的值，再使a减1。<br>&amp;ensp;&amp;ensp;这两个例子都是最直接最基础的，可能比较简单，但道理是明显的，由于加加减减运算符可以在一个语句中被多次、不同地方的使用，所以需要把握好这些基本概念。<br>&amp;ensp;&amp;ensp;对于什么++（i++）+++i这种没个十年脑血栓写不出来的代码，但总是有人喜欢考的东西，我只能说各位多做题吧……<br>    &amp;ensp;&amp;ensp;<strong>2</strong>.比较运算符<br>    &amp;ensp;&amp;ensp;大于（&gt;），小于（&lt;），等于（==），注意等于是两个等号；大于等于（&gt;&#x3D;），小于等于（&lt;&#x3D;）,不等于（！&#x3D;）。这几种比较运算符有小学知识概念应该可以理解，这些运算符是有返回值的，即它们是有结果的，如5&gt;6，这个结果明显是假的，则这个式子的值是0，如果用一个变量a &#x3D; 5&gt;6，则a的值变为0。同样的，6 =&#x3D; 6是成立的，则这个式子的值是1，如果用一个变量a &#x3D; 6==6，则a的值变为1。<br>    &amp;ensp;&amp;ensp;<strong>3</strong>.逻辑运算符<br>    &amp;ensp;&amp;ensp;逻辑与（&amp;&amp;），逻辑或（||），逻辑非（！），逻辑运算符表示多个bool之间的组合，与就是“一假全假，全真才真”，或是“一真则真，全假才假”，非就是和原来的反着来。这些比较基础没啥可说的，大家自学也可以学习，就不多赘述了。<br>    &amp;ensp;&amp;ensp;应当指出<strong>特殊情况</strong>，如（5&#x3D;&#x3D;6 &amp;&amp; a++ !&#x3D; 7）,这个逻辑与将两个逻辑式5 &#x3D;= 6和a++！&#x3D;7结合起来，有前面的知识我们知道，只要有一个逻辑式为假，整个结果都是假的，实际上运行的时候一看，发现5 &#x3D;&#x3D; 6已经是假的了，那这个逻辑式就一定为假，其结果为0，后面的a++！&#x3D;7是否成立根本就不需要看，所以它就不看了，但大家发现什么不对劲的没有？a++！&#x3D;7中包含了一个执行表达式（请允许我这么叫）a++，原本这个表达式是判断a是否等于7，再将a+1，现在不执行了，a+1这一步就没了，所以a的值就不变了！这一点在有些时候是致命的，如果a是一个循环次数的话，整个程序可能会产生死循环，需要注意这一点。同理逻辑或在前面为真的情况下也不会管后面的逻辑表达式了。<br>&amp;ensp;&amp;ensp;<strong>4</strong>.三目运算符（？）<br>    &amp;ensp;&amp;ensp;三目运算符其实就是一个简单的比较和返回的组合，和条件分支（后文介绍）类似，其基本用法：<br>    &amp;ensp;&amp;ensp;条件？是：否<br>    &amp;ensp;&amp;ensp;如x&gt;10?a&#x3D;5:a++<br>    &amp;ensp;&amp;ensp;三目运算符对条件进行判断，如果为真（成立），就执行冒号之前的操作，如果为假，就执行冒号后面的操作。这里的操作可以是多样的，可以为赋值，也可以是其他的算术表达式。<br>    &amp;ensp;&amp;ensp;注意这是一个整体，？和：必须配对使用。<br>    &amp;ensp;&amp;ensp;<strong>5</strong>.优先级和结合性<br>    &amp;ensp;&amp;ensp;单目的优先级高于双目的高于三目的，括号优先级最高，赋值运算符最低，目前所学的优先级这样排列就可以了。<br>    &amp;ensp;&amp;ensp;对于同级运算符，算术运算符都是自左向右运算的，如a+b+c，先计算a+b，再计算加c的值，这种结合性又称为左结合性。赋值运算符（将下面介绍）具有右结合性，如a&#x3D;b&#x3D;c，是先将c的值给b，再将b的值给a。<br>&amp;ensp;&amp;ensp;<strong>6</strong>.赋值运算符<br>    &amp;ensp;&amp;ensp;这里将赋值作为一种运算，即数据传输的操作。<br>    &amp;ensp;&amp;ensp;在编程中，&#x3D;代表赋值运算符，它并不代表左右两边相等这一状态（数学中等号的概念），而是表示将&#x3D;右边的值（右值）赋给&#x3D;左边的值（左值）。赋值运算符的左值要是一个可以修改的值，如变量，不能修改还要赋给不同的值，这显然是不行的，算术表达式也不能做左值。右值的要求低了很多，凡是左值都可以做右值，这意味着赋值运算符可以“连等”，如a&#x3D;b&#x3D;b+c<br>&amp;ensp;&amp;ensp;有上面的结合性可知，先将b+c的值给b，此时b是左值，再将b的值给a，此时b是右值。但a&#x3D;b*c&#x3D;b+c是非法的，因为b*c对右侧的&#x3D;而言是左值，而它本身是算术表达式。</p><h2 id="3-语法"><a href="#3-语法" class="headerlink" title="3.语法"></a>3.语法</h2><p>&amp;ensp;&amp;ensp;语句的概念很多，但很多只用了解就可以，这里重点介绍一下语句和表达式。<br>    &amp;ensp;&amp;ensp;语句一般是成对的，如if（）else；或者是表达式后加分号的，如a+&#x3D;5；一般来说后面有分号的是语句。<br>&amp;ensp;&amp;ensp;表达式种类就很多了，前面的算术表达式都可以。<br>&amp;ensp;&amp;ensp;如赋值语句a&#x3D;3；它是由赋值表达式a&#x3D;3加上后面的分号构成的。<br>&amp;ensp;&amp;ensp;如a+&#x3D;3；它是由算术表达式a+&#x3D;3加上后面的分号构成的。<br>&amp;ensp;&amp;ensp;如i++是表达式，它是算术表达式，加上分号后i++；才是语句。<br>&amp;ensp;&amp;ensp;如x+y；也是语句，可以简单的认为它后面有分号，当然实际上它是一个算术表达式，它是结果是x+y的值，但这个值并没有保存到某个地方之中（如变量），所以这个表达式并没有产生实质性的作用，因为它的值在这个语句执行完后就不见了。<br>&amp;ensp;&amp;ensp;空语句——只要一个分号，啥内容也没有。看起来很没有，其实有时候可以起到占位的作用。<br>&amp;ensp;&amp;ensp;复合语句，用一对大括号{}括住的语句，是一个整体，可以看作复合语句，现在复合语句的作用貌似没有，之后它的作用将会大大体现。<br>    &amp;ensp;&amp;ensp;分号是语句的特征，表示一个语句的结束，是语句之间的分界。<br>    &amp;ensp;&amp;ensp;下面对赋值语句进行讲解。<br>&amp;ensp;&amp;ensp;首先要说明的是，赋值表达式也是有值的，它不仅实现的赋值操作，它本身也有值，其值为赋的值的值，拗口？上例子。<br>&amp;ensp;&amp;ensp;如a&#x3D;6+（c&#x3D;4）<br>    &amp;ensp;&amp;ensp;这是一个赋值表达式，当然它中间还有一些算术表达式。首先看括号的，将4赋给c，同时这个赋值表达式也有值，就是赋值的值，即为4，再加上6赋给a，所以a是10，当然赋给a这一步也是一个赋值表达式，所以上面这个赋值表达式最后也是有值的，值为赋给a的值，即为10，如果b&#x3D;a&#x3D;6+（c&#x3D;4），那么b的值就变成了10。<br>    &amp;ensp;&amp;ensp;注意a&#x3D;6+c&#x3D;4是不对的，因为+的优先级高于&#x3D;，所以会先计算6+c，而这个是算术表达式，却作为&#x3D;4的左值，所以编译会报错。<br>&amp;ensp;&amp;ensp;从上面我们也可以看出表达式可以嵌套表达式，这使得C语言的表达式可以变得相当复杂。<br>    &amp;ensp;&amp;ensp;需要说明的是，在定义变量是，我们可以<br>&amp;ensp;&amp;ensp;int a&#x3D;3,b&#x3D;3,c&#x3D;3;<br>&amp;ensp;&amp;ensp;用这种方法定义多个同类型的变量，并给它们赋初值，如上面就定义了3个整型的变量，初值都为3。但 int a&#x3D;b&#x3D;c&#x3D;3;是不行的。</p><font size=5>#代码训练与详解</font><p>&amp;ensp;&amp;ensp;OK，现在我们已经入门差不多快一半了。有了上面的基础，我们就可以写一些自己的代码了。（终于见代码了……）<br>    &amp;ensp;&amp;ensp;这里我使用的是Dev-C++ 5.11版本，在64位windows10环境下运行。用Dev-C++的原因首先是因为操作简单，不用建立项目，第二是因为当初我学C的时候就是用的这个，虽然现在用VS用的比较多，但VS写C事情很多，对初学者来说，能用、简洁才是最好的。<br>    &amp;ensp;&amp;ensp;好了，让我们开始敲代码的旅途吧。<br>    &amp;ensp;&amp;ensp;打开后是这样的：<br><img src="https://img-blog.csdnimg.cn/9ac78edca0f142ed873cce0b1b30d3ee.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;点开文件-&gt;新建-&gt;源代码<br><img src="https://img-blog.csdnimg.cn/669b5cdf6cb847e8977936117e629c65.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;之后会变成这样<br><img src="https://img-blog.csdnimg.cn/f4a51df7f73841cfac3ae4ed2369f706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;当然这个是我已经调教过了，不过左上角会显示一个未命名的栏这个是一样的。大家可以在工具-&gt;编译器选项中选择调教。<br><img src="https://img-blog.csdnimg.cn/b01efc93aeb040c39b68f3dd930013c5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;这里可以改变字体和大小，也可以显示行号。<br>&amp;ensp;&amp;ensp;现在，我们可以开始了。<br>&amp;ensp;&amp;ensp;首先，先来个经典的Hello World。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;OK，差不多之后呢，我们先保存一下，ctrl+s，会弹出保存的框。<br><img src="https://img-blog.csdnimg.cn/1701bca9ee71442cba0dc7201a724482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;这里大家可以选择保存的地方，注意保存类型在下拉中要选.c的。<br><img src="https://img-blog.csdnimg.cn/cf15897c5e584a429c5d49b2aa29a219.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;这样才是C语言的形式。<br>&amp;ensp;&amp;ensp;点击保存，OK。<br>&amp;ensp;&amp;ensp;接下来大家关注这几个<br><img src="https://img-blog.csdnimg.cn/5f11b774c19d45ebb02a4f9f3d6fdc8c.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;圈住的从左到右依次是<strong>编译，运行，编译运行，全部重新编译，调试</strong>。<br>&amp;ensp;&amp;ensp;这些听不懂，没关系。还记得我们开头说过的，机器只认识0和1，而我们写的高级语言全是符号化的，所以我们需要一个翻译官，把我们写的翻译成机器看的懂的，这一过程就叫编译，对应上面最左边的按钮，编译是重要的，一方面是当翻译官，另一方面是编译器会在这一步帮我们查一下语法错误，比如语句的标志性分号少啦，算术表达式当左值啦什么的，很有用。翻译完了，我们希望计算机执行一下，就是运行。当然编译运行就是先编译，在运行。全部重新编译是针对多文件编程时候的，现在先不介绍。调试是所有程序员必备的，也是最头疼的，会在适当的时候为大家介绍。<br>现在，让我们编译运行一下这个源代码。<br><img src="https://img-blog.csdnimg.cn/8703dc3e8a6e4c479b4d11fbde4f3035.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;它弹出一个这样的小窗，叫“小黑窗”（我一直都是这么叫的，不过问题不大……），上面写这我们希望的话Hello World，表示我们成功啦。<br>&amp;ensp;&amp;ensp;现在让我们来看看原码<br>#include&lt;stdio.h&gt;<br>int main()<br>{<br>&amp;ensp;&amp;ensp;printf(“Hello World”);<br>&amp;ensp;&amp;ensp;return 0;<br>}<br>&amp;ensp;&amp;ensp;大家会发现，这么多单词，最后只能看见一个Hello World，那么别的那些是干什么的呢？<br>&amp;ensp;&amp;ensp;<strong>编程是有框架的，就像数学题先写个解，编程也是有固定格式的</strong>，大家现在可以认为其他部分是编程的固定格式，每次编程的时候把这个格式敲上就行了，当然我不会只满足于说这种大空话，水文章，<strong>下面我会尽量用不超纲的语言向大家描述这个原码的组成部分。</strong><br>&amp;ensp;&amp;ensp;首先，大家会看到打头的#include&lt;stdio.h&gt;，这是什么意思呢，其实这个不是每个都是必要的，比如下面的程序<br><img src="https://img-blog.csdnimg.cn/41d6653123234ed9b17e503b3355d49a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;它也是可以运行的<br><img src="https://img-blog.csdnimg.cn/f33d1909489e4235ac7c6421b4f89bcb.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;只是这次小黑窗和上次相比变空了，大家发现了什么不同吗？<br>&amp;ensp;&amp;ensp;Hello World的程序里面有一个printf，后面这个没有。<br>&amp;ensp;&amp;ensp;如果我们不写#include&lt;stdio.h&gt;<br><img src="https://img-blog.csdnimg.cn/cb24553926304b52b2710e99420652fe.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;编译器会报一个警告，说它不认识printf。<br>&amp;ensp;&amp;ensp;看来#include&lt;stdio.h&gt;和printf关系很大啊，<strong>实际上#include&lt;stdio.h&gt;就是为了printf服务的</strong>，printf我前面都没有介绍过（当然会在下一节介绍），因为它不是C语言自带的，我们打一个int，C语言编译器知道这是一个整型变量的类型，是因为C语言的创造者就是这样规定的，而printf并不是官方规定的，所以C语言编译器不认得。<br>&amp;ensp;&amp;ensp;我要怎么让它认识这个printf呢，<strong>实际上printf是定义在一堆文件中（头文件），你编译器不是不认得吗，我直接把说明书给你，说明书里告诉你printf是干啥的，怎么用的，这样我后面用printf的时候，编译器就知道了，这是说明书里的东西，就认得了</strong>。这个说明书就是头文件，把说明书给编译器的过程就是#include&lt;stdio.h&gt;这句的作用，叫做包含头文件。<br>&amp;ensp;&amp;ensp;这个说明书的名字是stdio.h，其中.h表明这是个说明书，就像.mp4是视频的后缀一样。说明书里详细说明了printf的用法，当然一个说明书里还可能有别的东西的用法，这里先按下不表。<br>&amp;ensp;&amp;ensp;OK，说完了第一行是干啥的，我们来看后面。<br>int main()<br>{<br>&amp;ensp;&amp;ensp;printf(“Hello World”);<br>&amp;ensp;&amp;ensp;return 0;<br>}</p><p>&amp;ensp;&amp;ensp;大家首先会看到一个熟悉的int，后面有一个main（），这是啥？<br>&amp;ensp;&amp;ensp;我这里写了2个差不多的东西</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">tese</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NUM.2&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NUM.1&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;除了main变成了test，剩下的都没有本质区别，我们运行看看。<br><img src="https://img-blog.csdnimg.cn/dce25c95684c4f1c9fe40afddbabf971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;它显示的是NUM.1，有Hello World的例子大家应该能猜到printf的作用，<strong>就是把“”中间的内容打印到小黑窗上</strong>，现在小黑窗上是NUM.1，说明程序只执行了在main里的东西，test里的东西没有执行，所以就没有显示NUM.2。<br>&amp;ensp;&amp;ensp;看来区别在main和test，实际上，我们写的很多，<strong>但程序不是从头开始执行的</strong>，哪怕是第一行#include&lt;stdio.h&gt;，程序执行的时候也不是从这里执行的，而是统一从main里执行（注：里的意思是main（）后面一对大括号{ }之间的算main的里）.#include&lt;stdio.h&gt;作用上面说了，是告诉编译器printf干什么的，<strong>当我们编译的时候，编译器充当翻译官，他从哪里开始翻译呢，并不是从开头，而是从main里的第一句</strong>，这是他碰到了printf，他知道这个在stdio.h的说明书里见过，于是他去查看了说明书，知道printf是干什么的，他再将printf翻译成计算机懂了0和1代码，整体是这样的过程。test不在main中出现过，所以翻译官就不去翻译，因为他就没见到test（他只翻译main里的，外面不管）。<br>&amp;ensp;&amp;ensp;OK，那么还有一个东西。return 0；是什么。<br>&amp;ensp;&amp;ensp;大家现在可以粗略的认为这是翻译官翻译的结束标识符，当翻译官看到这个语句，他知道自己的活干完了。（当然这么解释是不对的，具体需要到函数的知识讲解之后才能解释这个点，这里只是让大家对程序有更为感性的认识。）</p><p>&amp;ensp;&amp;ensp;好了，程序的框架我们已经搞定了，下面让我们看个例子<br>&amp;ensp;&amp;ensp;<strong>例：计算圆的周长。</strong><br>&amp;ensp;&amp;ensp;首先，我们知道圆的周长C&#x3D;Π*d，d为直径。<br>&amp;ensp;&amp;ensp;我们希望对于不同的d，这个程序都能使用，这意味着d是可变的，可变的，想到了什么？对啦，变量，我们用一个变量来放d，d是变量，得出的C也是变量。Π是3.14159，这个数是不会改变的，是什么？常量。现在，我们可以开始编程了。<br>&amp;ensp;&amp;ensp;框架部分当然要照写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">double</span> d = <span class="hljs-number">5</span>,C;<br>C = <span class="hljs-number">3.14159</span>*d;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;C = %lf&quot;</span>,C);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>‘&amp;ensp;&amp;ensp;’于是，我们写出了这样的程序。<br>&amp;ensp;&amp;ensp;大家也许会发现，这个printf怎么变了，里面东西不一样了。人家是可以有多胞胎的啊，printf有很多种，都在说明书里，所以这个也可以用，至于怎么用，是下一节的事情，现在大家只要知道这语句可以把变量C的值打印在小黑窗上就OK了。<br>&amp;ensp;&amp;ensp;这个程序中，我们计算的是直径d&#x3D;5的周长，运行后结果为<br><img src="https://img-blog.csdnimg.cn/8221a01c46374a26b0ff5c79edaa581e.png#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><p>&amp;ensp;&amp;ensp;用计算器算一边结果是一样的，说明这个是正确的。<br>&amp;ensp;&amp;ensp;如果我想算d&#x3D;6，我只需要改double d &#x3D; 6,C;就OK。<br>&amp;ensp;&amp;ensp;当然，大家会发现这个程序需要每次改完，重新编译运行才行，好像d的值根本不需要，既然每次d的值都是写死的，那我直接带入不就行了？<br>&amp;ensp;&amp;ensp;确实，现在是这样的，但当我们学了如何从键盘上读入数据之后（当然，也在下一节），我们就可以每次从键盘上输入不同的值，而不用更改源代码，这才是变量真正发挥作用的时候。</p><p>&amp;ensp;&amp;ensp;再来一个例子。<br>&amp;ensp;&amp;ensp;<strong>例：找出5个数之间的最大数</strong><br>&amp;ensp;&amp;ensp;我们先设5个数为1，100，520.1314，-1.1，-20<br>&amp;ensp;&amp;ensp;这里有两个数是有小数的，所以我们可以都用double来定义。<br>&amp;ensp;&amp;ensp;那怎么比较呢？<br>&amp;ensp;&amp;ensp;虽然能一眼看出来，但这种简单的操作计算机往往做不到。计算机只能一个一个比较。<br>&amp;ensp;&amp;ensp;能实现比较的操作——当然是<strong>三目运算符啦</strong>，我们这里用三目运算符，先假设一个个数最大，让它与第二个比较，如果第二个比较大，就将最大的数变为第二个，否则还是第一个数。以此类推，比4次就OK了。<br>&amp;ensp;&amp;ensp;我们得到下面的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">double</span> a=<span class="hljs-number">1</span>,b=<span class="hljs-number">100</span>,c=<span class="hljs-number">520.1314</span>,d=<span class="hljs-number">-1.1</span>,e=<span class="hljs-number">-20</span>;<br><span class="hljs-type">double</span> max = a;  <span class="hljs-comment">//最大的数</span><br>max&gt;b?:(max= b);<br>max&gt;c?:(max = c);<br>max&gt;d?:(max = d);<br>max&gt;e?:(max = e);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,max);<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;ensp;&amp;ensp;这里：前面没有，代表着如果条件为真，就不操作。<br>&amp;ensp;&amp;ensp;注意：这里的括号是必要的，因为赋值操作的优先级最低，如果max&gt;b?:max&#x3D; b;编译器会先运算max&gt;b?:max这个三目运算符，但这个是算术表达式，作为了&#x3D;b的左值，所以会报错。</p><p><strong>补充：注释的方法</strong><br>&amp;ensp;&amp;ensp;注释就是给人看但不给编译器看的东西，编译器在翻译的时候不管注释，注释对于别人还有自己看自己的代码都很有帮助，自己不写注释过几天自己都不知道写的是什么，所以要养成写注释的好习惯。C语言注释的写法有两种<br>&amp;ensp;&amp;ensp;1.&#x2F;&#x2F;双斜线后面的这一行的所有内容都是注释，如上面的例子。<br>&amp;ensp;&amp;ensp;2.&#x2F;*  *&#x2F;  用这种符号括起来的东西是注释，如&#x2F;* 这是注释！*&#x2F;<br>&amp;ensp;&amp;ensp;第二种注释可以跨很多行，只要配对就行<br><img src="https://img-blog.csdnimg.cn/6686f256cc20477d9e593f5a617ee6d3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU1OTcxNDQ5,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>&amp;ensp;&amp;ensp;被注释的字体颜色会发生变化，大家可以清楚的看出注释是否成功。</p><p>&amp;ensp;&amp;ensp;好了，这一讲真是讲了不少东西。大家消化可能也需要一阵了，当然笔者也不是大佬，自然会有疏忽遗漏的地方，但笔者是想用自己的方式，向更多想学习C语言的人介绍和入门这门语言，欢迎各位读者指正。</p><p>&amp;ensp;&amp;ensp;<strong>我们下一讲再见！</strong></p>]]></content>
    
    
    <categories>
      
      <category>知识总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识总结</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
